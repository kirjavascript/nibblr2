{
    "name": "golf.tasks",
    "command": "const trueJSON = JSON;\n\nconst stringify = (obj) => {\n    const output = trueJSON.stringify(obj) || 'undefined';\n    return output.length > 100\n        ? output.slice(0, 100) + ' ...'\n        : output;\n};\n\nfunction removeEval() {\n    const stub = eval = Function = function(){throw \"eval disabled\"};\n    [function(){}, async function(){}, function*(){}, async function*(){}].forEach(x=>{\n        const proto = Object.getPrototypeOf(x);\n        delete proto.constructor;\n        proto.constructor = stub;\n    });\n}\n\nconst { isEqual } = _;\n\nBigInt.prototype.toJSON = function() { return `${this.toString()}n`; };\n\nfunction assertType(a, type) {\n    if (typeof a !== type) {\n        throw new Error(`expected {dc}${type}{/} got {o}${typeof a}{/}`);\n    }\n}\n\nfunction assertEq(a, b) {\n    if (!isEqual(a, b)) {\n        throw new Error(`expected {dc}${stringify(b)}{/} got {o}${stringify(a)}{/}`);\n    }\n}\n\nfunction assertCall(result, expected, ...args) {\n    const output = result(...args);\n    if (!isEqual(expected, output)) {\n        const params = args.map(stringify).join`, `;\n        throw new Error(`expected {dc}${stringify(expected)}{/} got {o}${stringify(output)}{/}  (params: {dp}${params}{/})`);\n        \n        throw 'up';\n    }\n}\n\n\nmodule.exports = {\n    'logo': {\n        task: () => print('{bo}Write an expression that evaluates to the string:{/} ' + IRC.colors.link('http://ix.io/1JLF') + ' (the string is trimmed before comparison)'),\n        test: (solution) => {\n            const jsgolf = `#############################################\n#                                           #\n#      #  ####   ####   ####  #      ###### #\n#      # #      #    # #    # #      #      #\n#      #  ####  #      #    # #      #####  #\n#      #      # #  ### #    # #      #      #\n# #    # #    # #    # #    # #      #      #\n#  ####   ####   ####   ####  ###### #      #\n#                                           #\n#############################################`;\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                assertEq(result.trim(), jsgolf);\n            });\n        },\n    },\n    'ROT13': {\n        task: () => print('{bo}Write a function that returns a ROT13 ciphered version of its input string.\\nYour solution needs to cover the characters; abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertEq(result('NOPQWXYZabcdefghijklmABCGHIJKLMnopqrstuvwRSTUVDEFxyz'), 'ABCDJKLMnopqrstuvwxyzNOPTUVWXYZabcdefghijEFGHIQRSklm');\n                assertEq(result('HKLMUVDEefgpyzbcdTtuvnoXYNOPQWhijklmqrsZaxABCGwRSIJF'), 'UXYZHIQRrstclmopqGghiabKLABCDJuvwxyzdefMnkNOPTjEFVWS');\n            });\n        },\n    },\n    'hex2rgb': {\n        task: () => print('{bo}Write a function to convert a hex color ({o}#FFFFFF{/}{bo}) or ({o}#FFF{/}{bo}) to rgb ({dc}rgb(255,255,255){/}{bo})'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertEq(result('#B04B4B'), 'rgb(176,75,75)'); \n                assertEq(result('#7E88E6'), 'rgb(126,136,230)'); \n                assertEq(result('#1FA11F'), 'rgb(31,161,31)'); \n                assertEq(result('#123'), 'rgb(17,34,51)'); \n                assertEq(result('#7FFFD4'), 'rgb(127,255,212)');\n                assertEq(result('#B0E0E6'), 'rgb(176,224,230)');\n                assertEq(result('#5F9EA0'), 'rgb(95,158,160)');\n                assertEq(result('#4682B4'), 'rgb(70,130,180)');\n                assertEq(result('#6495ED'), 'rgb(100,149,237)');\n                assertEq(result('#00BFFF'), 'rgb(0,191,255)');\n                assertEq(result('#1E90FF'), 'rgb(30,144,255)');\n                assertEq(result('#ADD8E6'), 'rgb(173,216,230)');\n                assertEq(result('#87CEEB'), 'rgb(135,206,235)');\n                assertEq(result('#87CEFA'), 'rgb(135,206,250)');\n                assertEq(result('#666'), 'rgb(102,102,102)');\n                assertEq(result('#F00'), 'rgb(255,0,0)');\n            });\n        },\n    },\n    'quine': {\n        task: () => print('{bo}Write a quine'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                if (result.length < 1) throw new Error('program length must be non-zero');\n                if (result != solution) throw new Error('output doesn\\'t match source');\n            });\n        },\n    }, \n    'cross': {\n        task: () => print('{bo}Write an expression that evaluates to the string:{/} ' + IRC.colors.link('http://ix.io/1FZt') + ' (the string is trimmed before comparison)'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const art = `#......#\\n.#....#.\\n..#..#..\\n...##...\\n...##...\\n..#..#..\\n.#....#.\\n#......#`;\n                assertType(result, 'string');\n                assertEq(result.trim(), art);\n            });\n        },\n    },\n    'wordpath': {\n        task: () => print(`{bo}Given two single words, return a word path ({y}array{/}{bo}) from word a to word b where the word changes one character at every step. All steps have to be valid words in the dictionary at {p}global.words{/}{bo}, and all words will be of length 4. for example: ('more', 'fact') => ['more', 'fore', 'fort', 'fart', 'fact']. the full wordlist is here: https://paste.rs/I4c`),\n        test: (solution) => {\n            const words = Object.freeze('abed,abid,ahed,ails,ains,aked,albe,albs,aloe,alow,amid,anew,arbs,asar,aunt,axed,axel,axil,bait,bale,balk,bane,bank,bare,barn,base,bays,bazz,beal,bene,bent,best,bile,bima,bine,bint,bobs,boep,bogs,bois,bola,bolo,book,boon,boos,bork,boss,bota,boun,brag,brap,brig,bris,buik,bums,bunt,burk,busk,buss,caca,cain,call,cann,cans,cavy,cill,clow,cobs,coca,coda,come,coms,cone,coof,coop,coos,crab,crag,crow,dans,dead,deaf,dear,deaw,deer,diol,dire,dirl,disa,dish,diva,dobe,doby,dore,dorr,dosh,dote,doun,doup,dour,duck,dush,eans,ease,eats,elks,elts,emes,emic,emit,enew,epic,eres,erns,ests,eugh,exes,exit,eyra,fags,fall,farl,fell,fibs,figs,fill,filo,fils,flow,frig,fris,friz,fros,frow,fuck,fums,gamp,garb,gars,gaus,gays,gien,gies,gips,glow,goaf,goal,goof,goon,goos,gors,gris,gush,gust,gymp,hahs,hail,hare,hark,hauf,haul,haze,head,hear,heat,hell,hent,herd,hery,high,hish,hons,hops,hork,houf,hubs,hups,iris,iwis,kail,kais,kans,keas,kens,khud,kobs,ksar,kuru,lace,laze,lead,lean,lear,leas,lehr,lept,lice,life,limy,lins,liny,lone,loof,loos,lote,lush,lyne,lynx,lyra,maar,maas,mala,malt,mats,meal,meck,mere,mese,mesh,mick,mini,miny,mosh,muni,murk,mush,muti,nain,nams,nats,naze,nigh,oboe,obol,ohed,oink,ordo,ords,oups,past,peck,pips,plot,plow,pock,poep,poke,pone,pons,poon,poop,poot,post,pugh,push,rahs,rait,rare,rase,raze,razz,read,rean,redd,reno,reny,riff,rifs,rima,rimu,roke,rota,rurp,ruru,rusk,sall,salp,salt,samp,scry,sept,sext,shen,shew,shim,shin,ship,shit,shop,sigh,sigs,sile,silo,sinh,sink,skeg,sken,slit,soda,sogs,solo,soop,spec,spic,spry,sten,swam,swan,swim,tala,tehr,tene,thin,thud,tiff,toff,tops,umph,umpy,vale,viae,vine,vire,wale,waly,wast,wavy,waxy,wink,wins,wons,yaar,yarn,yelm,yelp,yest,yock,ywis'.split`,`);\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                const _result = result;\n                result = (...args) => {\n                    global.words = words\n                    return _result(...args);\n                };\n\n                const diff = (a, b) => {\n                    let count=0;\n                    for(let i=0; i< a.length; i++) {\n                        if( a[i] !== b[i]) count++\n                    }\n                    return count\n                }\n\n                function assertPath(start, end) {\n                    const wordpath = result(start, end);\n                    if (wordpath.length < 2) {\n                        throw 'word path is not long enough'\n                    }\n                    if (wordpath[0] !== start) {\n                        throw `first word in array is not ${start}`\n                    }\n                    if (wordpath[wordpath.length-1] !== end) {\n                        throw `last word in array is not ${end}`\n                    }\n\n                    if( wordpath.map( w => words.includes( w)).filter( x=>x===false).length>0) {\n                        throw ( 'some of those words are probably not real words')\n                    }\n                    for(let i=0; i< wordpath.length-1; i++) {\n                        if(diff( wordpath[i], wordpath[i+1])!==1) {\n                            throw ( wordpath[i] + ' and ' + wordpath[i+1] + ' either differ too much or are the same')\n                        }\n                    }\n                }\n\n                [[\"swim\", \"shim\"], [\"ohed\", \"amid\"], [\"pugh\", \"dosh\"], [\"coof\", \"cobs\"], [\"goal\", \"loof\"], [\"khud\", \"khud\"], [\"pons\", \"roke\"], [\"eugh\", \"pugh\"], [\"loos\", \"garb\"], [\"dans\", \"nain\"], [\"flow\", \"crow\"], [\"lote\", \"dour\"], [\"yelm\", \"yelp\"], [\"viae\", \"bint\"], [\"rota\", \"solo\"], [\"soop\", \"soop\"], [\"boon\", \"doup\"], [\"lush\", \"gust\"], [\"friz\", \"brap\"], [\"oboe\", \"obol\"], [\"anew\", \"enew\"], [\"lyra\", \"eyra\"], [\"poon\", \"wast\"], [\"yarn\", \"ease\"], [\"hery\", \"redd\"], [\"elks\", \"nams\"], [\"boep\", \"shop\"], [\"deaw\", \"deer\"], [\"goon\", \"murk\"], [\"lead\", \"rean\"], [\"oink\", \"wons\"], [\"rait\", \"bait\"], [\"swan\", \"swim\"], [\"rahs\", \"hahs\"], [\"life\", \"laze\"], [\"waxy\", \"vale\"], [\"gien\", \"pips\"], [\"umpy\", \"umph\"], [\"coos\", \"coos\"], [\"meal\", \"meal\"], [\"ests\", \"kens\"], [\"lept\", \"sext\"], [\"fags\", \"nigh\"], [\"exes\", \"emes\"], [\"yaar\", \"mats\"], [\"buss\", \"fums\"], [\"shin\", \"thin\"], [\"peck\", \"yock\"], [\"high\", \"diva\"], [\"spec\", \"exit\"], [\"hons\", \"tops\"], [\"meck\", \"mick\"], [\"salt\", \"tala\"], [\"tene\", \"bare\"], [\"rifs\", \"toff\"], [\"ywis\", \"bois\"], [\"oups\", \"hubs\"], [\"rare\", \"rase\"], [\"hent\", \"deaf\"], [\"alow\", \"arbs\"], [\"hear\", \"keas\"], [\"skeg\", \"sten\"], [\"waly\", \"cavy\"], [\"bobs\", \"sogs\"], [\"diol\", \"vire\"], [\"boss\", \"kobs\"], [\"naze\", \"hork\"], [\"gymp\", \"sall\"], [\"crag\", \"crab\"], [\"spry\", \"scry\"], [\"reny\", \"reno\"], [\"bazz\", \"raze\"], [\"gaus\", \"bays\"], [\"ordo\", \"ords\"], [\"glow\", \"plot\"], [\"duck\", \"fuck\"], [\"muni\", \"muti\"], [\"mere\", \"mosh\"], [\"asar\", \"ksar\"], [\"bank\", \"sile\"], [\"houf\", \"kais\"], [\"ails\", \"lins\"], [\"axil\", \"aked\"], [\"hell\", \"farl\"], [\"slit\", \"ship\"], [\"frow\", \"gris\"], [\"rurp\", \"kuru\"], [\"buik\", \"rusk\"], [\"tehr\", \"lear\"], [\"doby\", \"doby\"], [\"lynx\", \"coms\"], [\"soda\", \"caca\"], [\"yest\", \"aunt\"], [\"limy\", \"muni\"], [\"bima\", \"rimu\"], [\"sinh\", \"sink\"], [\"erns\", \"eres\"], [\"shen\", \"shew\"], [\"fibs\", \"silo\"], [\"push\", \"mush\"], [\"fibs\", \"call\"]].forEach(([a,b]) => {\n                        assertPath(a, b)\n                        assertPath(b, a)\n                    });\n\n            });\n        }\n\n\n\n    },\n    'numberWords': {\n        task: () => print('{bo}Write a function that takes a number, and returns a space-delimited word representation of that number. \\nFor example, given 120 as input you would return \\'one two zero\\'  {/}'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                if (\n                    result(123) !== 'one two three' ||\n                    result(90807) !== 'nine zero eight zero seven' ||\n                    result(564) !== 'five six four' ||\n                    result(120349) !== 'one two zero three four nine'\n                ) throw new Error('received invalid result');\n            });\n        }\n    },\n    pyramid: {\n          task: () => print('{bo}Given a positive integer, draw an ASCII pyramid with as many rows. For example, given a 2: \\n /\\\\\\n/__\\\\\\n'),\n          test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                [\n                    [ 1, '/\\\\\\n' ],\n                    [3, '  /\\\\\\n /  \\\\\\n/____\\\\\\n'],\n                    [8, '       /\\\\\\n      /  \\\\\\n     /    \\\\\\n    /      \\\\\\n   /        \\\\\\n  /          \\\\\\n /            \\\\\\n/______________\\\\\\n'],\n                    [32, '                               /\\\\\\n                              /  \\\\\\n                             /    \\\\\\n                            /      \\\\\\n                           /        \\\\\\n                          /          \\\\\\n                         /            \\\\\\n                        /              \\\\\\n                       /                \\\\\\n                      /                  \\\\\\n                     /                    \\\\\\n                    /                      \\\\\\n                   /                        \\\\\\n                  /                          \\\\\\n                 /                            \\\\\\n                /                              \\\\\\n               /                                \\\\\\n              /                                  \\\\\\n             /                                    \\\\\\n            /                                      \\\\\\n           /                                        \\\\\\n          /                                          \\\\\\n         /                                            \\\\\\n        /                                              \\\\\\n       /                                                \\\\\\n      /                                                  \\\\\\n     /                                                    \\\\\\n    /                                                      \\\\\\n   /                                                        \\\\\\n  /                                                          \\\\\\n /                                                            \\\\\\n/______________________________________________________________\\\\\\n'],\n                ].forEach(([input, output]) => {\n                    assertEq(result(input), output);\n                });\n            });\n          }\n    },\n    triangle: {\n        task: () => print('{bo}Provide a function that returns the nth row of pascal\\'s triangle as an array of numbers'),\n        test: (solution) => {\n            const { pascal } = require('pascal-triangle');\n            const triangle = pascal(30);\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                for(let i = 1; i < 30; i++) {\n                    assertCall(result, triangle[i-1], i);\n                }\n            });\n        },\n    },\n    'miniJSON': {\n        task: () => print('{bo}Create a JSON parser that handles {y}strings{/}{bo}, {y}numbers{/}{bo}, and {y}arrays{/}{bo}. (You cannot use {dc}eval{/}{bo} or the {dc}JSON{/}{bo} object)'),\n        test: (solution) => {\n            const cases = [` 123 `,` [1, 2, 3] `,` [[12, 2, [3]], []] `,` \"hello world\" `,` \"hello \\\\\" world\" `,` 123e5 `,` [\"bork\", 123] `,` \"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"''''\" `,` [123, \"[123, \", 123] `,` [123, [], [], [], [123],[]   ,   []] `,` [1e2,3e4,     999] `,` [1,2,3, [\"extra stuff\"]] `,` [\"these\", [\"are\", [\"strings\", [\"inside\", [\"arrays\"]]]]] `,` [[[[],[[[31337]]]]],[]] `].map(test => [test, JSON.parse(test)]);\n            delete global.JSON;\n            const golfEval = IRC.require('golf.eval');\n            removeEval();\n            golfEval(solution, result => {\n                assertType(result, 'function');\n                cases.forEach(([input, expected]) => {\n                    assertCall(result, expected, input);\n                });\n            });\n        },\n    },\n    blockmatrix: {\n        task: () => print('{bo}Given a binary matrix, construct a string using block characters (▖ ▗ ▘ ▙ ▚ ▛ ▜ ▝ ▞ ▟ ▀ ▄ █ ▌ ▐). 1char = 4 pixels'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertType(result([[0,0], [0,0]]), 'string');\n                [\n                    [[[0,1], [1,0]], \"▞\"],\n                    [[[1,1,1,0],[0,0,1,1]], \"▀▙\"],\n                    [[[1,1],[1,1]], \"█\"],\n                    [[[1,1],[0,1]], \"▜\"],\n                    [[[1,1,0,1],[1,1,1,1]], \"█▟\"],\n                    [[[0,1,0,1],[0,1,0,1]], \"▐▐\"],\n                    [[[1,0],[1,0]], \"▌\"],\n                    [[[1,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],[1,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0],[1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0]], \"▛▖▞▖▞▖▛▖\\n▛ ▚▘▚▘▛ \"],\n                    [[[0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,0,0,0,1,1,0,0,0,0,0]], \" ▄▖▗▄ \\n▐████▌\\n ▜██▛ \\n  ▜▛  \"],\n                    [[[1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,0],[0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,0,0,0,1],[0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,1,0,1],[1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1],[0,1,0,1,0,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0],[0,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,1,1,1,0,1,0,1,0,0],[0,1,0,1,0,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1]], \"▀▘▘▘▀▝▞▖▗▚▝ ▐ ▞ \\n▗▘▖▚  ▚▝▝ ▚▘▌▞▗▐\\n▜▚▝▞▛██▛▀▖▝▖▝▐ ▞\\n▐▗▚▝▟▟▞▞▐▚▜▜▜▝▞▗\"],\n                ].forEach(([input, output]) => {\n                    assertEq(result(input).replace(/\\n+$/,''), output);\n                })\n            });\n        },\n\n    },\n    prime: {\n        task: () => print(`{bo}Write an script that evaluates to an array containing all prime numbers below 1000 in order`),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'object');\n                assertEq(result, [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]);\n            });\n        },\n    },\n    pi: {\n        task: () => print(`{bo}Write a script that evaluates to a string containing the the first 100 decimal places of pi ({/}{dg}'3.14159 ...'{/}{bo})`),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                assertEq(result, '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679');\n            });\n        },\n    },\n    'vowelratio': {\n        task: () => print('{bo}Calculate the simplified ratio of vowels [aeiou] to consonants in a given string. For example, {/}{dc}cake{/}{bo} would give {/}{dg}\"1:1\"'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                [\n                    [ 'cake', '1:1' ],\n                    [ 'no', '1:1' ],\n                    [ 'x', '0:1' ],\n                    [ 'oaie', '1:0' ],\n                    [ 'xx', '0:1' ],\n                    [ 'golf', '1:3' ],\n                    [ 'figuratively', '5:7' ],\n                    [ '1e5', '1:0'],\n                    [ '0xff', '0:1'],\n                    [ '0xf', '0:1'],\n                    [ '1e9999', '1:0' ],\n                    [ '1.1e0', '1:0' ],\n                    [ 'the quick brown fox jumped over the lazy dog.', '1:2' ],\n                    [ 'lololol', '3:4' ],\n                    [ 'mozilla firefox™', '3:4' ],\n                    [ 'kirjava was here 2019', '3:4' ],\n                    [ 'The C/++ Programming Language', '8:15' ],\n                    [ 'bleh bleh bleh', '1:3' ],\n                    [ 'how are you enjoying the task', '5:7' ],\n                    [ 'adding more test cases', '7:12' ],\n                    [ \"I'm blue da ba dee da ba daa, da ba dee, da be daa\", '19:15' ],\n                    [ 'rustlang', '1:3' ],\n                    [ 'powerwank', '1:2' ],\n                    [ 'sega genesis', '5:6' ],\n                    [ 'chip-8', '1:3' ],\n                    [ 'oh wait these dont actually have to be real words', '2:3' ],\n                    [ 'saduhfgaiulewdfahlusdfghuasdgfa', '11:20' ],\n                    [ 'asdajasdjflkas jasldalkhjwjw', '2:7' ],\n                    [ 'as dkhnasbd anl dwk alknbwd aw', '1:4' ],\n                    [ 'aksdjalksjdaklsasdca gjokdfiogboi', '5:11' ],\n                    [ 'isdfvosoiu hg sdknlfsnkjflknsd nk', '1:5' ],\n                ].forEach(([input, expected]) => {\n                    assertCall(result, expected, input);\n                });\n            });\n        },\n    },\n    'helloworld': {\n        task: () => print('{bo}Write a script that evaluates to the string {dg}\"Hello World\"{/}{bo}. You cannot use {y}quotes{/}{bo}, {y}slashes{/}{bo} or {y}round brackets{/}{bo}'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                const highlighted = solution.replace(/[\"'`\\/\\\\\\(\\)]/g, d => `{r}${d}{/}`);\n                if (/[\"'`\\/\\\\\\(\\)]/.test(solution)) {\n                    throw new Error(`your solution contains disallowed characters: ${highlighted}`);\n                }\n                assertEq(result, 'Hello World');\n            });\n        },\n    },\n    'longstring': {\n        task: () => print('{bo}Write a script that evaluates to a string of length 17707. You cannot use {y}quote{/}{bo} or {y}number{/}{bo} characters'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                const highlighted = solution.replace(/[\"'`]/g, d => `{r}${d}{/}`).replace(/\\d+/g, d => `{r}${d}{/}`);\n                if (/[\"'`]/.test(solution) && /\\d/.test(solution)) {\n                    throw new Error(`your solution contains quote and number characters: ${highlighted}`);\n                }\n                if (/[\"'`]/.test(solution)) {\n                    throw new Error(`your solution contains quote characters: ${highlighted}`);\n                }\n                if (/\\d/.test(solution)) {\n                    throw new Error(`your solution contains number characters: ${highlighted}`);\n                }\n\n                if (result.length !== 17707) {\n                    throw new Error(`expected length {dc}17707{/} got {o}${result.length}{/}`);\n                }\n            });\n        },\n    },\n    'RPN': {\n        task: () => print('{bo}Write a function that evaluates reverse polish notation'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                // https://www.mathblog.dk/tools/infix-postfix-converter/\n                // https://lab.miguelmota.com/postfix-calculator/demo/\n                assertEq(result('15 7 1 1 + - / 3 * 2 1 1 + + -'), 5);\n                assertEq(result('3 3 5 3 * / + 10 +'), 13.2);\n                assertEq(result('3 3 3 / * 1239 +'), 1242);\n                assertEq(result('3 3 / 3 3 / * 1239 +'), 1240);\n                assertEq(result('31337 187123 * 99 -234875 4 / + +'), 5863814831.25);\n                assertEq(result('123 3443 2 / 1234 * 1234 * 1234 * +'), 3234837776359);\n                assertEq(result('123 3443 2 / 1234 * 1234 * 123 * +'), 322435207965);\n                assertEq(result('3 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 +'), 57);\n                assertEq(result('3 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 4 + 3 + 3 + 3 + 3 + 3 + 3 + 3 +'), 58);\n                assertEq(result('1 3 * 10 + 0 +'), 13);\n                assertEq(result('-1 -1 -'), 0);\n                assertEq(result('-1 -10 -'), 9);\n                assertEq(result('1'), 1);\n            });\n        },\n    },\n    boggle: {\n        task: () => print('{bo}Given a string of 16 characters and a word, return true if that word can be made using a 4x4 Boggle grid made from the 16 characters (4 x 4 rows).'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n\n                const assert = (grid, word, res) => { \n                    assertEq(result(grid, word), res);\n                };\n\n                assert( 'bsoitlshnreolfis', 'shoes', true);\n                assert( 'bsoitlshnreolfis', 'heirs', true);\n                assert( 'bsoitlshnreolfis', 'flesh', false);\n\n                assert( 'piohdmleosxesent', 'sextet', false);\n                assert( 'piohdmleosxesent', 'doses', true);\n                assert( 'piohdmleosxesent', 'dome', false);\n\n                assert( 'iosietpregiediah', 'poster', false);\n                assert( 'iosietpregiediah', 'baboon', false);\n                assert( 'iosietpregiediah', 'spirited', true);\n\n                assert( 'enesddssnbmeaint', 'absentmindedness', true);\n                assert( 'gbaiessxtsseazsl', 'assesses', true);\n                assert( 'ioioiooioioioioi', 'ioioioioioioioio', true);\n                assert( 'saibissaesseasaa', 'assasssassa', false);\n                assert( \"hasezxclrtolpoit\", \"hello\", false);\n                assert('..WORD..........', 'WORD', false);\n                assert('zxcvasdfqwerasdf', 'dewax', true);\n            });\n        }\n    },\n    'romanNumerals': {\n        task: () => print(`{bo}Write a function that converts a positive integer to roman numerals`),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const tests = [\n                    [1, 'I'],\n                    [3, 'III'],\n                    [4, 'IV'],\n                    [500, 'D'],\n                    [40, 'XL'],\n                    [123, 'CXXIII'],\n                    [546, 'DXLVI'],\n                    [3456, 'MMMCDLVI'],\n                    [1337, 'MCCCXXXVII'],\n                    [3999, 'MMMCMXCIX'],\n                    [1024, 'MXXIV'],\n                    [2925, 'MMCMXXV'],\n                    [1111, 'MCXI'],\n                    [67, 'LXVII'],\n                    [49, 'XLIX'],\n                    [32, 'XXXII'],\n                    [1001, 'MI'],\n                ];\n                assertType(result, 'function');\n                tests.forEach(([num, str]) => {\n                    assertEq(result(num), str);\n                });\n            });\n        },\n    },\n    'romanNumerals2': {\n        task: () => print(`{bo}Write a function that converts a roman numeral into an integer`),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const tests = [\n                    [1, 'I'],\n                    [3, 'III'],\n                    [4, 'IV'],\n                    [500, 'D'],\n                    [40, 'XL'],\n                    [123, 'CXXIII'],\n                    [546, 'DXLVI'],\n                    [3456, 'MMMCDLVI'],\n                    [1337, 'MCCCXXXVII'],\n                    [3999, 'MMMCMXCIX'],\n                    [1024, 'MXXIV'],\n                    [2925, 'MMCMXXV'],\n                    [1111, 'MCXI'],\n                    [67, 'LXVII'],\n                    [49, 'XLIX'],\n                    [32, 'XXXII'],\n                    [1001, 'MI'],\n                ];\n                assertType(result, 'function');\n                tests.forEach(([num, str]) => {\n                    assertEq(result(str), num);\n                });\n            });\n        },\n    },\n};\n\nif (IRC.command.path == 'golf.tasks') {\n    print('{bo}available tasks:{/} ' + Object.keys(module.exports).map(key => `${IRC.colors.nick(key, false)}`).join`, `)\n}\n",
    "locked": false,
    "starred": false
}