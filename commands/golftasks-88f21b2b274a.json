{
    "name": "golf.tasks",
    "command": "function assertType(a, type) {\n    if (typeof a !== type) {\n        throw new Error(`expected {dc}${type}{/} got {o}${typeof a}{/}`);\n    }\n}\n\nconst stringify = (obj) => {\n    const output = JSON.stringify(obj);\n    return output.length > 100\n        ? output.slice(0, 100) + ' ...'\n        : output;\n};\n\nfunction assertEq(a, b) {\n    //assertType(a, typeof b);\n    if ((typeof b !== 'object' && a !== b) || JSON.stringify(a) !== JSON.stringify(b)) {\n        throw new Error(`expected {dc}${stringify(b)}{/} got {o}${stringify(a)}{/}`);\n    }\n}\n\nmodule.exports = {\n    'logo': {\n        task: () => print('{bo}Write an expression that evaluates to the string:{/} ' + IRC.colors.link('http://ix.io/1JLF') + ' (the string is trimmed before comparison)'),\n        test: (solution) => {\n            const jsgolf = `#############################################\n#                                           #\n#      #  ####   ####   ####  #      ###### #\n#      # #      #    # #    # #      #      #\n#      #  ####  #      #    # #      #####  #\n#      #      # #  ### #    # #      #      #\n# #    # #    # #    # #    # #      #      #\n#  ####   ####   ####   ####  ###### #      #\n#                                           #\n#############################################`;\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                assertEq(result.trim(), jsgolf);\n            });\n        },\n    },\n    'ROT13': {\n        task: () => print('{bo}Write a function that returns a ROT13 ciphered version of its input string.\\nYour solution needs to cover the characters; abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertEq(result('NOPQWXYZabcdefghijklmABCGHIJKLMnopqrstuvwRSTUVDEFxyz'), 'ABCDJKLMnopqrstuvwxyzNOPTUVWXYZabcdefghijEFGHIQRSklm');\n                assertEq(result('HKLMUVDEefgpyzbcdTtuvnoXYNOPQWhijklmqrsZaxABCGwRSIJF'), 'UXYZHIQRrstclmopqGghiabKLABCDJuvwxyzdefMnkNOPTjEFVWS');\n            });\n        },\n    },\n    'hex2rgb': {\n        task: () => print('{bo}Write a function to convert a hex color ({o}#FFFFFF{/}{bo}) or ({o}#FFF{/}{bo}) to rgb ({dc}rgb(255,255,255){/}{bo})'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertEq(result('#B04B4B'), 'rgb(176,75,75)'); \n                assertEq(result('#7E88E6'), 'rgb(126,136,230)'); \n                assertEq(result('#1FA11F'), 'rgb(31,161,31)'); \n                assertEq(result('#123'), 'rgb(17,34,51)'); \n                assertEq(result('#7FFFD4'), 'rgb(127,255,212)');\n                assertEq(result('#B0E0E6'), 'rgb(176,224,230)');\n                assertEq(result('#5F9EA0'), 'rgb(95,158,160)');\n                assertEq(result('#4682B4'), 'rgb(70,130,180)');\n                assertEq(result('#6495ED'), 'rgb(100,149,237)');\n                assertEq(result('#00BFFF'), 'rgb(0,191,255)');\n                assertEq(result('#1E90FF'), 'rgb(30,144,255)');\n                assertEq(result('#ADD8E6'), 'rgb(173,216,230)');\n                assertEq(result('#87CEEB'), 'rgb(135,206,235)');\n                assertEq(result('#87CEFA'), 'rgb(135,206,250)');\n                assertEq(result('#666'), 'rgb(102,102,102)');\n                assertEq(result('#F00'), 'rgb(255,0,0)');\n            });\n        },\n    },\n    'quine': {\n        task: () => print('{bo}Write a quine'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                if (result.length < 1) throw new Error('program length must be non-zero');\n                if (result != solution) throw new Error('output doesn\\'t match source');\n            });\n        },\n    }, \n    'cross': {\n        task: () => print('{bo}Write an expression that evaluates to the string:{/} ' + IRC.colors.link('http://ix.io/1FZt') + ' (the string is trimmed before comparison)'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const art = `#......#\\n.#....#.\\n..#..#..\\n...##...\\n...##...\\n..#..#..\\n.#....#.\\n#......#`;\n                assertType(result, 'string');\n                assertEq(result.trim(), art);\n            });\n        },\n    }, \n    'numberWords': {\n        task: () => print('{bo}Write a function that takes a number, and returns a space-delimited word representation of that number. \\nFor example, given 120 as input you would return \\'one two zero\\'  {/}'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                if (typeof result !== 'function') throw new Error('result is not a function');\n                if (\n                    result(123) !== 'one two three' ||\n                    result(90807) !== 'nine zero eight zero seven' ||\n                    result(564) !== 'five six four' ||\n                    result(120349) !== 'one two zero three four nine'\n                ) throw new Error('received invalid result');\n            });\n        }\n    },\n    pyramid: {\n          task: () => print('{bo}Given a positive integer, draw an ASCII pyramid with as many rows. For example, given a 2: \\n /\\\\\\n/__\\\\\\n'),\n          test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                [\n                    [ 1, '/\\\\\\n' ],\n                    [3, '  /\\\\\\n /  \\\\\\n/____\\\\\\n'],\n                    [8, '       /\\\\\\n      /  \\\\\\n     /    \\\\\\n    /      \\\\\\n   /        \\\\\\n  /          \\\\\\n /            \\\\\\n/______________\\\\\\n'],\n                    [32, '                               /\\\\\\n                              /  \\\\\\n                             /    \\\\\\n                            /      \\\\\\n                           /        \\\\\\n                          /          \\\\\\n                         /            \\\\\\n                        /              \\\\\\n                       /                \\\\\\n                      /                  \\\\\\n                     /                    \\\\\\n                    /                      \\\\\\n                   /                        \\\\\\n                  /                          \\\\\\n                 /                            \\\\\\n                /                              \\\\\\n               /                                \\\\\\n              /                                  \\\\\\n             /                                    \\\\\\n            /                                      \\\\\\n           /                                        \\\\\\n          /                                          \\\\\\n         /                                            \\\\\\n        /                                              \\\\\\n       /                                                \\\\\\n      /                                                  \\\\\\n     /                                                    \\\\\\n    /                                                      \\\\\\n   /                                                        \\\\\\n  /                                                          \\\\\\n /                                                            \\\\\\n/______________________________________________________________\\\\\\n'],\n                ].forEach(([input, output]) => {\n                    assertEq(result(input), output);\n                });\n            });\n          }\n    },\n    blockmatrix: {\n        task: () => print('{bo}Given a binary matrix, construct a string using block characters (▖ ▗ ▘ ▙ ▚ ▛ ▜ ▝ ▞ ▟ ▀ ▄ █ ▌ ▐). 1char = 4 pixels'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertType(result([[0,0], [0,0]]), 'string');\n                [\n                    [[[0,1], [1,0]], \"▞\"],\n                    [[[1,1,1,0],[0,0,1,1]], \"▀▙\"],\n                    [[[1,1],[1,1]], \"█\"],\n                    [[[1,1],[0,1]], \"▜\"],\n                    [[[1,1,0,1],[1,1,1,1]], \"█▟\"],\n                    [[[0,1,0,1],[0,1,0,1]], \"▐▐\"],\n                    [[[1,0],[1,0]], \"▌\"],\n                    [[[1,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],[1,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0],[1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0]], \"▛▖▞▖▞▖▛▖\\n▛ ▚▘▚▘▛ \"],\n                    [[[0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,0,0,0,1,1,0,0,0,0,0]], \" ▄▖▗▄ \\n▐████▌\\n ▜██▛ \\n  ▜▛  \"],\n                    [[[1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,0],[0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,0,0,0,1],[0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,1,0,1],[1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1],[0,1,0,1,0,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0],[0,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,1,1,1,0,1,0,1,0,0],[0,1,0,1,0,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1]], \"▀▘▘▘▀▝▞▖▗▚▝ ▐ ▞ \\n▗▘▖▚  ▚▝▝ ▚▘▌▞▗▐\\n▜▚▝▞▛██▛▀▖▝▖▝▐ ▞\\n▐▗▚▝▟▟▞▞▐▚▜▜▜▝▞▗\"],\n                ].forEach(([input, output]) => {\n                    assertEq(result(input).replace(/\\n+$/,''), output);\n                })\n            });\n        },\n\n    },\n    prime: {\n        task: () => print(`{bo}Write an expression that evaluates to an array containing all prime numbers below 1000 in order`),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'object');\n                assertEq(result, [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]);\n            });\n        },\n    },\n    'longstring': {\n        task: () => print('{bo}Write a script that evaluates to a string of length 17707. You cannot use {y}quote{/}{bo} or {y}number{/}{bo} characters'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                const highlighted = solution.replace(/[\"'`]/g, d => `{r}${d}{/}`).replace(/\\d+/g, d => `{r}${d}{/}`);\n                if (/[\"'`]/.test(solution) && /\\d/.test(solution)) {\n                    throw new Error(`your solution contains quote and number characters: ${highlighted}`);\n                }\n                if (/[\"'`]/.test(solution)) {\n                    throw new Error(`your solution contains quote characters: ${highlighted}`);\n                }\n                if (/\\d/.test(solution)) {\n                    throw new Error(`your solution contains number characters: ${highlighted}`);\n                }\n\n                if (result.length !== 17707) {\n                    throw new Error(`expected length {dc}17707{/} got {o}${result.length}{/}`);\n                }\n            });\n        },\n    },\n    'RPN': {\n        task: () => print('{bo}Write a function that evaluates reverse polish notation'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                // https://www.mathblog.dk/tools/infix-postfix-converter/\n                // https://lab.miguelmota.com/postfix-calculator/demo/\n                assertEq(result('15 7 1 1 + - / 3 * 2 1 1 + + -'), 5);\n                assertEq(result('3 3 5 3 * / + 10 +'), 13.2);\n                assertEq(result('3 3 3 / * 1239 +'), 1242);\n                assertEq(result('3 3 / 3 3 / * 1239 +'), 1240);\n                assertEq(result('31337 187123 * 99 -234875 4 / + +'), 5863814831.25);\n                assertEq(result('123 3443 2 / 1234 * 1234 * 1234 * +'), 3234837776359);\n                assertEq(result('123 3443 2 / 1234 * 1234 * 123 * +'), 322435207965);\n                assertEq(result('3 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 +'), 57);\n                assertEq(result('3 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 4 + 3 + 3 + 3 + 3 + 3 + 3 + 3 +'), 58);\n                assertEq(result('1 3 * 10 + 0 +'), 13);\n                assertEq(result('-1 -1 -'), 0);\n                assertEq(result('-1 -10 -'), 9);\n                assertEq(result('1'), 1);\n            });\n        },\n    },\n    boggle: {\n        task: () => print('{bo}Given a string of 16 characters and a word, return true if that word can be made using a 4x4 Boggle grid made from the 16 characters (4 x 4 rows).'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n\n                const assert = (grid, word, res) => { \n                    assertEq(result(grid, word), res);\n                };\n\n                assert( 'bsoitlshnreolfis', 'shoes', true);\n                assert( 'bsoitlshnreolfis', 'heirs', true);\n                assert( 'bsoitlshnreolfis', 'flesh', false);\n\n                assert( 'piohdmleosxesent', 'sextet', false);\n                assert( 'piohdmleosxesent', 'doses', true);\n                assert( 'piohdmleosxesent', 'dome', false);\n\n                assert( 'iosietpregiediah', 'poster', false);\n                assert( 'iosietpregiediah', 'baboon', false);\n                assert( 'iosietpregiediah', 'spirited', true);\n\n                assert( 'enesddssnbmeaint', 'absentmindedness', true);\n                assert( 'gbaiessxtsseazsl', 'assesses', true);\n                assert( 'ioioiooioioioioi', 'ioioioioioioioio', true);\n                assert( 'saibissaesseasaa', 'assasssassa', false);\n                assert('..WORD..........', 'WORD', false);\n                assert('zxcvasdfqwerasdf', 'dewax', true);\n            });\n        }\n    },\n    'romanNumerals': {\n        task: () => print(`{bo}Write a function that converts a positive integer to roman numerals`),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const tests = [\n                    [1, 'I'],\n                    [3, 'III'],\n                    [4, 'IV'],\n                    [500, 'D'],\n                    [40, 'XL'],\n                    [123, 'CXXIII'],\n                    [546, 'DXLVI'],\n                    [3456, 'MMMCDLVI'],\n                    [1337, 'MCCCXXXVII'],\n                    [3999, 'MMMCMXCIX'],\n                    [1024, 'MXXIV'],\n                    [2925, 'MMCMXXV'],\n                    [1111, 'MCXI'],\n                    [67, 'LXVII'],\n                    [49, 'XLIX'],\n                    [32, 'XXXII'],\n                    [1001, 'MI'],\n                ];\n                assertType(result, 'function');\n                tests.forEach(([num, str]) => {\n                    assertEq(result(num), str);\n                });\n            });\n        },\n    },\n    'romanNumerals2': {\n        task: () => print(`{bo}Write a function that converts a roman numeral into an integer`),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const tests = [\n                    [1, 'I'],\n                    [3, 'III'],\n                    [4, 'IV'],\n                    [500, 'D'],\n                    [40, 'XL'],\n                    [123, 'CXXIII'],\n                    [546, 'DXLVI'],\n                    [3456, 'MMMCDLVI'],\n                    [1337, 'MCCCXXXVII'],\n                    [3999, 'MMMCMXCIX'],\n                    [1024, 'MXXIV'],\n                    [2925, 'MMCMXXV'],\n                    [1111, 'MCXI'],\n                    [67, 'LXVII'],\n                    [49, 'XLIX'],\n                    [32, 'XXXII'],\n                    [1001, 'MI'],\n                ];\n                assertType(result, 'function');\n                tests.forEach(([num, str]) => {\n                    assertEq(result(str), num);\n                });\n            });\n        },\n    },\n};\n\nif (IRC.command.path == 'golf.tasks') {\n    print('{bo}available tasks:{/} ' + Object.keys(module.exports).map(key => `${IRC.colors.nick(key)}`).join`, `)\n}\n",
    "locked": false,
    "starred": false
}