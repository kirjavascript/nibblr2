{
    "name": "roulette",
    "command": "IRC.colors.leaderboard = () => {};\n\nconst useGame = () => IRC.require('module.loadObject')('game', {\n    isRunning: false,\n    scores: {},\n    bets: {},\n    history: [],\n    house: 0,\n});\n\nconst [game, setGame] = useGame();\n\nconst numbers = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];\n\nconst isRed = (num) => (\n    ((num >= 1 && num <= 10 || num >= 19 && num <= 28) && num & 1)\n    || (num >= 11 && num <= 18 || num >= 29 && num <= 36) && !(num & 1)\n);\n\nconst isValidLocation = (str) => /even|odd|\\d+|red|black|low|high/.test(str);\n\nconst spin = () => 0|Math.random()*37;\n\nconst renderNumber = (num, withBall = false) => {\n    const ball = withBall ? '● ' : ''; // ⬤\n    if (!num) return `{w,dg} ${num} ${ball}{/}`;\n    if (isRed(num)) return `{w,r} ${num} ${ball}{/}`;\n    else return `{w,bl} ${num} ${ball}{/}`;\n};\n\nconst renderLocation = (location) => {\n    if (!Number.isNaN(parseInt(location, 10))) {\n        return renderNumber(location);\n    } else if (location == 'red') {\n        return '{w,r} red {/}';\n    } else if (location == 'black') {\n        return '{w,bl} black {/}';\n    } else {\n        return `{w,g} ${location} {/}`;\n    }\n};\n\nconst payout = (amount, type) => {\n    if (type == 'number') {\n        return amount * 35;\n    } else {\n        return amount * 2;\n    }\n};\n\n// ---\n\nconst { from: user } = IRC.message;\nif (typeof game.scores[user] == 'undefined') game.scores[user] = 1000;\n\nconst [amountRaw, ...locList] = input.trim().split(/\\s+/);\nconst locations = locList.filter(isValidLocation);\nconst amount = parseInt(amountRaw, 10);\nconst totalAmount = amount * locations.length;\n\n// assertions\n\nif (!locations.length) {\n    throw 'board locations are: 0-36, red, black, even, odd, low, high - place bets with ' + IRC.colors.cmd('roulette', ['amount', 'location(s)'])\n}\nif (amount < 1) {\n    throw 'bet at least 1';\n}\nif (game.scores[user] < totalAmount) {\n    throw 'you can\\'t afford to bet that much';\n}\nif (locations.some(d => Number.isNaN(parseInt(d, 10))) && amount < 10) {\n    throw 'minimum amount for non-numbers is {y}$10{/}';\n}\n\n// assign bets\n\nif (!game.bets[user]) game.bets[user] = {};\ngame.house += totalAmount;\ngame.scores[user] -= totalAmount;\nlocations.forEach(loc => {\n    if (!game.bets[user][loc]) {\n        game.bets[user][loc] = amount;\n    } else {\n        game.bets[user][loc] += amount;\n    }\n});\n\n\nconst betsMade = Object\n    .entries(game.bets[user])\n    .map(([key, value]) => `{y}$${value}{/} ${renderLocation(key)}`)\n    .join` `;\n\nprint('{g}Bets by ' + IRC.colors.nick(user, false) + ' - ' + betsMade + ' ' + (!game.isRunning ? ' - {g}Place your bets!' : ''));\n\nsetGame(game);\n\nif (!game.isRunning) {\n    game.isRunning = true;\n    setGame(game);\n    {\n        sleep(10000);\n        const [game, setGame] = useGame();\n        const num = spin();\n        // show board\n        print(numbers.map(d => renderNumber(d, d == num)).join``);\n        // show number, then zero or black/red even/odd low/high\n\n        // calculate scores...\n        game.bets = {};\n        game.isRunning = false;\n        // track the last 100 games\n        game.history.push(num);\n        if (game.history.length > 100) {\n            game.history.shift();\n        }\n        setGame(game);\n    }\n}\n",
    "locked": true,
    "starred": false
}