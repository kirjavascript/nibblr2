{
    "locked": true,
    "starred": false,
    "name": "scheme",
    "command": "/*\n * BiwaScheme 0.6.9 - R6RS Scheme in JavaScript\n *\n * Copyright (c) 2007-2014 Yutaka HARA (http://www.biwascheme.org/)\n * @license Licensed under the MIT license.\n */\n\nvar BiwaScheme = BiwaScheme || {};\n\nBiwaScheme.Version = \"0.6.9\";  // TODO: deprecate this\nBiwaScheme.VERSION = \"0.6.9\";\nBiwaScheme.GitCommit = \"7bc957d39298e7a83ea9eed8ce7935d29df4ebe2\";\n// Heap based scheme from 3imp.pdf\n//\n\n//\n// variables\n//\nBiwaScheme.TopEnv = {};\nBiwaScheme.CoreEnv = {};\n\n//\n// Nil\n// javascript representation of empty list( '() )\n//\nBiwaScheme.nil = {\n  toString: function() { return \"nil\"; },\n  to_write: function() { return \"()\"; },\n  to_array: function() { return []; },\n  length: function() { return 0; }\n};\n\n//\n// #<undef> (The undefined value)\n// also used as #<unspecified> values\n//\nBiwaScheme.undef = new Object();\nBiwaScheme.undef.toString = function(){ return \"#<undef>\"; }\n\n// Prints the arguments to console.debug.\nBiwaScheme.debug = function(/*arguments*/){\n  var args = _.toArray(arguments);\n  console.debug.apply(console, _.map(args, BiwaScheme.inspect));\n}\n\n//\n// Assertion\n//\nBiwaScheme.assert = function(cond, desc) {\n  if (!cond) {\n    throw new BiwaScheme.Bug(\"[BUG] Assertion failed: \"+desc);\n  }\n}\n\n//\n// Configurations\n//\n\n// Maximum depth of stack trace\n// (You can also set Interpreter#max_trace_size for each Interpreter)\nBiwaScheme.max_trace_size = 40;\n\n// Stop showing deprecation warning\nBiwaScheme.suppress_deprecation_warning = false;\n//\n// Super-simple class implementation\n//\n// Example usage:\n//\n// BiwaScheme.Foo = BiwaScheme.Class.create({\n//   initialize: function(a){\n//     this.a = a;\n//   },\n//\n//   toString: function(){\n//     return \"foo[\" + this.a + \"]\";\n//   }\n// });\n//\n// BiwaScheme.Bar = BiwaScheme.Class.extend(new BiwaScheme.Foo(\"hello1\"), {\n//   initialize: function(b){\n//     this.b = b;\n//   },\n//\n//   printEverything: function(){\n//     console.log(\"a = \", this.a, \"b = \", this.b);\n//   },\n//\n//   toString: function(){\n//     return \"bar[\" + this.b + \"]\";\n//   }\n// });\n\nBiwaScheme.Class = {\n  create: function(methods) {\n    var klass = function(){ this.initialize.apply(this, arguments); };\n    _.extend(klass.prototype, methods);\n    return klass;\n  },\n\n  extend: function(parent, methods) {\n    var klass = function(){ this.initialize.apply(this, arguments); };\n    klass.prototype = parent;\n    _.extend(klass.prototype, methods);\n    return klass;\n  }\n};\n\n// Update the given method to memoized version.\n//\n// - klass : a class defined by BiwaScheme.Class.create\n// - name_or_names : method name (a string or an array of strings)\n//\n// Example\n//\n//   // Given this method\n//   BiwaScheme.Enumeration.EnumType = ...\n//     universe: function(){\n//       return ...\n//     }\n//   ...\n//   // Memoize\n//   BiwaScheme.Class.memoize(BiwaScheme.Enumeration.EnumType,\n//                            \"_universe\"); \n//\n//   // Equal to:\n//   BiwaScheme.Enumeration.EnumType = ...\n//     universe: function(){\n//       if(!this.hasOwnProperty(\"cached_universe\")){\n//         this.cached_universe = this.compute_universe();\n//       }\n//       return this.cached_universe;\n//     },\n//     compute_universe: function(){ \n//       // Original function, renamed to compute_*\n//       return ...\n//     }\n//   ...\nBiwaScheme.Class.memoize = function(klass, name_or_names){\n  var proto = klass.prototype;\n  var names = _.isArray(name_or_names) ? name_or_names : [name_or_names];\n\n  _.each(names, function(name){\n    // Copy original function foo as 'compute_foo'\n    proto[\"compute_\"+name] = proto[name];\n\n    // Define memoizing version\n    proto[name] = function(/*arguments*/){\n      if(!this.hasOwnProperty(\"cached_\"+name)){\n        this[\"cached_\"+name] = this[\"compute_\"+name].apply(this, _.toArray(arguments));\n      }\n      return this[\"cached_\"+name];\n    }\n  });\n}\n//\n// write.js: Functions to convert objects to strings\n//\n\n//\n// write\n//\n\nBiwaScheme.to_write = function(obj){\n  if(obj === undefined)\n    return \"undefined\";\n  else if(obj === null)\n    return \"null\";\n  else if(_.isFunction(obj))\n    return \"#<Function \"+(obj.fname ? obj.fname :\n                          obj.toSource ? _.str.truncate(obj.toSource(), 40) :\n                          \"\")+\">\";\n  else if(_.isString(obj))\n    return '\"' +\n           obj.replace(/\\\\|\\\"/g,function($0){return'\\\\'+$0;})\n              .replace(/\\x07/g, \"\\\\a\")\n              .replace(/\\x08/g, \"\\\\b\")\n              .replace(/\\t/g, \"\\\\t\")\n              .replace(/\\n/g, \"\\\\n\")\n              .replace(/\\v/g, \"\\\\v\")\n              .replace(/\\f/g, \"\\\\f\")\n              .replace(/\\r/g, \"\\\\r\") +\n           '\"';\n  else if(_.isArray(obj) && obj.closure_p)\n    return \"#<Closure>\";\n  else if(_.isArray(obj))\n    return \"#(\" + _.map(obj, function(e) { return BiwaScheme.to_write(e); }).join(\" \") + \")\";\n  else if(typeof(obj.to_write) == 'function')\n    return obj.to_write();\n  else if(isNaN(obj) && typeof(obj) == 'number')\n    return \"+nan.0\";\n  else{\n    switch(obj){\n      case true: return \"#t\";\n      case false: return \"#f\";\n      case Infinity: return \"+inf.0\";\n      case -Infinity: return \"-inf.0\";\n    }\n  }\n  return BiwaScheme.inspect(obj);\n}\n\n//\n// display\n//\n\nBiwaScheme.to_display = function(obj){\n  if(_.isUndefined(obj))\n    return 'undefined';\n  else if(_.isNull(obj))\n    return 'null';\n  else if(typeof(obj.valueOf()) == \"string\")\n    return obj;\n  else if(obj instanceof BiwaScheme.Symbol)\n    return obj.name;\n  else if(obj instanceof Array)\n    return '#(' + _.map(obj, BiwaScheme.to_display).join(' ') + ')';\n  else if(obj instanceof BiwaScheme.Pair)\n    return obj.inspect(BiwaScheme.to_display);\n  else if(obj instanceof BiwaScheme.Char)\n    return obj.value;\n  else\n    return BiwaScheme.to_write(obj);\n}\n\n//\n// write/ss (write with substructure)\n//\n\n// example:  > (let ((x (list 'a))) (list x x))                   //           (#0=(a) #0#)\n// 2-pass algorithm.\n// (1) detect all the objects which appears more than once\n//     (find_cyclic, reduce_cyclic_info)\n// (2) write object using this information\n//   * add prefix '#n=' for first appearance\n//   * just write '#n#' for other appearance\n\n//TODO: support Values\nBiwaScheme.write_ss = function(obj, array_mode){\n  var known = [obj], used = [false];\n  BiwaScheme.find_cyclic(obj, known, used);\n  var cyclic   = BiwaScheme.reduce_cyclic_info(known, used);\n  var appeared = new Array(cyclic.length);\n  for(var i=cyclic.length-1; i>=0; i--) appeared[i] = false;\n\n  return BiwaScheme.to_write_ss(obj, cyclic, appeared, array_mode);\n}\nBiwaScheme.to_write_ss = function(obj, cyclic, appeared, array_mode){\n  var ret = \"\";\n  var i = cyclic.indexOf(obj);\n  if(i >= 0){\n    if(appeared[i]){\n      return \"#\"+i+\"#\";\n    }\n    else{\n      appeared[i] = true;\n      ret = \"#\"+i+\"=\";\n    }\n  }\n\n  if(obj instanceof BiwaScheme.Pair){\n    var a = [];\n    a.push(BiwaScheme.to_write_ss(obj.car, cyclic, appeared, array_mode));\n    for(var o=obj.cdr; o != BiwaScheme.nil; o=o.cdr){\n      if(!(o instanceof BiwaScheme.Pair) || cyclic.indexOf(o) >= 0){\n        a.push(\".\");\n        a.push(BiwaScheme.to_write_ss(o, cyclic, appeared, array_mode));\n        break;\n      }\n      a.push(BiwaScheme.to_write_ss(o.car, cyclic, appeared, array_mode));\n    }\n    ret += \"(\" + a.join(\" \") + \")\";\n  }\n  else if(obj instanceof Array){\n    var a = _.map(obj, function(item){\n      return BiwaScheme.to_write_ss(item, cyclic, appeared, array_mode);\n    })\n    if(array_mode)\n      ret += \"[\" + a.join(\", \") + \"]\";\n    else\n      ret += \"#(\" + a.join(\" \") + \")\";\n  }\n  else{\n    ret += BiwaScheme.to_write(obj);\n  }\n  return ret;\n}\nBiwaScheme.reduce_cyclic_info = function(known, used){\n  var n_used = 0;\n  for(var i=0; i<used.length; i++){\n    if(used[i]){\n      known[n_used] = known[i];\n      n_used++;\n    }\n  }\n  return known.slice(0, n_used);\n}\nBiwaScheme.find_cyclic = function(obj, known, used){\n  var items = (obj instanceof BiwaScheme.Pair)  ? [obj.car, obj.cdr] :\n              (obj instanceof Array) ? obj :\n              null;\n  if(!items) return;\n\n  _.each(items, function(item){\n    if(typeof(item)=='number' || typeof(item)=='string' ||\n      item === BiwaScheme.undef || item === true || item === false ||\n      item === BiwaScheme.nil || item instanceof BiwaScheme.Symbol) return;\n\n    var i = known.indexOf(item);\n    if(i >= 0)\n      used[i] = true;\n    else{\n      known.push(item);\n      used.push(false);\n      BiwaScheme.find_cyclic(item, known, used);\n    }\n  });\n};\n\n//\n// inspect\n//\nBiwaScheme.inspect = function(object, opts) {\n  try {\n    if (_.isUndefined(object)) return 'undefined';\n    if (object === null) return 'null';\n    if (object === true) return '#t';\n    if (object === false) return '#f';\n    if (object.inspect) return object.inspect();\n    if (_.isString(object)) {\n      return '\"' + object.replace(/\"/g, '\\\\\"') + '\"';\n    }\n    if (_.isArray(object)) {\n      return '[' + _.map(object, BiwaScheme.inspect).join(', ') + ']';\n    }\n\n    if (opts && opts[\"fallback\"]){\n      return opts[\"fallback\"];\n    }\n    else {\n      return object.toString();\n    }\n  } catch (e) {\n    if (e instanceof RangeError) return '...';\n    throw e;\n  }\n};\n//\n// types.js - type predicators, equality, compare\n//\n\nBiwaScheme.isNil = function(obj){\n  return (obj === BiwaScheme.nil);\n};\n\nBiwaScheme.isUndef = function(obj){\n  return (obj === BiwaScheme.undef);\n};\n\nBiwaScheme.isBoolean = _.isBoolean; // Return true if arg is either true or false\n\n//BiwaScheme.isNumber is defined in number.js (Return true if arg is scheme number)\n\nBiwaScheme.isString = _.isString;\n\nBiwaScheme.isChar = function(obj){\n  return (obj instanceof BiwaScheme.Char);\n};\n\nBiwaScheme.isSymbol = function(obj){\n  return (obj instanceof BiwaScheme.Symbol);\n};\n\nBiwaScheme.isPort = function(obj){\n  return (obj instanceof BiwaScheme.Port);\n};\n\n// Note: '() is not a pair in scheme\nBiwaScheme.isPair = function(obj){\n  return (obj instanceof BiwaScheme.Pair);\n};\n\n// Returns true if obj is a proper list\n// Note: isList returns true for '()\nBiwaScheme.isList = function(obj){\n  var nil = BiwaScheme.nil, Pair = BiwaScheme.Pair;\n\n  if (obj === nil) { // Empty list\n    return true;\n  }\n  if (!(obj instanceof Pair)) { // Argument isn't even a pair\n    return false;\n  }\n\n  var tortoise = obj;\n  var hare = obj.cdr;\n  while (true) {\n    if (hare === nil) { // End of list\n      return true;\n    }\n    if (hare === tortoise) { // Cycle\n      return false;\n    }\n    if (!(hare instanceof Pair)) { // Improper list\n      return false;\n    }\n\n    if (hare.cdr === nil) { // End of list\n      return true;\n    }\n    if (!(hare.cdr instanceof Pair)) { // Improper list\n      return false;\n    }\n\n    hare = hare.cdr.cdr;\n    tortoise = tortoise.cdr;\n  }\n};\n\nBiwaScheme.isVector = function(obj){\n  return (obj instanceof Array) && (obj.closure_p !== true);\n};\n\nBiwaScheme.isHashtable = function(obj){\n  return (obj instanceof BiwaScheme.Hashtable);\n};\n\nBiwaScheme.isMutableHashtable = function(obj){\n  return (obj instanceof BiwaScheme.Hashtable) && obj.mutable;\n};\n\nBiwaScheme.isClosure = function(obj){\n  return (obj instanceof Array) && (obj.closure_p === true);\n};\n\n// procedure: Scheme closure or JavaScript function\n// valid argument for anywhere function is expected\nBiwaScheme.isProcedure = function(obj){\n  return BiwaScheme.isClosure(obj) || _.isFunction(obj);\n};\n\n// Return true if obj is a scheme value which evaluates to itself\nBiwaScheme.isSelfEvaluating = function(obj) {\n  return BiwaScheme.isBoolean(obj) ||\n         BiwaScheme.isNumber(obj) ||\n         BiwaScheme.isString(obj) ||\n         BiwaScheme.isChar(obj);\n};\n\n//\n// equality\n//\nBiwaScheme.eq = function(a, b){\n  return a === b;\n};\n// TODO: Records (etc.)\nBiwaScheme.eqv = function(a, b){\n  return a == b && (typeof(a) == typeof(b));\n};\nBiwaScheme.equal = function(a, b){\n  //TODO: must terminate for cyclic objects\n  return BiwaScheme.to_write(a) == BiwaScheme.to_write(b);\n};\n\n//\n// comaprator\n//\n// Return true when a < b\nBiwaScheme.lt = function(a, b) {\n  if(typeof a !== typeof b){\n    return compareFn(typeof a, typeof b); \t\n  }\n  return a < b;\n};\n//\n// Errors\n//\n\nBiwaScheme.Error = BiwaScheme.Class.create({\n  initialize: function(msg){\n    this.message = \"Error: \"+msg;\n  },\n  toString: function(){\n    return this.message;\n  }\n});\n\nBiwaScheme.Bug = BiwaScheme.Class.extend(new BiwaScheme.Error(), {\n  initialize: function(msg){\n    this.message = \"[BUG] \"+msg;\n  }\n});\n\n// currently used by \"raise\"\nBiwaScheme.UserError = BiwaScheme.Class.extend(new BiwaScheme.Error(), {\n  initialize: function(msg){\n    this.message = msg;\n  }\n});\n\n//\n// Set - set of string\n// contents must be string (or at least sortable)\n//\nBiwaScheme.Set = BiwaScheme.Class.create({\n  initialize : function(/*args*/){\n    this.arr = [];\n    var i;\n    for(i=0; i<arguments.length; i++)\n      this.arr[i] = arguments[i];\n  },\n\n  equals : function(other){\n    if(this.arr.length != other.arr.length)\n      return false;\n\n    var a1 = _.clone(this.arr);\n    var a2 = _.clone(other.arr);\n    a1.sort();\n    a2.sort();\n    for(var i=0; i<this.arr.length; i++){\n      if(a1[i] != a2[i]) return false;\n    }\n    return true;\n  },\n  set_cons : function(item){\n    var o = new BiwaScheme.Set(item);\n    o.arr = _.clone(this.arr);\n    o.arr.push(item);\n    return o;\n  },\n  set_union : function(/*args*/){\n    var o = new BiwaScheme.Set();\n    o.arr = _.clone(this.arr);\n\n    for(var k=0; k<arguments.length; k++){\n      var s2 = arguments[k];\n      if(!(s2 instanceof BiwaScheme.Set))\n        throw new BiwaScheme.Error(\"set_union: arguments must be a set\");\n\n      for(var i=0; i<s2.arr.length; i++)\n        o.add(s2.arr[i]);\n    }\n    return o;\n  },\n  set_intersect : function(s2){\n    if(!(s2 instanceof BiwaScheme.Set))\n      throw new BiwaScheme.Error(\"set_intersect: arguments must be a set\");\n\n    var o = new BiwaScheme.Set();\n    for(var i=0; i<this.arr.length; i++)\n      if(s2.member(this.arr[i]))\n        o.add(this.arr[i]);\n    return o;\n  },\n  set_minus : function(s2){\n    if(!(s2 instanceof BiwaScheme.Set))\n      throw new BiwaScheme.Error(\"set_minus: arguments must be a set\");\n\n    var o = new BiwaScheme.Set();\n    for(var i=0; i<this.arr.length; i++)\n      if(!s2.member(this.arr[i]))\n        o.add(this.arr[i]);\n    return o;\n  },\n  add : function(item){\n    if(!this.member(item)){\n      this.arr.push(item);\n    }\n  },\n  member : function(item){\n    for(var i=0; i<this.arr.length; i++)\n      if(this.arr[i] == item) return true;\n\n    return false;\n  },\n  rindex : function(item){\n    for(var i=this.arr.length-1; i>=0 ; i--)\n      if(this.arr[i] == item) return (this.arr.length-1-i);\n\n    return null;\n  },\n  index : function(item){\n    for(var i=0; i<this.arr.length; i++)\n      if(this.arr[i] == item) return i;\n\n    return null;\n  },\n  inspect : function(){\n    return \"Set(\" + this.arr.join(\", \") + \")\";\n  },\n  toString : function(){\n    return this.inspect();\n  },\n  size : function(){\n    return this.arr.length;\n  }\n});\n//\n// Values\n//\nBiwaScheme.Values = BiwaScheme.Class.create({\n  initialize: function(values){\n    this.content = values;\n  },\n  to_write: function(){\n    return \"#<Values \" +\n             _.map(this.content, BiwaScheme.to_write).join(\" \") +\n           \">\";\n  }\n});\n\n//\n// Pair \n// cons cell\n//\n\nBiwaScheme.Pair = BiwaScheme.Class.create({\n  initialize: function(car, cdr){\n    this.car = car;\n    this.cdr = cdr;\n  },\n\n  caar: function(){ return this.car.car; },\n  cadr: function(){ return this.cdr.car; },\n  cdar: function(){ return this.cdr.car; },\n  cddr: function(){ return this.cdr.cdr; },\n\n  first:  function(){ return this.car; },\n  second: function(){ return this.cdr.car; },\n  third:  function(){ return this.cdr.cdr.car; },\n  fourth: function(){ return this.cdr.cdr.cdr.car; },\n  fifth:  function(){ return this.cdr.cdr.cdr.cdr.car; },\n\n  // returns array containing all the car's of list\n  // '(1 2 3) => [1,2,3]\n  // '(1 2 . 3) => [1,2]\n  to_array: function(){\n    var ary = [];\n    for(var o = this; o instanceof BiwaScheme.Pair; o=o.cdr){\n      ary.push(o.car);\n    }\n    return ary;\n  },\n\n  to_set: function(){\n    var set = new BiwaScheme.Set();\n    for(var o = this; o instanceof BiwaScheme.Pair; o=o.cdr){\n      set.add(o.car);\n    }\n    return set;\n  },\n\n  length: function(){\n    var n = 0;\n    for(var o = this; o instanceof BiwaScheme.Pair; o=o.cdr){\n      n++;\n    }\n    return n;\n  },\n\n  // Return the last cdr\n  last_cdr: function(){\n    var o;\n    for(o = this; o instanceof BiwaScheme.Pair; o = o.cdr)\n      ;\n    return o;\n  },\n\n  // calls the given func passing each car of list\n  // returns cdr of last Pair\n  foreach: function(func){\n    for(var o = this; o instanceof BiwaScheme.Pair; o=o.cdr){\n      func(o.car);\n    }\n    return o;\n  },\n\n  // Returns an array which contains the resuls of calling func\n  // with the car's as an argument.\n  // If the receiver is not a proper list, the last cdr is ignored.\n  // The receiver must not be a cyclic list.\n  map: function(func){\n    var ary = [];\n    for(var o = this; BiwaScheme.isPair(o); o = o.cdr){\n      ary.push(func(o.car));\n    }\n    return ary;\n  },\n\n  // Destructively concat the given list to the receiver.\n  // The receiver must be a proper list.\n  // Returns the receiver.\n  concat: function(list){\n    var o = this;\n    while(o instanceof BiwaScheme.Pair && o.cdr != BiwaScheme.nil){\n      o = o.cdr;\n    }\n    o.cdr = list;\n    return this;\n  },\n\n  // returns human-redable string of pair\n  inspect: function(conv){\n    conv || (conv = BiwaScheme.inspect);\n    var a = [];\n    var last = this.foreach(function(o){\n      a.push(conv(o));\n    });\n    if(last != BiwaScheme.nil){\n      a.push(\".\");\n      a.push(conv(last));\n    }\n    return \"(\" + a.join(\" \") + \")\";\n  },\n  toString : function(){\n    return this.inspect();\n  },\n\n  to_write: function(){\n    return this.inspect(BiwaScheme.to_write);\n  }\n});\n\n// Creates a list out of the arguments, optionally converting any nested arrays into nested lists if the deep argument is true.\n// Example:\n//   BiwaScheme.List(1, 2, [3, 4]) ;=> (list 1 2 (vector 3 4))\n//   BiwaScheme.deep_array_to_list(1, 2, [3, 4]) ;=> (list 1 2 (list 3 4))\nvar array_to_list = function(ary, deep) {\n  var list = BiwaScheme.nil;\n  for(var i=ary.length-1; i>=0; i--){\n    var obj = ary[i];\n    if(deep && _.isArray(obj) && !obj.is_vector){\n      obj = array_to_list(obj, deep);\n    }\n    list = new BiwaScheme.Pair(obj, list);\n  }\n  return list;\n}\n\n// Shallow: List(1, 2, [3]) == (list 1 2 (vector 3 4))\nBiwaScheme.List = function() {\n  var ary = _.toArray(arguments);\n  return array_to_list(ary, false);\n};\n\n// Shallow: array_to_list(1, 2, [3]) == (list 1 2 (vector 3 4))\nBiwaScheme.array_to_list = function(ary) {\n  return array_to_list(ary, false);\n};\n\n// Deep: deep_array_to_list(1, 2, [3, 4]) == (list 1 2 (list 3 4))\n// deep_array_to_list([1, 2, 3]) - deep\nBiwaScheme.deep_array_to_list = function(ary) {\n  return array_to_list(ary, true);\n};\n\nBiwaScheme.Cons = function(car, cdr) {\n  return new BiwaScheme.Pair(car, cdr);\n};\n//\n// Symbol\n//\n\nBiwaScheme.Symbol = BiwaScheme.Class.create({\n  initialize: function(str){\n    this.name = str;\n    BiwaScheme.Symbols[ str ] = this;\n  },\n\n  inspect: function(){\n    return \"'\"+this.name;\n    //return \"#<Symbol '\"+this.name+\"'>\";\n  },\n\n  toString: function(){\n    return \"'\"+this.name;\n  },\n\n  to_write: function(){\n    return this.name;\n  }\n});\nBiwaScheme.Symbols = {};\nBiwaScheme.Sym = function(name,leaveCase){\n  if( BiwaScheme.Symbols[name] === undefined ){\n    return new BiwaScheme.Symbol(name);\n  }\n  else if( ! (BiwaScheme.Symbols[name] instanceof BiwaScheme.Symbol) ){ //pre-defined member (like 'eval' in Firefox)\n    return new BiwaScheme.Symbol(name);\n  }\n  else{\n    return BiwaScheme.Symbols[name];\n  }\n}\n\nBiwaScheme.gensym = function(){\n  return BiwaScheme.Sym(_.uniqueId(\"__gensym\"));\n};\n//\n// Char\n//\n\nBiwaScheme.Char = BiwaScheme.Class.create({\n  initialize: function(c){\n    BiwaScheme.Chars[ this.value = c ] = this;\n  },\n  to_write: function(){\n    switch(this.value){\n      case '\\n': return \"#\\\\newline\";\n      case ' ':  return \"#\\\\space\";\n      case '\\t': return \"#\\\\tab\";\n      default:   return \"#\\\\\"+this.value;\n    }\n  },\n  inspect: function(){\n    return this.to_write();\n  }\n});\nBiwaScheme.Chars = {};\nBiwaScheme.Char.get = function(c) {\n  if(typeof(c) != \"string\") {\n    throw new BiwaScheme.Bug(\"Char.get: \" +\n                             BiwaScheme.inspect(c) + \" is not a string\");\n  }\n  if( BiwaScheme.Chars[c] === undefined )\n    return new BiwaScheme.Char(c);\n  else\n    return BiwaScheme.Chars[c];\n};\n\n//\n// number.js\n//\n\n//\n// Complex\n//\nBiwaScheme.Complex = BiwaScheme.Class.create({\n  initialize: function(real, imag){\n    this.real = real;\n    this.imag = imag;\n  },\n  magnitude: function(){\n    return Math.sqrt(this.real * this.real + this.imag * this.imag);\n  },\n  angle: function(){\n    return Math.atan2(this.imag, this.real);\n  },\n  isReal: function(){\n    return this.imag == 0;\n  },\n  isRational: function() {\n    return this.imag == 0 && BiwaScheme.isRational(this.real);\n  },\n  isInteger: function(){\n    return this.imag == 0 && BiwaScheme.isInteger(this.real);\n  },\n  toString: function(radix){\n    if (this.real === 0 && this.imag === 0)\n      return \"0\";\n    var img = \"\";\n    if (this.imag !== 0) {\n      if (this.imag > 0 && this.real !== 0){\n          img+=\"+\";\n      }\n      switch(this.imag) {\n          case 1:\n              break;\n          case -1: img+=\"-\";\n               break;\n          default: img+=this.imag.toString(radix);\n      }\n     img+=\"i\";\n    }\n    var real = \"\";\n    if (this.real !== 0){\n      real += this.real.toString(radix);\n    }\n    return real+img;\n  }\n})\nBiwaScheme.Complex.from_polar = function(r, theta){\n  var real = r * Math.cos(theta);\n  var imag = r * Math.sin(theta);\n  return new BiwaScheme.Complex(real, imag);\n}\nBiwaScheme.Complex.assure = function(num){\n  if(num instanceof BiwaScheme.Complex)\n    return num\n  else\n    return new BiwaScheme.Complex(num, 0);\n}\n\n//\n// Rational (unfinished)\n//\nBiwaScheme.Rational = BiwaScheme.Class.create({\n  initialize: function(numerator, denominator){\n    this.numerator = numerator;\n    this.denominator = denominator;\n  },\n\n  isInteger: function() {\n     // FIXME\n  }\n})\n\n//\n// Predicates\n//\nBiwaScheme.isNumber = function(x) {\n  return (x instanceof BiwaScheme.Complex)  ||\n         (x instanceof BiwaScheme.Rational) ||\n         (typeof(x) == 'number');\n};\nBiwaScheme.isComplex = BiwaScheme.isNumber;\nBiwaScheme.isReal = function(x) {\n  if (x instanceof BiwaScheme.Complex || x instanceof BiwaScheme.Rational) {\n    return x.isReal()\n  }\n  else {\n    return (typeof(x) == 'number');\n  }\n};\nBiwaScheme.isRational = function(x) {\n  if (x instanceof BiwaScheme.Complex) {\n    return x.isRational();\n  }\n  else if (x instanceof BiwaScheme.Rational) {\n    return true;\n  }\n  else {\n    return (typeof(x) == 'number');\n  }\n};\nBiwaScheme.isInteger = function(x) {\n  if (x instanceof BiwaScheme.Complex || x instanceof BiwaScheme.Rational) {\n    return x.isInteger();\n  }\n  else {\n    return (typeof(x) == 'number') && (x % 1 == 0);\n  }\n};\n//\n// Port\n//\n\n// (eof-object)\nBiwaScheme.eof = new Object;\n\nBiwaScheme.Port = BiwaScheme.Class.create({\n  initialize: function(is_in, is_out){\n    this.is_open = true;\n    this.is_binary = false; //??\n    this.is_input = is_in;\n    this.is_output = is_out;\n  },\n  close: function(){\n    // close port\n    this.is_open = false;\n  },\n  inspect: function(){\n    return \"#<Port>\";\n  },\n  to_write: function(){\n    return \"#<Port>\";\n  }\n});\n\n//\n// string ports (srfi-6)\n//\nBiwaScheme.Port.StringOutput = BiwaScheme.Class.extend(new BiwaScheme.Port(false, true), {\n  initialize: function(){\n    this.buffer = [];\n  },\n  put_string: function(str){\n    this.buffer.push(str);\n  },\n  output_string: function(str){\n    return this.buffer.join(\"\");\n  }\n});\n\nBiwaScheme.Port.StringInput = BiwaScheme.Class.extend(new BiwaScheme.Port(true, false), {\n  initialize: function(str){\n    this.str = str;\n  },\n  get_string: function(after){\n    return after(this.str);\n  }\n});\n\nBiwaScheme.Port.NullInput = BiwaScheme.Class.extend(new BiwaScheme.Port(true, false), {\n  initialize: function(){\n  },\n  get_string: function(after){\n    // Never give them anything!\n    return after('');\n  }\n});\n\nBiwaScheme.Port.NullOutput = BiwaScheme.Class.extend(new BiwaScheme.Port(false, true), {\n  initialize: function(output_function){\n    this.output_function = output_function;\n  },\n  put_string: function(str){}\n});\n\nBiwaScheme.Port.CustomOutput = BiwaScheme.Class.extend(new BiwaScheme.Port(false, true), {\n  initialize: function(output_function){\n    this.output_function = output_function;\n  },\n  put_string: function(str){\n    this.output_function(str);\n  }\n});\n\nBiwaScheme.Port.CustomInput = BiwaScheme.Class.extend(new BiwaScheme.Port(true, false), {\n  initialize: function(input_function){\n    this.input_function = input_function;\n  },\n  get_string: function(after){\n    var input_function = this.input_function;\n    return new BiwaScheme.Pause(function(pause) {\n      input_function(function(input) {\n        pause.resume(after(input));\n      });\n    });\n  }\n});\n\n// User must set the current input/output\nBiwaScheme.Port.current_input  = new BiwaScheme.Port.NullInput();\nBiwaScheme.Port.current_output = new BiwaScheme.Port.NullOutput();\nBiwaScheme.Port.current_error  = new BiwaScheme.Port.NullOutput();\n//\n// R6RS Records\n// http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-7.html#node_chap_6\n//\n// Record is like struct in C, but supports more feature like inheritance.\n// see also: src/library/r6rs_lib.js\n\n//\n// Record \n// represents each instance of record type\n//\nBiwaScheme.Record = BiwaScheme.Class.create({\n  initialize: function(rtd, values){\n    BiwaScheme.assert_record_td(rtd, \"new Record\");\n\n    this.rtd = rtd;\n    this.fields = values;\n  },\n\n  get: function(k){\n    return this.fields[k]\n  },\n\n  set: function(k, v){\n    this.fields[k] = v;\n  },\n\n  toString: function(){\n    var contents = BiwaScheme.to_write(this.fields);\n    return \"#<Record \"+this.rtd.name+\" \"+contents+\">\";\n  }\n});\n\nBiwaScheme.isRecord = function(o){\n  return (o instanceof BiwaScheme.Record);\n};\n\n// Defined record types\nBiwaScheme.Record._DefinedTypes = {};\n\nBiwaScheme.Record.define_type = function(name_str, rtd, cd){\n  return BiwaScheme.Record._DefinedTypes[name_str] = {rtd: rtd, cd: cd};\n};\nBiwaScheme.Record.get_type = function(name_str){\n  return BiwaScheme.Record._DefinedTypes[name_str];\n};\n\n//\n// RTD (Record type descriptor)\n//\nBiwaScheme.Record.RTD = BiwaScheme.Class.create({\n  //                   Symbol RTD        Symbol Bool  Bool    Array\n  initialize: function(name, parent_rtd, uid, sealed, opaque, fields){\n    this.name = name;\n    this.parent_rtd = parent_rtd;\n    this.is_base_type = !parent_rtd;\n\n    if(uid){\n      this.uid = uid;\n      this.generative = false;\n    }\n    else{\n      this.uid = this._generate_new_uid();;\n      this.generative = true;\n    }\n\n    this.sealed = !!sealed;\n    this.opaque = parent_rtd.opaque || (!!opaque);\n\n    this.fields = _.map(fields, function(field){\n      return {name: field[0], mutable: !!field[1]};\n    });\n  },\n\n  // Returns the name of the k-th field.\n  // Only used for error messages.\n  field_name: function(k){\n    var names = this._field_names();\n\n    for(par = this.parent_rtd; par; par = par.parent_rtd){\n      names = par._field_names() + names;\n    }\n\n    return names[k];\n  },\n  _field_names: function(){\n    return _.map(this.fields, function(spec){\n        return spec.name;\n      });\n  },\n\n  _generate_new_uid: function(){\n    return BiwaScheme.Sym(_.uniqueId(\"__record_td_uid\"));\n  },\n\n  toString: function(){\n    return \"#<RecordTD \"+name+\">\";\n  }\n});\n\nBiwaScheme.Record.RTD.NongenerativeRecords = {};\nBiwaScheme.isRecordTD = function(o){\n  return (o instanceof BiwaScheme.Record.RTD);\n};\n\n//\n// CD (Record constructor descriptor)\n//\nBiwaScheme.Record.CD = BiwaScheme.Class.create({\n  initialize: function(rtd, parent_cd, protocol){\n    this._check(rtd, parent_cd, protocol);\n    this.rtd = rtd;\n    this.parent_cd = parent_cd;\n    if(protocol){\n      this.has_custom_protocol = true;\n      this.protocol = protocol;\n    }\n    else{\n      this.has_custom_protocol = false;\n      if(rtd.parent_rtd)\n        this.protocol = this._default_protocol_for_derived_types();\n      else\n        this.protocol = this._default_protocol_for_base_types();\n    }\n  },\n\n  _check: function(rtd, parent_cd, protocol){\n    if(rtd.is_base_type && parent_cd)\n      throw new Error(\"Record.CD.new: cannot specify parent cd of a base type\");\n\n    if(parent_cd && rtd.parent_rtd && (parent_cd.rtd != rtd.parent_rtd))\n      throw new Error(\"Record.CD.new: mismatched parents between rtd and parent_cd\");\n\n    if(rtd.parent_rtd && !parent_cd && protocol)\n      throw new Error(\"Record.CD.new: protocol must be #f when parent_cd is not given\");\n\n    if(parent_cd && parent_cd.has_custom_protocol && !protocol)\n      throw new Error(\"Record.CD.new: protocol must be specified when parent_cd has a custom protocol\");\n  },\n  \n  _default_protocol_for_base_types: function(){\n    // (lambda (p) p)\n    // called with `p' as an argument\n    return function(ar){\n      var p = ar[0];\n      BiwaScheme.assert_procedure(p, \"_default_protocol/base\");\n      return p;\n    };\n  },\n\n  _default_protocol_for_derived_types: function(){\n    // (lambda (n) \n    //   (lambda (a b x y s t)\n    //     (let1 p (n a b x y) (p s t))))\n    // called with `n' as an argument\n    var rtd = this.rtd;\n    return function(ar){\n      var n = ar[0];\n      BiwaScheme.assert_procedure(n, \"_default_protocol/n\");\n\n      var ctor = function(args){\n        var my_argc = rtd.fields.length;\n        var ancestor_argc = args.length - my_argc;\n\n        var ancestor_values = args.slice(0, ancestor_argc);\n        var my_values       = args.slice(ancestor_argc);\n\n        // (n a b x y) => p\n        return new BiwaScheme.Call(n, ancestor_values, function(ar){\n          var p = ar[0];\n          BiwaScheme.assert_procedure(p, \"_default_protocol/p\");\n\n          // (p s t) => record\n          return new BiwaScheme.Call(p, my_values, function(ar){\n            var record = ar[0];\n            BiwaScheme.assert_record(record, \"_default_protocol/result\");\n\n            return record;\n          });\n        });\n      };\n      return ctor;\n    };\n  },\n\n  toString: function(){\n    return \"#<RecordCD \"+this.rtd.name+\">\";\n  },\n\n  record_constructor: function(){\n    var arg_for_protocol = (this.parent_cd ? this._make_n([], this.rtd)\n                                           : this._make_p());\n    arg_for_protocol = _.bind(arg_for_protocol, this);\n\n    return new BiwaScheme.Call(this.protocol, [arg_for_protocol], function(ar){\n      var ctor = ar[0];\n      BiwaScheme.assert_procedure(ctor, \"record_constructor\");\n      return ctor;\n    });\n  },\n\n  // Create the function `p' which is given to the protocol.\n  _make_p: function(){\n    return function(values){\n      return new BiwaScheme.Record(this.rtd, values);\n      // TODO: check argc \n    };\n  },\n\n  // Create the function `n' which is given to the protocol.\n  // When creating an instance of a derived type,\n  // _make_n is called for each ancestor rtd's.\n  _make_n: function(children_values, rtd){\n    var parent_cd = this.parent_cd;\n\n    if(parent_cd){\n      // called from protocol (n)\n      var n = function(args_for_n){\n\n        // called from protocol (p)\n        var p = function(args_for_p){\n          var values = [].concat(args_for_p[0]).concat(children_values)\n          var parent_n = parent_cd._make_n(values, rtd);\n\n          return new BiwaScheme.Call(parent_cd.protocol, [parent_n], function(ar){\n            var ctor = ar[0];\n            BiwaScheme.assert_procedure(ctor, \"_make_n\");\n\n            return new BiwaScheme.Call(ctor, args_for_n, function(ar){\n              var record = ar[0];\n              BiwaScheme.assert_record(record);\n              return record;\n            });\n          });\n        };\n        return p;\n      };\n      return n;\n    }\n    else{\n      var n = function(my_values){\n        var values = my_values.concat(children_values);\n        return new BiwaScheme.Record(rtd, values);\n        // TODO: check argc \n      };\n      return n;\n    }\n  }\n});\n\nBiwaScheme.isRecordCD = function(o){\n  return (o instanceof BiwaScheme.Record.CD);\n};\n// \n// R6RS Enumerations\n// http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-15.html#node_chap_14\n//\n// Example\n//\n//   (define-enumeration color\n//     (black white purple maroon)\n//     color-set)\n//   \n//   (color black)                  ;=> 'black\n//   (color purpel)                 ;=> &syntax exception\n//   (enum-set->list\n//     (color-set maroon white))    ;=> #<enum-set (white maroon)>\n\nBiwaScheme.Enumeration = {};\n\n// Represents an enum_type.\n//\n// Becuase there is no way to access an EnumType directly from Scheme,\n// EnumType#to_write is not defined.\n//\n// Properties\n//\n// members - Array of symbols (no duplicate)\n//\nBiwaScheme.Enumeration.EnumType = BiwaScheme.Class.create({\n  // Creates a new enum_type.\n  //\n  // members - Array of symbols.\n  //           Symbols may be duplicate (I think you shouldn't, though :-p).\n  initialize: function(members){\n    this.members = _.uniq(members);\n  },\n\n  // Returns an EnumSet.\n  universe: function(){\n    return new BiwaScheme.Enumeration.EnumSet(this, this.members);\n  }, \n\n  // Returns a function which map a symbol to an integer (or #f, if \n  // the symbol is out of the universe).\n  // \n  // Implementation note: don't forget this.members may have duplicates.\n  indexer: function(){\n    // ar[0] - a symbol\n    // Returns an integer or #f.\n    return _.bind(function(ar){\n      BiwaScheme.assert_symbol(ar[0], \"(enum-set indexer)\");\n      var idx = _.indexOf(this.members, ar[0]);\n      return (idx === -1) ? false : idx;\n    }, this);\n  },\n\n  // Retuns a function which creates an enum_set from a list of\n  // symbols (Symbols may be duplicate.)\n  constructor: function(){\n    // ar[0] - a list of symbol\n    // Returns a enum_set.\n    return _.bind(function(ar){\n      BiwaScheme.assert_list(ar[0], \"(enum-set constructor)\");\n      var symbols = ar[0].to_array();\n      _.each(symbols, function(arg){\n        BiwaScheme.assert_symbol(arg, \"(enum-set constructor)\");\n      });\n\n      return new BiwaScheme.Enumeration.EnumSet(this, symbols);\n    }, this);\n  }\n});\nBiwaScheme.Class.memoize(BiwaScheme.Enumeration.EnumType,\n  [\"universe\", \"indexer\", \"constructor\"]); \n\n// Represents an enum_set of an enum_type.\n//\n// Properties\n//\n// enum_type - The enum_type.\n// symbols   - Array of symbols (no duplicate, properly ordered)\n//\nBiwaScheme.Enumeration.EnumSet = BiwaScheme.Class.create({\n  // Creates a new enum_set.\n  //\n  // enum_type - An EnumType\n  // symbols   - Array of symbols.\n  //\n  // initialize normalizes symbols.\n  //   - remove duplicates\n  //   - order by universe\n  initialize: function(enum_type, symbols){\n    this.enum_type = enum_type;\n    this.symbols = _.filter(enum_type.members, function(sym){\n      return _.include(symbols, sym);\n    });\n  },\n\n  // Returns a list of symbols.\n  symbol_list: function(){\n    return BiwaScheme.array_to_list(this.symbols); \n  },\n  \n  // Returns true if the enum_set includes the symbol.\n  // 'symbol' is allowed to be a symbol which is not included in the universe.\n  is_member: function(symbol){\n    return _.include(this.symbols, symbol);\n  },\n  \n  // Returns true if:\n  // - the enum_set is a subset of the enum_set 'other', and\n  // - the universe of the enum_set is a subset of \n  //   the universe of 'other'.\n  // The enum_set and 'other' may belong to different enum_type.\n  is_subset: function(other){\n    // Check elements\n    if(_.any(this.symbols, function(sym){\n         return !_.include(other.symbols, sym);\n       })){\n      return false;\n    }\n\n    // Check universe\n    if(this.enum_type === other.enum_type){\n      return true;\n    }\n    else{\n      return _.all(this.enum_type.members, function(sym){\n               return _.include(other.enum_type.members, sym);\n             });\n    }\n  },\n\n  // Returns true if:\n  //   - the enum_set contains the same set of symbols as 'other', and\n  //   - universe of the enum_set contains the same set of symbols\n  //     as the universe of 'other'.\n  //\n  // The enum_set and 'other' may belong to different enum_type.\n  equal_to: function(other){\n    return this.is_subset(other) && other.is_subset(this);\n  },\n\n  // Returns a enum_set which has:\n  // - all the symbols included in the enum_set or the enum_set 'other'.\n  // The enum_set and 'other' *must* belong to the same enum_type.\n  union: function(other){\n    var syms = _.filter(this.enum_type.members, _.bind(function(sym){\n                 return _.include(this.symbols, sym) ||\n                        _.include(other.symbols, sym);\n               }, this));\n    return new BiwaScheme.Enumeration.EnumSet(this.enum_type, syms);\n  },\n\n  // Returns a enum_set which has:\n  // - the symbols included both in the enum_set or the enum_set 'other'.\n  // The enum_set and 'other' *must* belong to the same enum_type.\n  intersection: function(other){\n    var syms = _.filter(this.symbols, function(sym){\n                 return _.include(other.symbols, sym);\n               });\n    return new BiwaScheme.Enumeration.EnumSet(this.enum_type, syms);\n  },\n\n  // Returns a enum_set which has:\n  // - the symbols included in the enum_set and not in the enum_set 'other'.\n  // The enum_set and 'other' *must* belong to the same enum_type.\n  difference: function(other){\n    var syms = _.filter(this.symbols, function(sym){\n                 return !_.include(other.symbols, sym);\n               });\n    return new BiwaScheme.Enumeration.EnumSet(this.enum_type, syms);\n  },\n\n  // Returns a enum_set which has:\n  // - the symbols included in the universe but not in the enum_set.\n  complement: function(){\n    var syms = _.filter(this.enum_type.members, _.bind(function(sym){\n                 return !_.include(this.symbols, sym);\n               }, this));\n    return new BiwaScheme.Enumeration.EnumSet(this.enum_type, syms);\n  },\n\n  // Returns a enum_set which has:\n  // - the symbols included in the enum_set and the universe of the enum_set 'other'.\n  // The enum_set and 'other' may belong to different enum_type.\n  projection: function(other){\n    var syms = _.filter(this.symbols, function(sym){\n                 return _.include(other.enum_type.members, sym);\n               });\n    return new BiwaScheme.Enumeration.EnumSet(other.enum_type, syms);\n  },\n\n  // Returns a string which represents the enum_set.\n  toString: function(){\n    return \"#<EnumSet \"+BiwaScheme.inspect(this.symbols)+\">\";\n  }\n});\nBiwaScheme.Class.memoize(BiwaScheme.Enumeration.EnumSet, \"symbol_list\");\n\nBiwaScheme.isEnumSet = function(obj){\n  return (obj instanceof BiwaScheme.Enumeration.EnumSet);\n};\n//\n// Hashtable\n//\n// Based on the base JavaScript Object class, but\n//  * Object takes only strings as keys\n//  * R6RS hashtable needs its own hash function\n// so some hacks are needed.\n\nBiwaScheme.Hashtable = BiwaScheme.Class.create({\n  initialize: function(_hash_proc, _equiv_proc, mutable){\n    this.mutable = (mutable === undefined) ? true :\n                   mutable ? true : false;\n\n    this.hash_proc = _hash_proc;\n    this.equiv_proc = _equiv_proc;\n\n    // Hash (hashed) => (array of (key and value))\n    this.pairs_of = {};\n  },\n\n  clear: function(){\n    this.pairs_of = {};\n  },\n\n  candidate_pairs: function(hashed){\n    return this.pairs_of[hashed];\n  },\n\n  add_pair: function(hashed, key, value){\n    var pairs = this.pairs_of[hashed];\n\n    if (pairs) {\n      pairs.push([key, value]);\n    }\n    else {\n      this.pairs_of[hashed] = [[key, value]];\n    }\n  },\n\n  remove_pair: function(hashed, pair){\n    var pairs = this.pairs_of[hashed];\n    var i = pairs.indexOf(pair);\n    if (i == -1){\n      throw new BiwaScheme.Bug(\"Hashtable#remove_pair: pair not found!\");\n    }\n    else {\n      pairs.splice(i, 1); //remove 1 element from i-th index\n    }\n  },\n\n  create_copy: function(mutable){\n    var copy = new BiwaScheme.Hashtable(this.hash_proc, this.equiv_proc,\n                                        mutable);\n    // clone the pairs to copy\n    _.each(_.keys(this.pairs_of), _.bind(function(hashed){\n      var pairs = this.pairs_of[hashed];\n      var cloned = _.map(pairs, function(pair){\n        return _.clone(pair);\n      });\n      copy.pairs_of[hashed] = cloned;\n    }, this));\n\n    return copy;\n  },\n\n  size: function(){\n    var n = 0;\n    this._apply_pair(function(pair){\n      n++;\n    });\n    return n;\n  },\n\n  keys: function(){\n    return this._apply_pair(function(pair){\n      return pair[0];\n    });\n  },\n\n  values: function(){\n    return this._apply_pair(function(pair){\n      return pair[1];\n    });\n  },\n\n  _apply_pair: function(func){\n    var a = [];\n    _.each(_.values(this.pairs_of), function(pairs){\n      _.each(pairs, function(pair){\n        a.push(func(pair));\n      });\n    });\n    return a;\n  },\n\n  to_write: function(){\n    return \"#<Hashtable size=\" + this.size() + \">\";\n  }\n});\n\n//\n// Hash functions\n//\n\nBiwaScheme.Hashtable.equal_hash = function(ar){\n  return BiwaScheme.to_write(ar[0]);\n};\nBiwaScheme.Hashtable.eq_hash = BiwaScheme.Hashtable.equal_hash;\nBiwaScheme.Hashtable.eqv_hash = BiwaScheme.Hashtable.equal_hash;\n\nBiwaScheme.Hashtable.string_hash = function(ar){\n  return ar[0];\n};\n\nBiwaScheme.Hashtable.string_ci_hash = function(ar){\n  return _.isString(ar[0]) ? ar[0].toLowerCase() : ar[0];\n};\n\nBiwaScheme.Hashtable.symbol_hash = function(ar){\n  return (ar[0] instanceof BiwaScheme.Symbol) ? ar[0].name : ar[0];\n};\n\n//\n// Equivalence functions\n//\n\nBiwaScheme.Hashtable.eq_equiv = function(ar){\n  return BiwaScheme.eq(ar[0], ar[1]);\n};\n\nBiwaScheme.Hashtable.eqv_equiv = function(ar){\n  return BiwaScheme.eqv(ar[0], ar[1]);\n};\n//\n// Syntax\n//\nBiwaScheme.Syntax = BiwaScheme.Class.create({\n  initialize: function(sname, func){\n    this.sname = sname;\n    this.func = func;\n  },\n  transform: function(x){\n    if (!this.func){\n      throw new BiwaScheme.Bug(\"sorry, syntax \"+this.sname+\n                               \" is a pseudo syntax now\");\n    }\n    return this.func(x);\n  },\n  inspect: function(){\n    return \"#<Syntax \" + this.sname +\">\";\n  }\n})\n\n// A built-in syntax did not have associated Syntax object.\n// Following code installed dummy Syntax objects to built-in syntax.\nBiwaScheme.CoreEnv[\"define\"] = new BiwaScheme.Syntax(\"define\");\nBiwaScheme.CoreEnv[\"begin\"]  = new BiwaScheme.Syntax(\"begin\");\nBiwaScheme.CoreEnv[\"quote\"]  = new BiwaScheme.Syntax(\"quote\");\nBiwaScheme.CoreEnv[\"lambda\"] = new BiwaScheme.Syntax(\"lambda\");\nBiwaScheme.CoreEnv[\"if\"]     = new BiwaScheme.Syntax(\"if\");\nBiwaScheme.CoreEnv[\"set!\"]   = new BiwaScheme.Syntax(\"set!\");\n  //\n  // Parser \n  // copied from jsScheme - should be rewrriten (support #0=, etc)\n  //\n  BiwaScheme.Parser = BiwaScheme.Class.create({\n    initialize: function(txt){\n      this.tokens = this.tokenize(txt);\n      this.i = 0;\n    },\n\n    inspect: function(){\n      return [\n        \"#<Parser:\",\n        this.i, \"/\", this.tokens.length, \" \",\n        BiwaScheme.inspect(this.tokens),\n        \">\"\n      ].join(\"\");\n    },\n\n    tokenize: function(txt) {\n      var tokens = new Array(), oldTxt=null;\n      var in_srfi_30_comment = 0;\n\n      while( txt != \"\" && oldTxt != txt ) {\n        oldTxt = txt;\n        txt = txt.replace( /^\\s*(;[^\\r\\n]*(\\r|\\n|$)|#;|#\\||#\\\\[^\\w]|#?(\\(|\\[|{)|\\)|\\]|}|\\'|`|,@|,|\\+inf\\.0|-inf\\.0|\\+nan\\.0|\\\"(\\\\(.|$)|[^\\\"\\\\])*(\\\"|$)|[^\\s()\\[\\]{}]+)/,\n        function($0,$1) {\n          var t = $1;\n\n          if (t == \"#|\") {\n            in_srfi_30_comment++;\n            return \"\";\n          }\n          else if (in_srfi_30_comment > 0) {\n            if ( /(.*\\|#)/.test(t) ) {\n              in_srfi_30_comment--;\n              if (in_srfi_30_comment < 0) {\n                throw new BiwaScheme.Error(\"Found an extra comment terminator: `|#'\")\n              }\n              // Push back the rest substring to input stream.\n              return t.substring(RegExp.$1.length, t.length);\n            }\n            else {\n              return \"\";\n            }\n          }\n          else {\n            if( t.charAt(0) != ';' ) tokens[tokens.length]=t;\n            return \"\";\n          }\n        } );\n      }\n      return tokens;\n    },\n\n    sexpCommentMarker: new Object,\n    getObject: function() {\n      var r = this.getObject0();\n\n      if (r != this.sexpCommentMarker)\n        return r;\n\n      r = this.getObject();\n      if (r == BiwaScheme.Parser.EOS)\n        throw new BiwaScheme.Error(\"Readable object not found after S exression comment\");\n\n      r = this.getObject();\n      return r;\n    },\n    \n    getList: function( close ) {\n      var list = BiwaScheme.nil, prev = list;\n      while( this.i < this.tokens.length ) {\n\n        this.eatObjectsInSexpComment(\"Input stream terminated unexpectedly(in list)\");\n\n        if( this.tokens[ this.i ] == ')' || this.tokens[ this.i ] == ']' || this.tokens[ this.i ] == '}' ) {\n          this.i++; break;\n        }\n\n        if( this.tokens[ this.i ] == '.' ) {\n          this.i++;\n          var o = this.getObject();\n          if( o != BiwaScheme.Parser.EOS && list != BiwaScheme.nil ) {\n            prev.cdr = o;\n          }\n        } else {\n            var cur = new BiwaScheme.Pair( this.getObject(), BiwaScheme.nil);\n            if( list == BiwaScheme.nil ) list = cur;\n            else prev.cdr = cur;\n            prev = cur;\n        }\n      }\n      return list;\n    },\n\n    getVector: function( close ) {\n      var arr = new Array();\n      while( this.i < this.tokens.length ) {\n        \n        this.eatObjectsInSexpComment(\"Input stream terminated unexpectedly(in vector)\");\n        \n        if( this.tokens[ this.i ] == ')' ||\n        this.tokens[ this.i ] == ']' ||\n        this.tokens[ this.i ] == '}' ) { this.i++; break; }\n        arr[ arr.length ] = this.getObject();\n      }\n      return arr;\n    },\n\n    eatObjectsInSexpComment: function(err_msg) {\n      while( this.tokens[ this.i ] == '#;' ) {\n        this.i++;\n        if ((this.getObject() == BiwaScheme.Parser.EOS) || (this.i >= this.tokens.length))\n          throw new BiwaScheme.Error(err_msg);  \n      }\n    }, \n\n    getObject0: function() {\n      if( this.i >= this.tokens.length )\n        return BiwaScheme.Parser.EOS;\n\n      var t = this.tokens[ this.i++ ];\n      // if( t == ')' ) return null;\n\n      if (t == '#;')\n        return this.sexpCommentMarker;\n\n      var s = t == \"'\"  ? 'quote' :\n              t == \"`\"  ? 'quasiquote' :\n              t == \",\"  ? 'unquote' :\n              t == \",@\" ? 'unquote-splicing' : false;\n\n      if( s || t == '(' || t == '#(' || t == '[' || t == '#[' || t == '{' || t == '#{' ) {\n        return s ? new BiwaScheme.Pair( BiwaScheme.Sym(s), new BiwaScheme.Pair( this.getObject(), BiwaScheme.nil ))\n        : (t=='(' || t=='[' || t=='{') ? this.getList(t) : this.getVector(t);\n      } \n      else {\n        switch(t){\n          case \"+inf.0\" : return Infinity;\n          case \"-inf.0\" : return -Infinity;\n          case \"+nan.0\" : return NaN;\n        }\n\n        var n;\n        if( /^#x[0-9a-z]+$/i.test(t) ) {  // #x... Hex\n          n = new Number('0x'+t.substring(2,t.length) );\n        } \n        else if( /^#d[0-9\\.]+$/i.test(t) ) {  // #d... Decimal\n          n = new Number( t.substring(2,t.length) );\n        } \n        else{\n          n = new Number(t);  // use constrictor as parser\n        }\n\n        if( ! isNaN(n) ) {\n          return n.valueOf();\n        } else if( t == '#f' || t == '#F' ) {\n          return false;\n        } else if( t == '#t' || t == '#T' ) {\n          return true;\n        } else if( t.toLowerCase() == '#\\\\newline' ) {\n          return BiwaScheme.Char.get('\\n');\n        } else if( t.toLowerCase() == '#\\\\space' ) {\n          return BiwaScheme.Char.get(' ');\n        } else if( t.toLowerCase() == '#\\\\tab' ) {\n          return BiwaScheme.Char.get('\\t');\n        } else if( /^#\\\\.$/.test(t) ) {\n          return BiwaScheme.Char.get( t.charAt(2) );\n        } else if( /^#\\\\x[a-zA-Z0-9]+$/.test(t) ) {\n          var scalar = parseInt(t.slice(3), 16);\n          // R6RS 11.11 (surrogate codepoints)\n          if (scalar >= 0xD800 && scalar <= 0xDFFF) {\n            throw new BiwaScheme.Error(\"Character in Unicode excluded range.\");\n          }\n          // ECMA-262 4.3.16 -- Basically, strings are sequences of 16-bit\n          // unsigned integers, so anything greater than 0xFFFF won't fit.\n          // NOTE: This violates R6RS which requires the full Unicode range!\n          else if (scalar > 0xFFFF) {\n            throw new BiwaScheme.Error(\"Character literal out of range.\");\n          } else {\n            return BiwaScheme.Char.get(String.fromCharCode(scalar));\n          }\n        } else if( /^\\\"(\\\\(.|$)|[^\\\"\\\\])*\\\"?$/.test(t) ) {\n          return t.replace(/(\\r?\\n|\\\\n)/g, \"\\n\").replace( /^\\\"|\\\\(.|$)|\\\"$/g, function($0,$1) {\n            return $1 ? $1 : '';\n          } );\n        } else return BiwaScheme.Sym(t);  // 2Do: validate !!\n      }\n    }\n  });\n  // indicates end of source file\n  BiwaScheme.Parser.EOS = new Object();\n  \n\n///\n/// Compiler\n///\n/// Note: macro expansion is done by Intepreter#expand\n\nBiwaScheme.Compiler = BiwaScheme.Class.create({\n  initialize: function(){\n  },\n\n  is_tail: function(x){\n    return (x[0] == \"return\");\n  },\n\n  //free: set\n  //e: env(= [locals, frees])\n  //next: opc\n  //ret: opc[\"refer_*\", n, [\"argument\", \n  //          [\"refer_*\", n, ... [\"argument\", next]\n  collect_free: function(free, e, next){\n    var vars = free;\n    var opc = next;\n    var arr = vars.arr;\n    for(var i=0; i<arr.length; i++){\n      opc = this.compile_refer(arr[i], e, [\"argument\", opc]);\n    }\n    //Console.puts(\"collect_free \"+free.inspect()+\" / \"+e.inspect()+\" => \"+opc.inspect());\n    return opc;\n  },\n\n  //x: Symbol\n  //e: env [set of locals, set of frees]\n  //ret: opc\n  compile_refer: function(x, e, next){\n    return this.compile_lookup(x, e,\n             function(n){ return [\"refer-local\", n, next] },\n             function(n){ return [\"refer-free\",  n, next] },\n             function(sym){ return [\"refer-global\", sym, next] });\n  },\n\n  compile_lookup: function(x, e, return_local, return_free, return_global){\n    var locals = e[0], free = e[1];\n    if((n = locals.index(x)) != null){\n      //Console.puts(\"compile_refer:\"+x.inspect()+\" in \"+e.inspect()+\" results refer-local \"+n);\n      return return_local(n);\n    }\n    else if((n = free.index(x)) != null){\n      //Console.puts(\"compile_refer:\"+x.inspect()+\" in \"+e.inspect()+\" results refer-free \"+n);\n      return return_free(n);\n    }\n    else{\n      var sym = x.name;\n      return return_global(sym);\n    }\n    //throw new BiwaScheme.Error(\"undefined symbol `\" + sym + \"'\");\n  },\n\n  //generate boxing code (intersection of sets & vars)\n  //if no need of boxing, just returns next\n  //  sets(Set): assigned variables \n  //  vars(List): used variables\n  //  next(opc):\n  //  ret(opc):\n  make_boxes: function(sets, vars, next){\n    var vars = vars;\n    var n = 0;\n    var a = [];\n    while(vars instanceof BiwaScheme.Pair){\n      if(sets.member(vars.car))\n        a.push(n);\n      n++;\n      vars = vars.cdr;\n    }\n    var opc = next;\n    for(var i=a.length-1; i>=0; i--)\n      opc = [\"box\", a[i], opc];\n    return opc;\n  },\n\n  // Enumerate variables which (could be assigned && included in v)\n  // x: exp\n  // v: set(vars)\n  // ret: set\n  find_sets: function(x, v){\n    //Console.puts(\"find_sets: \" + to_write(x) + \" \" + to_write(v))\n    var ret=null;\n    if(x instanceof BiwaScheme.Symbol){\n      ret = new BiwaScheme.Set();\n    }\n    else if(x instanceof BiwaScheme.Pair){\n      switch(x.first()){\n      case BiwaScheme.Sym(\"define\"):\n        var exp=x.third();\n        ret = this.find_sets(exp, v);\n      case BiwaScheme.Sym(\"begin\"):\n        ret = this.find_sets(x.cdr, v); //(ignores improper list)\n        break;\n      case BiwaScheme.Sym(\"quote\"):\n        ret = new BiwaScheme.Set();\n        break;\n      case BiwaScheme.Sym(\"lambda\"):\n        var vars=x.second(), body=x.cdr.cdr;\n        if (vars instanceof BiwaScheme.Pair){ // (lambda (...) ...)\n          ret = this.find_sets(body, v.set_minus(vars.to_set()));\n        }\n        else { // (lambda args ...)\n          ret = this.find_sets(body, v.set_minus(new BiwaScheme.Set(vars)));\n        }\n        break;\n      case BiwaScheme.Sym(\"if\"):\n        var testc=x.second(), thenc=x.third(), elsec=x.fourth();\n        ret = this.find_sets(testc, v).set_union(\n                        this.find_sets(thenc, v),\n                        this.find_sets(elsec, v));\n        break;\n      case BiwaScheme.Sym(\"set!\"):\n        var vari=x.second(), xx=x.third();\n        if(v.member(vari))\n          ret = this.find_sets(xx, v).set_cons(vari);\n        else\n          ret = this.find_sets(xx, v);\n        break;\n      case BiwaScheme.Sym(\"call/cc\"):\n        var exp=x.second();\n        ret = this.find_sets(exp, v);\n        break;\n      default:\n        var set = new BiwaScheme.Set();\n        for(var p=x; p instanceof BiwaScheme.Pair; p=p.cdr){\n          set = set.set_union(this.find_sets(p.car, v));\n        }\n        ret = set;\n        break;\n      }\n    }\n    else{\n      ret = new BiwaScheme.Set();\n    }\n\n    if(ret == null)\n      throw new BiwaScheme.Bug(\"find_sets() exited in unusual way\");\n    else\n      return ret;\n  },\n\n  // find_free(): find free variables in x\n  //              these variables are collected by collect_free().\n  // x: expression \n  // b: set of local vars (= variables which are not free)\n  // f: set of free var candidates \n  //    (local vars of outer lambdas)\n  // ret: set of free vars\n  find_free: function(x, b, f){\n    var ret=null;\n    if(x instanceof BiwaScheme.Symbol){\n      if(f.member(x))\n        ret = new BiwaScheme.Set(x);\n      else\n        ret = new BiwaScheme.Set();\n    }\n    else if(x instanceof BiwaScheme.Pair){\n      switch(x.first()){\n      case BiwaScheme.Sym(\"define\"):\n        var exp=x.third();\n        ret = this.find_free(exp, b, f);\n        break;\n      case BiwaScheme.Sym(\"begin\"):\n        ret = this.find_free(x.cdr, b, f); //(ignores improper list)\n        break;\n      case BiwaScheme.Sym(\"quote\"):\n        ret = new BiwaScheme.Set();\n        break;\n      case BiwaScheme.Sym(\"lambda\"):\n        var vars=x.second(), body=x.cdr.cdr;\n        if (vars instanceof BiwaScheme.Pair){ // (lambda (...) ...)\n          ret = this.find_free(body, b.set_union(vars.to_set()), f);\n        }\n        else { // (lambda args ...)\n          ret = this.find_free(body, b.set_cons(vars), f);\n        }\n        break;\n      case BiwaScheme.Sym(\"if\"):\n        var testc=x.second(), thenc=x.third(), elsec=x.fourth();\n        ret = this.find_free(testc, b, f).set_union(\n                        this.find_free(thenc, b, f),\n                        this.find_free(elsec, b, f));\n        break;\n      case BiwaScheme.Sym(\"set!\"):\n        var vari=x.second(), exp=x.third();\n        if(f.member(vari))\n          ret = this.find_free(exp, b, f).set_cons(vari);\n        else\n          ret = this.find_free(exp, b, f)\n        break;\n      case BiwaScheme.Sym(\"call/cc\"):\n        var exp=x.second();\n        ret = this.find_free(exp, b, f);\n        break;\n      default:\n        var set = new BiwaScheme.Set();\n        for(var p=x; p instanceof BiwaScheme.Pair; p=p.cdr){\n          set = set.set_union(this.find_free(p.car, b, f));\n        }\n        ret = set;\n        break;\n      }\n    }\n    else{\n      ret = new BiwaScheme.Set();\n    }\n    //Console.p(\"find_free \"+x.inspect()+\" / \"+b.inspect()+\" => \"+ret.inspect());\n\n    if(ret == null)\n      throw new BiwaScheme.Bug(\"find_free() exited in unusual way\");\n    else\n      return ret;\n  },\n\n  // Returns the position of the dot pair.\n  // Returns -1 if x is a proper list.\n  //\n  // eg. (a b . c) -> 2\n  find_dot_pos: function(x){\n    var idx = 0;\n    for (; x instanceof BiwaScheme.Pair; x = x.cdr, ++idx)\n      ;\n    if (x != BiwaScheme.nil) {\n      return idx;\n    } else {\n      return -1;\n    }\n  },\n\n  last_pair: function(x){\n    if (x instanceof BiwaScheme.Pair){\n      for (; x.cdr instanceof BiwaScheme.Pair; x = x.cdr)\n        ;\n    }\n    return x;\n  },\n\n  // Takes an dotted list and returns proper list.\n  //\n  // eg. (x y . z) -> (x y z)\n  dotted2proper: function(ls){\n    var nreverse = function(ls){\n      var res = BiwaScheme.nil;\n      for (; ls instanceof BiwaScheme.Pair; ){\n        var d = ls.cdr;\n        ls.cdr = res;\n        res = ls;\n        ls = d;\n      }\n      return res;\n    }\n    var copy_list = function(ls){\n      var res = BiwaScheme.nil;\n      for (; ls instanceof BiwaScheme.Pair; ls = ls.cdr){\n        res = new BiwaScheme.Pair(ls.car, res);\n      }\n      return nreverse(res);\n    }\n\n    if (ls instanceof BiwaScheme.Pair) {\n      var last = this.last_pair(ls);\n      if (last instanceof BiwaScheme.Pair && last.cdr === BiwaScheme.nil){\n        return ls;\n      } else {\n        var copied = copy_list(ls);\n        this.last_pair(copied).cdr = new BiwaScheme.Pair(last.cdr, BiwaScheme.nil);\n        return copied;\n      }\n    } else {\n      return new BiwaScheme.Pair(ls, BiwaScheme.nil);\n    }\n  },\n\n  // x: exp(list of symbol or integer or..)\n  // e: env (= [locals, frees])\n  // s: vars might be set!\n  // next: opc\n  // ret: opc\n  compile: function(x, e, s, f, next){\n    //Console.p(x);\n    var ret = null;\n\n    while(1){\n      if(x instanceof BiwaScheme.Symbol){\n        // Variable reference\n        // compiled into refer-(local|free|global)\n        return this.compile_refer(x, e, (s.member(x) ? [\"indirect\", next] : next));\n      }\n      else if(x instanceof BiwaScheme.Pair){\n        switch(x.first()){\n        case BiwaScheme.Sym(\"define\"):\n          ret = this._compile_define(x, next);\n\n          x = ret[0];\n          next = ret[1];\n          break;\n\n        case BiwaScheme.Sym(\"begin\"):\n          var a = [];\n          for(var p=x.cdr; p instanceof BiwaScheme.Pair; p=p.cdr)\n            a.push(p.car);\n\n          //compile each expression (in reverse order)\n          var c = next;\n          for(var i=a.length-1; i>=0; i--){\n            c = this.compile(a[i], e, s, f, c);\n          }\n          return c;\n\n        case BiwaScheme.Sym(\"quote\"):\n          if(x.length() < 2)\n              throw new BiwaScheme.Error(\"Invalid quote: \"+x.to_write());\n\n          var obj=x.second();\n          return [\"constant\", obj, next];\n\n        case BiwaScheme.Sym(\"lambda\"):\n          return this._compile_lambda(x, e, s, f, next);\n\n        case BiwaScheme.Sym(\"if\"):\n          if(x.length() < 3 || x.length() > 4)\n              throw new BiwaScheme.Error(\"Invalid if: \"+x.to_write());\n\n          var testc=x.second(), thenc=x.third(), elsec=x.fourth();\n          var thenc = this.compile(thenc, e, s, f, next);\n          var elsec = this.compile(elsec, e, s, f, next);\n          x    = testc;\n          next = [\"test\", thenc, elsec];\n          break;\n\n        case BiwaScheme.Sym(\"set!\"):\n          // error-checking: should have only 3 things\n          if(x.length() != 3)\n              throw new BiwaScheme.Error(\"Invalid set!: \"+x.to_write());\n\n          var v=x.second(), x=x.third();\n          var do_assign = this.compile_lookup(v, e,\n            function(n){ return [\"assign-local\", n, next]; },\n            function(n){ return [\"assign-free\",  n, next]; },\n            function(sym){ return [\"assign-global\",sym, next]; }\n          );\n          next = do_assign;\n          break;\n\n        case BiwaScheme.Sym(\"call/cc\"): \n          var x=x.second();\n          var c = [\"conti\", \n                    (this.is_tail(next) ? (e[0].size() + 1) : 0), //number of args for outer lambda\n                    [\"argument\",\n                    [\"constant\", 1,\n                    [\"argument\",\n                      this.compile(x, e, s,f,  \n                        (this.is_tail(next) ? [\"shift\", 1, [\"tco_hinted_apply\"]]\n                                            : [\"apply\"]))]]]];\n                  //note: proc for call/cc takes 1 argument (= [\"apply\", 1])\n\n          // Do not push stack frame when call/cc is in a tail context\n          return this.is_tail(next) ? c : [\"frame\", c, next];\n\n        default: \n          //apply \n          //x = (func 1 2) \n          //x.car = func = '(lambda (x) ..) or Symbol\n          //x.cdr = args = '(1 2)\n          var func = x.car;\n          var args = x.cdr;\n          var c = this.compile(func, e, s,f,  \n                    this.is_tail(next) ? [\"shift\", args.length(), [\"tco_hinted_apply\"]]\n                                       : [\"apply\"]);\n\n          // VM will push the number of arguments to the stack.\n          c = this.compile(args.length(), e, s, f, [\"argument\", c]);\n          for(var p=args; p instanceof BiwaScheme.Pair; p=p.cdr){\n            c = this.compile(p.car, e, s, f, [\"argument\", c]);\n          }\n\n          // Do not push stack frame for tail calls\n          return this.is_tail(next) ? c : [\"frame\", c, next];\n        }\n      }\n      else{\n        return [\"constant\", x, next];\n      }\n    }\n    //Console.p(\"result of \" + x.inspect() + \":\");\n    //Console.p(ret);\n    //dump({\"ret\":ret, \"x\":x, \"e\":e, \"s\":s, \"next\":next, \"stack\":[]});\n//      if(ret == null)\n//        throw new BiwaScheme.Bug(\"compile() exited in unusual way\");\n//      else\n//        return ret;\n  },\n\n  // Compile define.\n  //\n  // 0. (define) ; => error\n  // 1. (define a)\n  // 2. (define a 1)\n  // 3. (define a 1 2) ; => error\n  // 4. (define (f x) x), (define (f . a) a)\n  // 5. (define 1 2) \n  //\n  // Note: define may appear in lambda, let, let*, let-values,\n  // let*-values, letrec, letrec*. These definitions are local to the\n  // <body> of these forms.\n  _compile_define: function(x, next){\n    if(x.length() == 1) { // 0. (define)\n      throw new BiwaScheme.Error(\"Invalid `define': \"+x.to_write());\n    }\n\n    var first = x.cdr.car;\n    var rest = x.cdr.cdr;\n    \n    if(first instanceof BiwaScheme.Symbol){    \n      if (rest === BiwaScheme.nil) { // 1. (define a)\n        x = BiwaScheme.undef;\n      }\n      else {\n        if (rest.cdr === BiwaScheme.nil) // 2. (define a 1)\n          x = rest.car;\n        else // 3. (define a 1 2)\n          throw new BiwaScheme.Error(\"Invalid `define': \"+x.to_write());\n      }\n\n      if (!BiwaScheme.TopEnv.hasOwnProperty(first.name)) {\n        BiwaScheme.TopEnv[first.name] = BiwaScheme.undef;\n      }\n      next = [\"assign-global\", first.name, next];\n    }\n    else if(first instanceof BiwaScheme.Pair){ // 4. (define (f x) ...)\n      // Note: define of this form may contain internal define.\n      // They are handled in compilation of \"lambda\".\n\n      var fname=first.car, args=first.cdr;\n      var lambda = new BiwaScheme.Pair(BiwaScheme.Sym(\"lambda\"), new BiwaScheme.Pair(args, rest));\n      x = lambda;\n      if (!BiwaScheme.TopEnv.hasOwnProperty(first.name)) {\n        BiwaScheme.TopEnv[fname.name] = BiwaScheme.undef;\n      }\n      next = [\"assign-global\", fname.name, next];\n    }\n    else{ // 5. (define 1 2)\n      throw new BiwaScheme.Error(\"define: symbol or pair expected but got \"+first);\n    }\n\n    return [x, next];\n  },\n\n  // Compiles various forms of \"lambda\".\n  //\n  // * (lambda (x y) ...)\n  // * (lambda (x y . rest) ...)\n  // * (lambda args ...)\n  _compile_lambda: function(x, e, s, f, next){\n    if(x.length() < 3)\n      throw new BiwaScheme.Error(\"Invalid lambda: \"+x.to_write());\n\n    var vars = x.cdr.car;\n    var body = x.cdr.cdr;\n\n    // Handle internal defines\n    var tbody = BiwaScheme.Compiler.transform_internal_define(body);\n    if(BiwaScheme.isPair(tbody) &&\n       BiwaScheme.isSymbol(tbody.car) &&\n       tbody.car.name == \"letrec*\"){\n      // The body has internal defines.\n      // Expand letrec* macro\n      var cbody = BiwaScheme.Interpreter.expand(tbody);\n    }\n    else{\n      // The body has no internal defines.\n      // Just wrap the list with begin \n      var cbody = new BiwaScheme.Pair(BiwaScheme.Sym(\"begin\"), x.cdr.cdr);\n    }\n\n    var dotpos = this.find_dot_pos(vars);\n    var proper = this.dotted2proper(vars);\n    var free = this.find_free(cbody, proper.to_set(), f); //free variables\n    var sets = this.find_sets(cbody, proper.to_set());    //local variables\n\n    var do_body = this.compile(cbody,\n                    [proper.to_set(), free],\n                    sets.set_union(s.set_intersect(free)),\n                    f.set_union(proper.to_set()),\n                    [\"return\"]);\n    var do_close = [\"close\", \n                     free.size(),\n                     this.make_boxes(sets, proper, do_body),\n                     next,\n                     dotpos];\n    return this.collect_free(free, e, do_close);\n  },\n\n  run: function(expr){\n    return this.compile(expr, [new BiwaScheme.Set(), new BiwaScheme.Set()], new BiwaScheme.Set(), new BiwaScheme.Set(), [\"halt\"]);\n  }\n});\n\n// Compile an expression with new compiler\nBiwaScheme.Compiler.compile = function(expr, next){\n  expr = BiwaScheme.Interpreter.expand(expr);\n  return (new BiwaScheme.Compiler).run(expr, next);\n};\n\n// Transform internal defines to letrec*.\n//\n// Example\n//   (let ((a 1))\n//     (define (b) a)\n//     (b))\n//\n//   (let ((a 1))\n//     (letrec* ((b (lambda () a)))\n//       (b)))\n//\n// x - expression starts with (define ...)\n// \n// Returns a letrec* expression, or\n// just returns x, when x does not contain definitions.\n(function(){\n// Returns true if x is a definition\nvar is_definition = function(x){\n  return BiwaScheme.isPair(x) &&\n         BiwaScheme.Sym(\"define\") === x.car;\n  // TODO: support \"begin\", nested \"begin\", \"let(rec)-syntax\"\n};\n\n// Convert function definition to lambda binding\n//   (define a ..)         -> (a ..)\n//   (define (f) ..)       -> (f (lambda () ..))\n//   (define (f x . y) ..) -> (f (lambda (x . y) ..))\n//   (define (f . a) ..)   -> (f (lambda a ..))\nvar define_to_lambda_bind = function(def){\n  var sig  = def.cdr.car;\n  var body = def.cdr.cdr;\n\n  if (BiwaScheme.isSymbol(sig)) {\n    var variable = sig;\n\n    return new BiwaScheme.Pair(variable, body);\n  }\n  else {\n    var variable = sig.car;\n    var value = new BiwaScheme.Pair(BiwaScheme.Sym(\"lambda\"),\n                  new BiwaScheme.Pair(sig.cdr, body));\n\n    return BiwaScheme.List(variable, value);\n  }\n};\n\nBiwaScheme.Compiler.transform_internal_define = function(x){\n  // 1. Split x into definitions and expressions\n  var defs = [], item = x;\n  while (is_definition(item.car)){\n    defs.push(item.car);\n    item = item.cdr;\n  }\n  var exprs = item;\n\n  // 2. Return x if there is no definitions\n  if (defs.length == 0)\n    return x;\n  \n  // 3. Return (letrec* <bindings> <expressions>)\n  var bindings = BiwaScheme.List.apply(null, _.map(defs, define_to_lambda_bind));\n  return new BiwaScheme.Pair(BiwaScheme.Sym(\"letrec*\"),\n           new BiwaScheme.Pair(bindings, exprs));\n};\n})();\n//\n// pause object (facility to stop/resume interpreting)\n//\nBiwaScheme.Pause = BiwaScheme.Class.create({\n  //new (on_pause: javascript function calling setTimeout, Ajax.Request, ..)\n  initialize: function(on_pause){\n    this.on_pause = on_pause;\n  },\n\n  //save state of interpreter\n  set_state: function(intp, x, f, c, s){\n    this.interpreter = intp;\n    this.x = x;\n    this.f = f;\n    this.c = c;\n    this.s = s;\n  },\n\n  //call this when ready (to fire setTimeout, Ajax.Request..)\n  ready: function(){\n    this.on_pause(this);\n  },\n\n  //restart calculation\n  resume: function(value){\n    return this.interpreter.resume(true, value, this.x, this.f, this.c, this.s)\n  }\n});\n\n///\n/// Call\n///\n\n// The class Call is used to invoke scheme closure from \n// library functions.\n//\n// Call#initialize takes three arguments: proc, args and after.\n//   * proc is the scheme closure to invoke.\n//   * args is an Array (not list!) of arguments for the invocation.\n//   * after is a javascript function which is invoked when \n//     returned from the proc.\n//\n//     after takes two arguments: ar and intp.\n//       * ar is an Array which contains the result of the invocation.\n//       * intp is an Interpreter which is running.\n//\n//     If after returns another Call object, another invocation\n//     happens. If after returns a normal value, it is the value\n//     of the library function.\n//\n// example:\n//   return new Call(proc, [x, y], function(ar){ ar[0] });\n//\nBiwaScheme.Call = BiwaScheme.Class.create({\n  initialize: function(proc, args, after){\n    this.proc = proc;\n    this.args = args;\n    this.after = after || function(ar){\n      // just return result which closure returned\n      return ar[0];\n    };\n  },\n\n  inspect: function(){\n    return \"#<Call args=\" + this.args.inspect() + \">\";\n  },\n\n  toString: function(){\n    return \"#<Call>\";\n  },\n\n  to_write: function(){\n    return \"#<Call>\";\n  }\n})\n\n//\n// Iterator - external iterator for Call.foreach\n//\nBiwaScheme.Iterator = {\n  ForArray: BiwaScheme.Class.create({\n    initialize: function(arr){\n      this.arr = arr;\n      this.i = 0;\n    },\n    has_next: function(){\n      return this.i < this.arr.length;\n    },\n    next: function(){\n      return this.arr[this.i++];\n    }\n  }),\n  ForString: BiwaScheme.Class.create({\n    initialize: function(str){\n      this.str = str;\n      this.i = 0;\n    },\n    has_next: function(){\n      return this.i < this.str.length;\n    },\n    next: function(){\n      return BiwaScheme.Char.get(this.str.charAt(this.i++));\n    }\n  }),\n  ForList: BiwaScheme.Class.create({\n    initialize: function(ls){\n      this.ls = ls;\n    },\n    has_next: function(){\n      return (this.ls instanceof BiwaScheme.Pair) &&\n             this.ls != BiwaScheme.nil;\n    },\n    next: function(){\n      var pair = this.ls;\n      this.ls = this.ls.cdr;\n      return pair;\n    }\n  }),\n  ForMulti: BiwaScheme.Class.create({\n    initialize: function(objs){\n      this.objs = objs;\n      this.size = objs.length;\n      this.iterators = _.map(objs, function(x){\n        return BiwaScheme.Iterator.of(x);\n      })\n    },\n    has_next: function(){\n      for(var i=0; i<this.size; i++)\n        if(!this.iterators[i].has_next())\n          return false;\n      \n      return true;\n    },\n    next: function(){\n      return _.map(this.iterators, function(ite){\n        return ite.next();\n      })\n    }\n  }),\n  of: function(obj){\n    switch(true){\n      case (obj instanceof Array):\n        return new this.ForArray(obj);\n      case (typeof(obj) == \"string\"):\n        return new this.ForString(obj);\n      case (obj instanceof BiwaScheme.Pair):\n      case (obj === BiwaScheme.nil):\n        return new this.ForList(obj);\n      default:\n        throw new BiwaScheme.Bug(\"Iterator.of: unknown class: \"+BiwaScheme.inspect(obj));\n    }\n  }\n}\n\n//\n// Call.foreach - shortcut for successive Calls\n//\n// Some library functions, such as for-each or map,\n// call a closure for each element. Call.foreach is \n// a utility to help defining such methods.\n//\n// Call.foreach takes a sequence and some callbacks.\n// Sequence is an Array, String, or list.\n//\n// Example:\n//   return Call.foreach(sequence, {\n//     // before each call\n//     call: function(elem){\n//       return new Call(proc, [elem]);\n//     },\n//     // after each call\n//     result: function(value, elem){\n//       ary.push(value);\n//       // you can return a value to terminate the loop\n//     },\n//     // after all the calls\n//     finish: function(){\n//       return ary;\n//     }\n//   });\n\nBiwaScheme.Call.default_callbacks = {\n  call: function(x){ return new BiwaScheme.Call(this.proc, [x]) },\n  result: function(){},\n  finish: function(){}\n}\nBiwaScheme.Call.foreach = function(obj, callbacks, is_multi){\n  is_multi || (is_multi = false);\n  _.each([\"call\", \"result\", \"finish\"], function(key){\n    if(!callbacks[key])\n      callbacks[key] = BiwaScheme.Call.default_callbacks[key];\n  })\n  \n  var iterator = null;\n  var x = null;\n\n  var loop = function(ar){\n    if(iterator){\n      var ret = callbacks[\"result\"](ar[0], x);\n      if(ret !== undefined) return ret;\n    }\n    else{ // first lap\n      if(is_multi)\n        iterator = new BiwaScheme.Iterator.ForMulti(obj);\n      else\n        iterator = BiwaScheme.Iterator.of(obj);\n    }\n\n    if(!iterator.has_next()){\n      return callbacks[\"finish\"]();\n    }\n    else{\n      x = iterator.next();\n      var result = callbacks[\"call\"](x);\n      result.after = loop;\n      return result;\n    }\n  }\n  return loop(null);\n}\nBiwaScheme.Call.multi_foreach = function(obj, callbacks){\n  return BiwaScheme.Call.foreach(obj, callbacks, true);\n}\n\n///\n/// Interpreter\n///\n\nBiwaScheme.Interpreter = BiwaScheme.Class.create({\n  // new BiwaScheme.Interpreter()\n  // new BiwaScheme.Interpreter(lastInterpreter)\n  // new BiwaScheme.Interpreter(errorHandler)\n  // new BiwaScheme.Interpreter(lastInterpreter, errorHandler)\n  initialize: function(){\n    var last_interpreter = null;\n    var on_error = null;\n    if (arguments.length == 2) {\n      last_interpreter = arguments[0];\n      on_error = arguments[1];\n    } else if (arguments.length == 1 && arguments[0] instanceof BiwaScheme.Interpreter) {\n      last_interpreter = arguments[0];\n    } else if (arguments.length == 1 && typeof(arguments[0]) == \"function\") {\n      on_error = arguments[0];\n    }\n\n    // Interpreter stack\n    this.stack = [];\n    // JS function to handle error\n    this.on_error = on_error || (last_interpreter ? last_interpreter.on_error : function(e){});\n    // JS function to handle result\n    this.after_evaluate = function(){};\n\n    // (Variables for stack trace)\n    // Name of the last variable read by refer-xx\n    this.last_refer = last_interpreter ? last_interpreter.last_refer : null;\n    // Call stack (array of last_refer)\n    this.call_stack = last_interpreter ? _.clone(last_interpreter.call_stack) : [];\n    // Counts number of tail calls (= how many times should we pop call_stack\n    // in op_return)\n    this.tco_counter = [];\n    // Maximum length of call_stack\n    // (Note: we should cap call_stack for inifinite loop with recursion)\n    this.max_trace_size = last_interpreter ? last_interpreter.max_trace_size : BiwaScheme.max_trace_size;\n  },\n\n  inspect: function(){\n    return [\n      \"#<Interpreter: stack size=>\",\n      this.stack.length, \" \",\n      \"after_evaluate=\",\n      BiwaScheme.inspect(this.after_evaluate),\n      \">\"\n    ].join(\"\");\n  },\n\n  // private\n  push: function(x, s){\n    this.stack[s] = x;\n    return s+1;\n  },\n\n  // private\n  //s: depth of stack to save\n  //ret: saved(copied) stack \n  save_stack: function(s){\n    var v = [];\n    for(var i=0; i<s; i++){\n      v[i] = this.stack[i];\n    }\n    return { stack: v, last_refer: this.last_refer, call_stack: _.clone(this.call_stack), tco_counter: _.clone(this.tco_counter) };\n  },\n\n  // private\n  //v: stack array to restore\n  //ret: lenght of restored stack\n  restore_stack: function(stuff){\n    v = stuff.stack;\n    var s = v.length;\n    for(var i=0; i<s; i++){\n      this.stack[i] = v[i];\n    }\n    this.last_refer = stuff.last_refer;\n    this.call_stack = _.clone(stuff.call_stack);\n    this.tco_counter = _.clone(stuff.tco_counter);\n    return s;\n  },\n\n  // private\n  //s: depth of stack to save\n  //n: number of args(for outer lambda) to remove (= 0 unless tail position)\n  //ret: closure array\n  continuation: function(s, n){\n    // note: implementation of this function for final version doesn't exist in 3imp.pdf..\n    var ss = this.push(n, s);\n    return this.closure([\"refer-local\", 0,\n                          [\"nuate\", this.save_stack(ss), \n                          [\"return\"]]], \n                        0,     //n (number of frees)\n                        null,  //s (stack position to get frees)\n                        -1);   // dotpos\n  },\n\n  // private\n  // shift stack \n  // n: number of items to skip (from stack top)\n  // m: number of items to shift\n  // s: stack pointer (= index of stack top + 1)\n  shift_args: function(n, m, s){\n    for(var i = n-1; i >= -1; i--){\n      this.index_set(s, i+m+1, this.index(s, i));\n    }\n    return s-m-1;\n  },\n\n  index: function(s, i){\n    return this.stack[s-i-2];\n  },\n\n  // private\n  index_set: function(s, i, v){\n    this.stack[s-i-2] = v;\n  },\n\n  // private\n  //ret: [body, stack[s-1], stack[s-2], .., stack[s-n], dotpos]\n  closure: function(body, n, s, dotpos){\n    var v = []; //(make-vector n+1+1)\n    v[0] = body;\n    for(var i=0; i<n; i++)\n      v[i+1] = this.index(s, i-1);\n    v[n+1] = dotpos;\n\n    v.closure_p = true;\n\n    return v;\n  },\n\n  // private\n  run_dump_hook: function(a, x, f, c, s) {\n    var dumper;\n    var state;\n\n\n    if (this.dumper) {\n      dumper = this.dumper;\n    }\n    else if (BiwaScheme.Interpreter.dumper) {\n      dumper = BiwaScheme.Interpreter.dumper;\n    }\n    else\n      return;\n\n    if (dumper) {\n      state = {\"a\":a,\n               \"f\":f,\n               \"c\":c,\n               \"s\":s,\n               \"x\":x,\n               \"stack\":this.stack};\n      dumper.dump(state);\n    }\n  },\n\n  // private\n  _execute: function(a, x, f, c, s){\n    var ret = null;\n    //Console.puts(\"executing \"+x[0]);\n    \n    while(true){ //x[0] != \"halt\"){\n\n      this.run_dump_hook(a, x, f, c, s);\n\n      switch(x[0]){\n      case \"halt\":\n        return a;\n      case \"refer-local\":\n        var n=x[1], x=x[2];\n        a = this.index(f, n);\n        this.last_refer = \"(anon)\";\n        break;\n      case \"refer-free\":\n        var n=x[1], x=x[2];\n        a = c[n+1];\n        this.last_refer = \"(anon)\";\n        break;\n      case \"refer-global\":\n        var sym=x[1], x=x[2];\n        if(BiwaScheme.TopEnv.hasOwnProperty(sym))\n          var val = BiwaScheme.TopEnv[sym];\n        else if(BiwaScheme.CoreEnv.hasOwnProperty(sym))\n          var val = BiwaScheme.CoreEnv[sym];\n        else\n          throw new BiwaScheme.Error(\"execute: unbound symbol: \"+BiwaScheme.inspect(sym));\n\n        a = val;\n        this.last_refer = sym || \"(anon)\";\n        break;\n      case \"indirect\":\n        var x=x[1];\n        a = a[0]; //unboxing\n        break;\n      case \"constant\":\n        var obj=x[1], x=x[2];\n        a = obj;\n        this.last_refer = \"(anon)\";\n        break;\n      case \"close\":\n        var ox=x;\n        var n=ox[1], body=ox[2], x=ox[3], dotpos=ox[4];\n        a = this.closure(body, n, s, dotpos);\n        s -= n;\n        break;\n      case \"box\":\n        var n=x[1], x=x[2];\n        this.index_set(s, n, [this.index(s, n)]); //boxing\n        break;\n      case \"test\":\n        var thenc=x[1], elsec=x[2];\n        x = ((a!==false) ? thenc : elsec);\n        break;\n      case \"assign-global\":\n        var name=x[1], x=x[2];\n        if(!BiwaScheme.TopEnv.hasOwnProperty(name) &&\n           !BiwaScheme.CoreEnv.hasOwnProperty(name))\n          throw new BiwaScheme.Error(\"global variable '\"+name+\"' is not defined\");\n        \n        BiwaScheme.TopEnv[name] = a;\n        a = BiwaScheme.undef;\n        break;\n      case \"assign-local\":\n        var n=x[1], x=x[2];\n        var box = this.index(f, n);\n        box[0] = a;\n        a = BiwaScheme.undef;\n        break;\n      case \"assign-free\":\n        var n=x[1], x=x[2];\n        var box = c[n+1];\n        box[0] = a;\n        a = BiwaScheme.undef;\n        break;\n      case \"conti\":\n        var n=x[1], x=x[2];\n        a = this.continuation(s, n);\n        break;\n      case \"nuate\":\n        var stack=x[1], x=x[2];\n        s = this.restore_stack(stack);\n        break;\n      case \"frame\":\n        var ret = x[2];\n        x = x[1];\n        s = this.push(ret, this.push(f, this.push(c, s)));\n        this.tco_counter[this.tco_counter.length] = 0;\n        break;\n      case \"argument\":\n        var x=x[1];\n        s = this.push(a, s);\n        break;\n      case \"shift\":\n        var n=x[1], x=x[2];\n\n        // the number of arguments in the last call\n        var n_args = this.index(s, n);  \n\n        s = this.shift_args(n, n_args, s);\n        break;\n      case \"tco_hinted_apply\": // just like a regular apply, except we need to trace the # of TCO calls so we can generate a stacktrace\n        this.tco_counter[this.tco_counter.length - 1]++;\n        x = [\"apply\"].concat(_.rest(x));\n        break;\n      case \"apply\": //extended: n_args as second argument\n        var func = a; //, n_args = x[1];\n\n        // Save stack trace\n        this.call_stack.push(this.last_refer);\n        if (this.call_stack.length > this.max_trace_size) {\n          // Remove old memory if it grows too long\n          // Note: this simple way may be inconvenient (e.g. no trace\n          // will be shown when an error occurred right after returning\n          // from a large function)\n          this.call_stack.shift();\n        }\n\n        // the number of arguments in the last call is\n        // pushed to the stack.\n        var n_args = this.index(s, -1);\n        if(func instanceof Array){ //closure\n          a = func;\n          x = func[0];\n\n          // The position of dot in the parameter list.\n          var dotpos = func[func.length-1];\n\n          if (dotpos >= 0) {\n            // The dot is found\n            // ----------------\n            // => Process the &rest args: packing the rest args into a list.\n            var ls = BiwaScheme.nil;\n            for (var i=n_args; --i>=dotpos; ) {\n              ls = new BiwaScheme.Pair(this.index(s, i), ls);\n            }\n            if (dotpos >= n_args) {\n              // No rest argument is passed to this closure.\n              // However, the closure expects the caller passes the rest argument.\n              // In such case this VM prepares an empty list as the rest argument.\n              // --------------------------------------------------------------\n              // => We extend the stack to put the empty list.\n              for(var i = -1; i < n_args; i++){\n                this.index_set(s, i-1, this.index(s, i));\n              }\n              s++;\n              // => Update the number of arguments\n              this.index_set(s, -1, this.index(s, -1) + 1);  \n            }\n            this.index_set(s, dotpos, ls);\n          }\n          f = s;\n          c = a;\n        }\n        else if(func instanceof Function){ // Apply JavaScript function\n          // load arguments from stack\n          var args = [];\n          for(var i=0; i<n_args; i++) \n            args.push(this.index(s, i));\n\n          // invoke the function\n          var result = func(args, this);\n\n          if(result instanceof BiwaScheme.Pause){\n            // it requested the interpreter to suspend\n            var pause = result;\n            pause.set_state(this, [\"return\"], f, c, s);\n            pause.ready();\n            return pause;\n          }\n          else if(result instanceof BiwaScheme.Call){\n            // it requested the interpreter to call a scheme closure\n\n            //   [frame,\n            //     [constant... (args)\n            //     [constant, proc\n            //     [apply]]]]\n            //   [frame,\n            //     [constant, after\n            //     [apply 1]]]]\n            //   x\n            var call_after = [\"frame\",\n                               [\"argument\",\n                               [\"constant\", 1,\n                               [\"argument\",\n                               [\"constant\", result.after,\n                               [\"apply\"]]]]],\n                             [\"return\"]];\n            var call_proc = [\"constant\", result.args.length,\n                            [\"argument\",\n                            [\"constant\", result.proc, \n                            [\"apply\", result.args.length]]]];\n            var push_args = _.inject(result.args, function(opc, arg){\n              // (foo 1 2) => first push 2, then 1\n              //   [constant 2 ... [constant 1 ... ]\n              return [\"constant\", arg, \n                     [\"argument\",\n                     opc]];\n            }, call_proc);\n            x = [\"frame\",\n                  push_args,\n                call_after]\n          }\n          else{\n            // the JavaScript function returned a normal value\n            a = result;\n            x = [\"return\"];\n          }\n        }\n        else{\n          // unknown function type\n          throw new BiwaScheme.Error(BiwaScheme.inspect(func) + \" is not a function\");\n        }\n        break;\n      case \"return\":\n        // Pop stack frame\n        var n=this.index(s, -1);\n        var ss=s-n;\n        x = this.index(ss, 0),\n        f = this.index(ss, 1),\n        c = this.index(ss, 2),\n        s = ss-3-1;\n\n        // Pop stack trace (> 1 times if tail calls are done)\n        var n_pops = 1 + this.tco_counter[this.tco_counter.length - 1];\n        this.call_stack.splice(-n_pops);\n        this.tco_counter.pop();\n        break;\n      default:\n        throw new BiwaScheme.Bug(\"unknown opecode type: \"+x[0]);\n      }\n    }\n\n//      if(ret === null)\n//        throw new BiwaScheme.Bug(\"interpreter exited in unusual way\");\n//      else\n//        return ret;\n    return a\n  },\n\n  // Compile and evaluate Scheme program\n  evaluate: function(str, after_evaluate){\n    this.call_stack = [];\n    this.parser = new BiwaScheme.Parser(str);\n    this.compiler = new BiwaScheme.Compiler();\n    if(after_evaluate) \n      this.after_evaluate = after_evaluate;\n\n    if(BiwaScheme.Debug) Console.puts(\"executing: \" + str);\n     \n    this.is_top = true;\n    this.file_stack = [];\n\n    try{\n      return this.resume(false);\n    }\n    catch(e){\n      e.message = e.message + \" [\" + this.call_stack.join(\", \") + \"]\";\n      return this.on_error(e);\n    }\n  },\n\n  // Resume evaluation\n  // (internally used from Interpreter#execute and Pause#resume)\n  resume: function(is_resume, a, x, f, c, s){\n    var ret = BiwaScheme.undef;\n\n    for(;;){\n      if(is_resume){\n        ret = this._execute(a, x, f, c, s);\n        is_resume = false;\n      }\n      else{\n        if(!this.parser) break; // adhoc: when Pause is used via invoke_closure\n        var expr = this.parser.getObject();\n        if(expr === BiwaScheme.Parser.EOS) break;\n\n        // expand\n        expr = BiwaScheme.Interpreter.expand(expr);\n\n        // compile\n        var opc = this.compiler.run(expr);\n        //if(BiwaScheme.Debug) Console.p(opc);\n\n        // execute\n        ret = this._execute(expr, opc, 0, [], 0);\n      }\n\n      if(ret instanceof BiwaScheme.Pause){ //suspend evaluation\n        return ret;\n      }\n    }\n\n    // finished executing all forms\n    this.after_evaluate(ret);\n    return ret;\n  },\n\n  // Invoke a scheme closure\n  invoke_closure: function(closure, args){\n    args || (args = []);\n    var n_args  = args.length;\n\n    var x = [\"constant\", n_args, [\"argument\", [\"constant\", closure, [\"apply\"]]]]\n    for(var i=0; i<n_args; i++)\n      x = [\"constant\", args[i], [\"argument\", x]]\n\n    return this._execute(closure, [\"frame\", x, [\"halt\"]], 0, closure, 0);\n  },\n\n  // only compiling (for debug use only)\n  compile: function(str){\n    var obj = BiwaScheme.Interpreter.read(str);\n    var opc = BiwaScheme.Compiler.compile(obj);\n    return opc;\n  }\n});\n\n// Take a string and returns an expression.\nBiwaScheme.Interpreter.read = function(str){\n  var parser = new BiwaScheme.Parser(str);\n  var r      = parser.getObject();\n  return (r == BiwaScheme.Parser.EOS)? BiwaScheme.eof: r;\n};\n\n// Expand macro calls in a expression recursively.\n//\n// x - expression\n// flag - used internally. do not specify this\n//\n// @throws {BiwaScheme.Error} when x has syntax error\nBiwaScheme.Interpreter.expand = function(x, flag/*optional*/){\n  var expand = BiwaScheme.Interpreter.expand;\n  flag || (flag = {})\n  var ret = null;\n\n  if(x instanceof BiwaScheme.Pair){\n    switch(x.car){\n    case BiwaScheme.Sym(\"define\"):\n      var left = x.cdr.car, exp = x.cdr.cdr;\n      ret = new BiwaScheme.Pair(BiwaScheme.Sym(\"define\"),\n              new BiwaScheme.Pair(left, expand(exp, flag)));\n      break;\n    case BiwaScheme.Sym(\"begin\"):\n      ret = new BiwaScheme.Pair(BiwaScheme.Sym(\"begin\"), expand(x.cdr, flag));\n      break;\n    case BiwaScheme.Sym(\"quote\"):\n      ret = x;\n      break;\n    case BiwaScheme.Sym(\"lambda\"):\n      var vars=x.cdr.car, body=x.cdr.cdr;\n      ret = new BiwaScheme.Pair(BiwaScheme.Sym(\"lambda\"),\n              new BiwaScheme.Pair(vars, expand(body, flag)));\n      break;\n    case BiwaScheme.Sym(\"if\"):\n      var testc=x.second(), thenc=x.third(), elsec=x.fourth();\n      ret = BiwaScheme.List(BiwaScheme.Sym(\"if\"),\n                            expand(testc, flag),\n                            expand(thenc, flag),\n                            expand(elsec, flag));\n      break;\n    case BiwaScheme.Sym(\"set!\"):\n      var v=x.second(), x=x.third();\n      ret = BiwaScheme.List(BiwaScheme.Sym(\"set!\"), v, expand(x, flag));\n      break;\n    case BiwaScheme.Sym(\"call-with-current-continuation\"): \n    case BiwaScheme.Sym(\"call/cc\"): \n      var x=x.second();\n      ret = BiwaScheme.List(BiwaScheme.Sym(\"call/cc\"), expand(x, flag));\n      break;\n    default: //apply\n      var transformer = null;\n      if(BiwaScheme.isSymbol(x.car)){\n        if(BiwaScheme.TopEnv[x.car.name] instanceof BiwaScheme.Syntax)\n          transformer = BiwaScheme.TopEnv[x.car.name];\n        else if(BiwaScheme.CoreEnv[x.car.name] instanceof BiwaScheme.Syntax)\n          transformer = BiwaScheme.CoreEnv[x.car.name];\n      }\n\n      if(transformer){\n        flag[\"modified\"] = true;\n        ret = transformer.transform(x);\n\n//            // Debug\n//            var before = BiwaScheme.to_write(x);\n//            var after = BiwaScheme.to_write(ret);\n//            if(before != after){\n//              console.log(\"before: \" + before)\n//              console.log(\"expand: \" + after)\n//            }\n\n        var fl;\n        for(;;){\n          ret = expand(ret, fl={});\n          if(!fl[\"modified\"]) \n            break;\n        }\n      }\n      else{\n        var expanded_car = expand(x.car, flag);\n        var expanded_cdr;\n        if(!(x.cdr instanceof BiwaScheme.Pair) && (x.cdr !== BiwaScheme.nil)){\n          throw new Error(\"proper list required for function application \"+\n                          \"or macro use: \"+BiwaScheme.to_write(x));\n        }\n        expanded_cdr = BiwaScheme.array_to_list(\n                         _.map(x.cdr.to_array(),\n                               function(item){ return expand(item, flag); }));\n        ret = new BiwaScheme.Pair(expanded_car, expanded_cdr);\n      }\n    }\n  }\n  else{\n    ret = x;\n  }\n  return ret;\n};\n//\n// R7RS Promise (lazy library)\n//\nBiwaScheme.Promise = BiwaScheme.Class.create({\n  initialize : function(done, thunk_or_value){\n    this.box = [done, thunk_or_value];\n  },\n\n  // Return true when this promise is already calculated\n  is_done: function() {\n    return this.box[0];\n  },\n\n  // Return calculated value of this promise\n  value: function() {\n    if (!this.is_done()) {\n      throw new BiwaScheme.Bug(\"this promise is not calculated yet\");\n    }\n    return this.box[1];\n  },\n\n  thunk: function() {\n    if (this.is_done()) {\n      throw new BiwaScheme.Bug(\"this promise does not know the thunk\");\n    }\n    return this.box[1];\n  },\n\n  update_with: function(new_promise) {\n    this.box[0] = new_promise.box[0];\n    this.box[1] = new_promise.box[1];\n    new_promise.box = this.box;\n  }\n});\nBiwaScheme.isPromise = function(obj) {\n  return (obj instanceof BiwaScheme.Promise);\n};\n\n// Create fresh promise\nBiwaScheme.Promise.fresh = function(thunk) {\n  return new BiwaScheme.Promise(false, thunk);\n};\n// Create calculated promise\nBiwaScheme.Promise.done = function(value) {\n  return new BiwaScheme.Promise(true, value);\n};\n///\n/// infra.js - Basis for library functions\n///\n\n//\n// define_*func - define library functions\n//\nBiwaScheme.check_arity = function(len, min, max){\n  var fname = arguments.callee.caller\n                ? arguments.callee.caller.fname\n                : \"(?)\";\n  if(len < min){\n    if(max && max == min)\n      throw new BiwaScheme.Error(fname+\": wrong number of arguments (expected: \"+min+\" got: \"+len+\")\");\n    else\n      throw new BiwaScheme.Error(fname+\": too few arguments (at least: \"+min+\" got: \"+len+\")\");\n  }\n  else if(max && max < len)\n    throw new BiwaScheme.Error(fname+\": too many arguments (at most: \"+max+\" got: \"+len+\")\");\n}\nBiwaScheme.define_libfunc = function(fname, min, max, func){\n  var f = function(ar, intp){\n    BiwaScheme.check_arity(ar.length, min, max);\n    return func(ar, intp);\n  };\n\n  func[\"fname\"] = fname; // for assert_*\n  f[\"fname\"]    = fname; // for check_arity\n  f[\"inspect\"] = function(){ return this.fname; }\n  BiwaScheme.CoreEnv[fname] = f;\n}\nBiwaScheme.alias_libfunc = function(fname, aliases) {\n  if (BiwaScheme.CoreEnv[fname]) {\n    if (_.isArray(aliases)) {\n      _.map(aliases, function(a) { BiwaScheme.alias_libfunc(fname, a); });\n    } else if (_.isString(aliases)) {\n      BiwaScheme.CoreEnv[aliases] = BiwaScheme.CoreEnv[fname];\n    } else {\n      console.error(\"[BUG] bad alias for library function \" +\n                    \"`\" + fname + \"': \" + aliases.toString());\n    }\n  } else {\n    console.error(\"[BUG] library function \" +\n                  \"`\" + fname + \"'\" +\n                  \" does not exist, so can't alias it.\");\n  }\n};\nBiwaScheme.define_syntax = function(sname, func) {\n  var s = new BiwaScheme.Syntax(sname, func);\n  BiwaScheme.CoreEnv[sname] = s;\n}\nBiwaScheme.define_scmfunc = function(fname, min, max, str){\n  (new BiwaScheme.Interpreter).evaluate(\"(define \"+fname+\" \"+str+\"\\n)\");\n}\n\n//  define_scmfunc(\"map+\", 2, null, \n//    \"(lambda (proc ls) (if (null? ls) ls (cons (proc (car ls)) (map proc (cdr ls)))))\");\n\n//\n// assertions - type checks\n//\nBiwaScheme.make_assert = function(check){\n  return function(/*args*/){\n    var fname = arguments.callee.caller\n                  ? arguments.callee.caller.fname\n                  : \"\";\n    check.apply(this, [fname].concat(_.toArray(arguments)));\n  }\n}\nBiwaScheme.make_simple_assert = function(type, test, _fname){\n  return BiwaScheme.make_assert(function(fname, obj, opt){\n    if(_fname) fname = _fname;\n    option = opt ? (\"(\"+opt+\")\") : \"\"\n    if(!test(obj)){\n      throw new BiwaScheme.Error(fname + option + \": \" +\n                                 type + \" required, but got \" +\n                                 BiwaScheme.to_write(obj));\n    }\n  })\n}\n\nBiwaScheme.assert_number = BiwaScheme.make_simple_assert(\"number\", function(obj){\n  return typeof(obj) == 'number' || (obj instanceof BiwaScheme.Complex);\n});\n\nBiwaScheme.assert_integer = BiwaScheme.make_simple_assert(\"integer\", function(obj){\n  return typeof(obj) == 'number' && (obj % 1 == 0)\n});\n\nBiwaScheme.assert_real = BiwaScheme.make_simple_assert(\"real number\", function(obj){\n  return typeof(obj) == 'number';\n});\n\nBiwaScheme.assert_between = BiwaScheme.make_assert(function(fname, obj, from, to){\n  if( typeof(obj) != 'number' || obj != Math.round(obj) ){\n    throw new BiwaScheme.Error(fname + \": \" +\n                               \"number required, but got \" +\n                               BiwaScheme.to_write(obj));\n  }\n\n  if( obj < from || to < obj ){\n    throw new BiwaScheme.Error(fname + \": \" +\n                               \"number must be between \" +\n                               from + \" and \" + to + \", but got \" +\n                               BiwaScheme.to_write(obj));\n  }\n});\n\nBiwaScheme.assert_string = BiwaScheme.make_simple_assert(\"string\", _.isString);\n\nBiwaScheme.assert_char = BiwaScheme.make_simple_assert(\"character\", BiwaScheme.isChar);\nBiwaScheme.assert_symbol = BiwaScheme.make_simple_assert(\"symbol\", BiwaScheme.isSymbol);\nBiwaScheme.assert_port = BiwaScheme.make_simple_assert(\"port\", BiwaScheme.isPort);\nBiwaScheme.assert_pair = BiwaScheme.make_simple_assert(\"pair\", BiwaScheme.isPair);\nBiwaScheme.assert_list = BiwaScheme.make_simple_assert(\"list\", BiwaScheme.isList);\nBiwaScheme.assert_vector = BiwaScheme.make_simple_assert(\"vector\", BiwaScheme.isVector);\n\nBiwaScheme.assert_hashtable = BiwaScheme.make_simple_assert(\"hashtable\",\n                                          BiwaScheme.isHashtable);\nBiwaScheme.assert_mutable_hashtable = BiwaScheme.make_simple_assert(\"mutable hashtable\",\n                                            BiwaScheme.isMutableHashtable);\n\nBiwaScheme.assert_record = BiwaScheme.make_simple_assert(\"record\",\n                                          BiwaScheme.isRecord);\nBiwaScheme.assert_record_td = BiwaScheme.make_simple_assert(\"record type descriptor\",\n                                          BiwaScheme.isRecordTD);\nBiwaScheme.assert_record_cd = BiwaScheme.make_simple_assert(\"record constructor descriptor\",\n                                          BiwaScheme.isRecordCD);\nBiwaScheme.assert_enum_set = BiwaScheme.make_simple_assert(\"enum_set\",\n                                          BiwaScheme.isEnumSet);\nBiwaScheme.assert_promise = BiwaScheme.make_simple_assert(\"promise\",\n                                          BiwaScheme.isPromise);\n\nBiwaScheme.assert_function = BiwaScheme.make_simple_assert(\"JavaScript function\",\n                                         _.isFunction);\nBiwaScheme.assert_closure = BiwaScheme.make_simple_assert(\"scheme function\",\n                                        BiwaScheme.isClosure);\nBiwaScheme.assert_procedure = BiwaScheme.make_simple_assert(\"scheme/js function\", function(obj){\n  return BiwaScheme.isClosure(obj) || _.isFunction(obj);\n});\n\nBiwaScheme.assert_date = BiwaScheme.make_simple_assert(\"date\", function(obj){\n  // FIXME: this is not accurate (about cross-frame issue)\n  // https://prototype.lighthouseapp.com/projects/8886/tickets/443\n  return obj instanceof Date;\n});\n\n//var assert_instance_of = BiwaScheme.make_assert(function(fname, type, obj, klass){\n//  if(!(obj instanceof klass)){\n//    throw new BiwaScheme.Error(fname + \": \" +\n//                               type + \" required, but got \" +\n//                               BiwaScheme.to_write(obj));\n//  }\n//});\n\nBiwaScheme.assert = BiwaScheme.make_assert(function(fname, success, message, _fname){\n  if(!success){\n    throw new BiwaScheme.Error((_fname || fname)+\": \"+message);\n  }\n});\n\n//\n// deprecation\n//\n\n// Show deprecation warnig\n// @param {string} title - feature to be deprecated\n// @param {string} ver - when it will be removed (eg. \"1.0\")\n// @param {string} alt - alternatives\nBiwaScheme.deprecate = function(title, ver, alt){\n  if(BiwaScheme.suppress_deprecation_warning) return;\n\n  var msg = title+\" is deprecated and will be removed in BiwaScheme \"+ver+ \". \"+\n            \"Please use \"+alt+\" instead\";\n  console.warn(msg); \n};\n\n//\n// utils\n//\n\n// Parses a fractional notation in the format: <num>/<denom> (e.g. 3/7, -9/4),\n// where <num> is a valid integer notation, and <denom> is a valid notation\n// for a positive integer.\n//\n// Returns a float if the notation is valid, otherwise false.\n//\n// @param {string} rep - the string representation of the fraction\n// @return {float|false}\nBiwaScheme.parse_fraction = function(rep) {\n  BiwaScheme.assert_string(rep);\n\n  var frac_parts = rep.split('/');\n\n  if (frac_parts.length !== 2)\n    return false;\n\n  var num_rep = frac_parts[0];\n  var denom_rep = frac_parts[1];\n\n  var num = BiwaScheme.parse_integer(num_rep, 10);\n  var denom = BiwaScheme.parse_integer(denom_rep, 10);\n\n  if (num === false || denom === false)\n    return false;\n\n  if (denom <= 0)\n    return false;\n\n  return num / denom;\n};\n\n// Given a string notation of an integer, and the radix, validates the\n// notation: returns true if the notation is valid, otherwise false.\n//\n// @param {string} rep - the string representation of the integer\n// @param {integer} rdx - the radix, where 2 <= rdx <= 36\n// @return {boolean}\nBiwaScheme.is_valid_integer_notation = function(rep, rdx) {\n  BiwaScheme.assert_string(rep);\n  BiwaScheme.assert_integer(rdx);\n\n  if (rdx < 2 || rdx > 36)\n    return false;\n\n  var rdx_symbols = '0123456789abcdefghijklmnopqrstuvwxyz';\n\n  var valid_symbols = rdx_symbols.slice(0, rdx);\n  var sym_regex = new RegExp('^[+-]?' + '[' + valid_symbols + ']+$', 'ig');\n\n  return sym_regex.test(rep);\n};\n\n// Parse an integer. If the integer does not have a valid representation, or\n// produces NaN, - false is returned. If the radix is not within [2..36]\n// range, false is returned as well.\n//\n// @param {string} rep - the string representation of the integer\n// @param {integer} rdx - the radix, where 2 <= rdx <= 36\n// @return {integer|false}\nBiwaScheme.parse_integer = function(rep, rdx) {\n  BiwaScheme.assert_string(rep);\n  BiwaScheme.assert_integer(rdx);\n\n  if (rdx < 2 || rdx > 36)\n    return false;\n\n  if (!BiwaScheme.is_valid_integer_notation(rep, rdx))\n    return false;\n\n  var res = parseInt(rep, rdx);\n\n  if (Number.isNaN(res))\n    return false;\n\n  return res;\n};\n\n// Given a string notation of a floating-point number in the standard or\n// scientific notation, returns true if the notation valid, otherwise false.\n//\n// For example:\n// \"1\"      -> true\n// \"1.\"     -> true\n// \"1.23\"   -> true\n// \"1e4\"    -> true\n// \"1E4\"    -> true\n// \"1E4.34\" -> false\n// \"e34\"    -> false\n//\n// @param {string} rep - the string representation of the float.\n// @return {boolean}\nBiwaScheme.is_valid_float_notation = function(rep) {\n  BiwaScheme.assert_string(rep);\n\n  var sci_regex = /^[+-]?[0-9]+[.]?[0-9]*e[+-]?[0-9]+$/i;\n  var fp_regex  = /(^[+-]?[0-9]*[.][0-9]+$)|(^[+-]?[0-9]+[.][0-9]*$)/;\n\n  if (sci_regex.test(rep) || fp_regex.test(rep))\n    return true;\n\n  return BiwaScheme.is_valid_integer_notation(rep, 10);\n};\n\n// Parse a floating-point number. If the floating-point number does not have a\n// valid representation, or produces -Infinity, +Infinity or NaN, - false is\n// returned.\n//\n// @param {string} rep - the string representation of the floating-point value\n// @return {float|false}\nBiwaScheme.parse_float = function(rep) {\n  BiwaScheme.assert_string(rep);\n\n  if (!BiwaScheme.is_valid_float_notation(rep))\n    return false;\n\n  var res = new Number(rep).valueOf();\n\n  if (Number.isNaN(res))\n    return false;\n\n  if (!Number.isFinite(res))\n    return false;\n\n  return res;\n};\n//\n// R6RS Base library\n//\n\nif( typeof(BiwaScheme)!='object' ) BiwaScheme={}; with(BiwaScheme) {\n  ///\n  /// R6RS Base library\n  ///\n\n  //\n  //        11.4  Expressions\n  //\n  //            11.4.1  Quotation\n  //(quote)\n  //            11.4.2  Procedures\n  //(lambda)\n  //            11.4.3  Conditionaar\n  //(if)\n  //            11.4.4  Assignments\n  //(set!)\n  //            11.4.5  Derived conditionaar\n\n  define_syntax(\"cond\", function(x){\n    var clauses = x.cdr;\n    if(!(clauses instanceof Pair) || clauses === nil){\n      throw new Error(\"malformed cond: cond needs list but got \" +\n                      to_write_ss(clauses));\n    }\n    // TODO: assert that clauses is a proper list\n\n    var ret = null;\n    _.each(clauses.to_array().reverse(), function(clause){\n      if(!(clause instanceof Pair)){\n        throw new Error(\"bad clause in cond: \" + to_write_ss(clause));\n      }\n\n      if(clause.car === Sym(\"else\")){\n        if(ret !== null){\n          throw new Error(\"'else' clause of cond followed by more clauses: \" +\n                          to_write_ss(clauses));\n        }\n        else if(clause.cdr === nil){\n          // pattern A: (else)\n          //  -> #f            ; not specified in R6RS...?\n          ret = false;\n        }\n        else if(clause.cdr.cdr === nil){\n          // pattern B: (else expr)\n          //  -> expr\n          ret = clause.cdr.car;\n        }\n        else{\n          // pattern C: (else expr ...)\n          //  -> (begin expr ...)\n          ret = new Pair(Sym(\"begin\"), clause.cdr);\n        }\n      }\n      else{\n        var test = clause.car;\n        if(clause.cdr === nil){\n          // pattern 1: (test)\n          //  -> (or test ret)\n          ret = List(Sym(\"or\"), test, ret);\n        }\n        else if (clause.cdr.cdr === nil){\n          // pattern 2: (test expr)\n          //  -> (if test expr ret)\n          ret = List(Sym(\"if\"), test, clause.cdr.car, ret);\n        }\n        else if(clause.cdr.car === Sym(\"=>\")){\n          // pattern 3: (test => expr)\n          //  -> (let ((#<gensym1> test))\n          //       (if test (expr #<gensym1>) ret))\n          var test = clause.car, expr = clause.cdr.cdr.car;\n          var tmp_sym = BiwaScheme.gensym();\n\n          ret = List(Sym(\"let\"),\n                     List( List(tmp_sym, test) ),\n                     List(Sym(\"if\"), test, List(expr, tmp_sym), ret));\n        }\n        else{\n          // pattern 4: (test expr ...)\n          //  -> (if test (begin expr ...) ret)\n          ret = List(Sym(\"if\"), test,\n                     new Pair(Sym(\"begin\"), clause.cdr),\n                     ret);\n        }\n      }\n    });\n    return ret;\n  });\n\n  define_syntax(\"case\", function(x){\n    var tmp_sym = BiwaScheme.gensym();\n\n    if(x.cdr === nil){\n      throw new Error(\"case: at least one clause is required\");\n    }\n    else if(!(x.cdr instanceof Pair)){\n      throw new Error(\"case: proper list is required\");\n    }\n    else{\n      // (case key clauses ....)\n      //  -> (let ((#<gensym1> key))\n      var key = x.cdr.car;\n      var clauses = x.cdr.cdr;\n\n      var ret = undefined;\n      _.each(clauses.to_array().reverse(), function(clause){\n        if(clause.car === Sym(\"else\")){\n          // pattern 0: (else expr ...)\n          //  -> (begin expr ...)\n          if(ret === undefined){\n            ret = new Pair(Sym(\"begin\"), clause.cdr);\n          }\n          else{\n            throw new Error(\"case: 'else' clause followed by more clauses: \" +\n                            to_write_ss(clauses));\n          }\n        }\n        else{\n          // pattern 1: ((datum ...) expr ...)\n          //  -> (if (or (eqv? key (quote d1)) ...) (begin expr ...) ret)\n          ret = List(\n            Sym(\"if\"),\n            new Pair(Sym(\"or\"), array_to_list(_.map(clause.car.to_array(), function(d){\n                return List(Sym(\"eqv?\"),\n                            tmp_sym,\n                            List(Sym(\"quote\"), d));\n            }))),\n            new Pair(Sym(\"begin\"), clause.cdr),\n            ret\n          );\n        }\n      });\n      return new Pair(Sym(\"let1\"),\n               new Pair(tmp_sym,\n                 new Pair(key,\n                   new Pair(ret, nil))));\n    }\n  });\n\n  define_syntax(\"and\", function(x){\n    // (and a b c) => (if a (if b c #f) #f)\n    //todo: check improper list\n    if(x.cdr == nil) return true;\n\n    var objs = x.cdr.to_array();\n    var i = objs.length-1;\n    var t = objs[i];\n    for(i=i-1; i>=0; i--)\n      t = List(Sym(\"if\"), objs[i], t, false);\n\n    return t;\n  })\n\n  define_syntax(\"or\", function(x){\n    // (or a b c) => (if a a (if b b (if c c #f)))\n    //todo: check improper list\n\n    var objs = x.cdr.to_array()\n    var f = false;\n    for(var i=objs.length-1; i>=0; i--)\n      f = List(Sym(\"if\"), objs[i], objs[i], f);\n\n    return f;\n  })\n\n  //            11.4.6  Binding constructs\n  define_syntax(\"let\", function(x){\n    //(let ((a 1) (b 2)) (print a) (+ a b))\n    //=> ((lambda (a b) (print a) (+ a b)) 1 2)\n    var name = null;\n    if (x.cdr.car instanceof Symbol) {\n      name = x.cdr.car;\n      x = x.cdr;\n    }\n    var binds = x.cdr.car, body = x.cdr.cdr;\n\n    if((!(binds instanceof Pair)) && binds != BiwaScheme.nil){\n      throw new Error(\"let: need a pair for bindings: got \"+to_write(binds));\n    }\n\n    var vars = nil, vals = nil;\n    for(var p=binds; p instanceof Pair; p=p.cdr){\n      if(!(p.car instanceof Pair)){\n        throw new Error(\"let: need a pair for bindings: got \"+to_write(p.car));\n      }\n      vars = new Pair(p.car.car, vars);\n      vals = new Pair(p.car.cdr.car, vals);\n    }\n\n    var lambda = null;\n    if (name) {\n      // (let loop ((a 1) (b 2)) body ..)\n      //=> (letrec ((loop (lambda (a b) body ..))) (loop 1 2))\n      vars = array_to_list(vars.to_array().reverse());\n      vals = array_to_list(vals.to_array().reverse());\n\n      var body_lambda = new Pair(Sym(\"lambda\"), new Pair(vars, body));\n      var init_call = new Pair(name, vals);\n\n      lambda = List(Sym(\"letrec\"),\n                    new Pair(List(name, body_lambda), nil),\n                    init_call);\n    }\n    else {\n      lambda = new Pair(new Pair(Sym(\"lambda\"),\n                                 new Pair(vars, body)),\n                        vals);\n    }\n    return lambda;\n  })\n\n  define_syntax(\"let*\", function(x){\n    //(let* ((a 1) (b a)) (print a) (+ a b))\n    //-> (let ((a 1))\n    //     (let ((b a)) (print a) (+ a b)))\n    var binds = x.cdr.car, body = x.cdr.cdr;\n\n    if(!(binds instanceof Pair))\n      throw new Error(\"let*: need a pair for bindings: got \"+to_write(binds));\n\n    var ret = null;\n    _.each(binds.to_array().reverse(), function(bind){\n      ret = new Pair(Sym(\"let\"),\n               new Pair(new Pair(bind, nil),\n                 ret == null ? body : new Pair(ret, nil)));\n    })\n    return ret;\n  })\n\n  var expand_letrec_star = function(x){\n    var binds = x.cdr.car, body = x.cdr.cdr;\n\n    if(!(binds instanceof Pair))\n      throw new Error(\"letrec*: need a pair for bindings: got \"+to_write(binds));\n\n    var ret = body;\n    _.each(binds.to_array().reverse(), function(bind){\n      ret = new Pair(new Pair(Sym(\"set!\"), bind),\n              ret);\n    })\n    var letbody = nil;\n    _.each(binds.to_array().reverse(), function(bind){\n      letbody = new Pair(new Pair(bind.car,\n                           new Pair(BiwaScheme.undef, nil)),\n                  letbody);\n    })\n    return new Pair(Sym(\"let\"),\n             new Pair(letbody,\n               ret));\n  }\n  define_syntax(\"letrec\", expand_letrec_star);\n  define_syntax(\"letrec*\", expand_letrec_star);\n\n  define_syntax(\"let-values\", function(x) {\n    // (let-values (((a b) (values 1 2))\n    //               ((c d . e) (values 3 4 a)))\n    //              (print a b c d e))\n    // =>\n    // (let ((#<gensym1> (lambda () (values 1 2)))\n    //       (#<gensym2> (lambda () (values 3 4 a))))\n    //   (let*-values (((a b) #<gensym1>)\n    //                 ((c d . e) #<gensym2>))\n    //                 (print a b c d e)))\n      var mv_bindings = x.cdr.car;\n      var body = x.cdr.cdr;\n      var ret = null;\n\n      var let_bindings = nil;\n      var let_star_values_bindings = nil;\n      _.each(mv_bindings.to_array().reverse(), function (item) {\n\t  var init = item.cdr.car;\n\t  var tmpsym = BiwaScheme.gensym()\n\t  var binding = new Pair(tmpsym,\n\t\t\t\t new Pair(\n\t\t\t\t\t  new Pair(Sym(\"lambda\"), new Pair(nil,\n\t\t\t\t\t\t\t\t\t   new Pair(init, nil))),\n\t\t\t\t\t  nil));\n\t  let_bindings = new Pair(binding, let_bindings);\n\n\t  var formals = item.car;\n\t  let_star_values_bindings = new Pair(new Pair (formals, new Pair(new Pair(tmpsym, nil), nil)),\n\t\t\t\t\t      let_star_values_bindings);\n      });\n\n      var let_star_values = new Pair(Sym(\"let*-values\"),\n\t\t\t\t     new Pair(let_star_values_bindings,\n\t\t\t\t\t      body));\n      ret = new Pair(Sym(\"let\"),\n\t\t     new Pair(let_bindings,\n\t\t\t      new Pair (let_star_values, nil)));\n      return ret;\n\n  });\n\n  //let*-values\n  define_syntax(\"let*-values\", function(x){\n    // (let*-values (((a b) (values 1 2))\n    //               ((c d . e) (values 3 4 a)))\n    //   (print a b c d e))\n    // -> (call-with-values\n    //      (lambda () (values 1 2))\n    //      (lambda (a b)\n    //        (call-with-values\n    //          (lambda () (values 3 4 a))\n    //          (lambda (c d . e)\n    //            (print a b c d e)))))\n    var mv_bindings = x.cdr.car;\n    var body = x.cdr.cdr;\n\n    var ret = null;\n\n    _.each(mv_bindings.to_array().reverse(), function(item){\n      var formals = item.car, init = item.cdr.car;\n      ret = new Pair(Sym(\"call-with-values\"),\n              new Pair(new Pair(Sym(\"lambda\"),\n                         new Pair(nil,\n                           new Pair(init, nil))),\n                new Pair(new Pair(Sym(\"lambda\"),\n                           new Pair(formals,\n                             (ret == null ? body\n                                          : new Pair(ret, nil)))), nil)));\n    });\n    return ret;\n  });\n  //            11.4.7  Sequencing\n  //(begin)\n\n  //\n  //        11.5  Equivalence predicates\n  //\n  define_libfunc(\"eqv?\", 2, 2, function(ar){\n    return BiwaScheme.eqv(ar[0], ar[1]);\n  })\n  define_libfunc(\"eq?\", 2, 2, function(ar){\n    return BiwaScheme.eq(ar[0], ar[1]);\n  })\n  define_libfunc(\"equal?\", 2, 2, function(ar){\n    return BiwaScheme.equal(ar[0], ar[1]);\n  })\n\n  //\n  //        11.6  Procedure predicate\n  //\n  //\"procedure?\", 1, 1\n  define_libfunc(\"procedure?\", 1, 1, function(ar){\n    return ((ar[0] instanceof Array) && (ar[0].closure_p === true)\n\t    || (typeof ar[0] == \"function\"));\n  })\n\n  //\n  //        11.7  Arithmetic\n  //\n\n  //            11.7.1  Propagation of exactness and inexactness\n  //            11.7.2  Representability of infinities and NaNs\n  //            11.7.3  Semantics of common operations\n  //                11.7.3.1  Integer division\n  //                11.7.3.2  Transcendental functions\n  //(no functions are introduced by above sections)\n\n  //\n  //            11.7.4  Numerical operations\n  //\n\n  //                11.7.4.1  Numerical type predicates\n  define_libfunc(\"number?\", 1, 1, function(ar){\n    return BiwaScheme.isNumber(ar[0]);\n  });\n  define_libfunc(\"complex?\", 1, 1, function(ar){\n    return BiwaScheme.isComplex(ar[0]);\n  });\n  define_libfunc(\"real?\", 1, 1, function(ar){\n    return BiwaScheme.isReal(ar[0]);\n  });\n  define_libfunc(\"rational?\", 1, 1, function(ar){\n    return BiwaScheme.isRational(ar[0]);\n  });\n  define_libfunc(\"integer?\", 1, 1, function(ar){\n    return BiwaScheme.isInteger(ar[0]);\n  });\n\n//(real-valued? obj)    procedure\n//(rational-valued? obj)    procedure\n//(integer-valued? obj)    procedure\n//\n//(exact? z)    procedure\n//(inexact? z)    procedure\n\n  //                11.7.4.2  Generic conversions\n  //\n//(inexact z)    procedure\n//(exact z)    procedure\n//\n  //                11.7.4.3  Arithmetic operations\n\n  //inf & nan: ok (for this section)\n  define_libfunc(\"=\", 2, null, function(ar){\n    var v = ar[0];\n    assert_number(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      assert_number(ar[i]);\n      if(real_part(ar[i]) != real_part(v)) return false;\n      if(imag_part(ar[i]) != imag_part(v)) return false;\n    }\n    return true;\n  });\n  define_libfunc(\"<\", 2, null, function(ar){\n    assert_number(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      assert_number(ar[i]);\n      if(!(ar[i-1] < ar[i])) return false;\n    }\n    return true;\n  });\n  define_libfunc(\">\", 2, null, function(ar){\n    assert_number(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      assert_number(ar[i]);\n      if(!(ar[i-1] > ar[i])) return false;\n    }\n    return true;\n  });\n  define_libfunc(\"<=\", 2, null, function(ar){\n    assert_number(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      assert_number(ar[i]);\n      if(!(ar[i-1] <= ar[i])) return false;\n    }\n    return true;\n  });\n  define_libfunc(\">=\", 2, null, function(ar){\n    assert_number(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      assert_number(ar[i]);\n      if(!(ar[i-1] >= ar[i])) return false;\n    }\n    return true;\n  });\n\n  define_libfunc(\"zero?\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return ar[0] === 0;\n  });\n  define_libfunc(\"positive?\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return (ar[0] > 0);\n  });\n  define_libfunc(\"negative?\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return (ar[0] < 0);\n  });\n  define_libfunc(\"odd?\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return (ar[0] % 2 == 1) || (ar[0] % 2 == -1);\n  })\n  define_libfunc(\"even?\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return ar[0] % 2 == 0;\n  })\n  define_libfunc(\"finite?\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return (ar[0] != Infinity) && (ar[0] != -Infinity) && !isNaN(ar[0]);\n  })\n  define_libfunc(\"infinite?\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return (ar[0] == Infinity) || (ar[0] == -Infinity);\n  })\n  define_libfunc(\"nan?\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return isNaN(ar[0]);\n  })\n  define_libfunc(\"max\", 2, null, function(ar){\n    for(var i=0; i<ar.length; i++)\n      assert_number(ar[i]);\n\n    return Math.max.apply(null, ar)\n  });\n  define_libfunc(\"min\", 2, null, function(ar){\n    for(var i=0; i<ar.length; i++)\n      assert_number(ar[i]);\n\n    return Math.min.apply(null, ar);\n  });\n\n  var complex_or_real = function(real,imag){\n    if(imag === 0) return real;\n    return new Complex(real,imag);\n  }\n  var polar_or_real = function(magnitude, angle){\n      if(angle === 0) return magnitude;\n      return Complex.from_polar(magnitude, angle);\n  }\n  define_libfunc(\"+\", 0,null, function(ar){\n    var real = 0;\n    var imag = 0;\n    for(var i=0; i<ar.length; i++){\n      assert_number(ar[i]);\n      real+=real_part(ar[i]);\n      imag+=imag_part(ar[i]);\n    }\n    return complex_or_real(real,imag);\n  });\n  var the_magnitude = function(n) {\n      if(n instanceof Complex) return n.magnitude();\n      return n;\n  }\n  var the_angle = function(n) {\n      if(n instanceof Complex) return n.angle();\n      return 0;\n  }\n  define_libfunc(\"*\", 0,null, function(ar){\n    var magnitude = 1;\n    var angle = 0;\n    for(var i=0; i<ar.length; i++){\n      assert_number(ar[i]);\n      magnitude*=the_magnitude(ar[i]);\n      angle+=the_angle(ar[i]);\n    }\n    return polar_or_real(magnitude, angle);\n  });\n  define_libfunc(\"-\", 1,null, function(ar){\n    var len = ar.length;\n    assert_number(ar[0]);\n\n    if(len == 1) {\n      if(ar[0] instanceof Complex) return new Complex(-real_part(ar[0]),-imag_part(ar[0]));\n      return -ar[0];\n    }\n    else{\n      var real = real_part(ar[0]);\n      var imag = imag_part(ar[0]);\n      for(var i=1; i<len; i++){\n        assert_number(ar[i]);\n        real-=real_part(ar[i]);\n        imag-=imag_part(ar[i]);\n      }\n      return complex_or_real(real,imag);\n    }\n  });\n  //for r6rs specification, (/ 0 0) or (/ 3 0) raises '&assertion exception'\n  define_libfunc(\"/\", 1,null, function(ar){\n    var len = ar.length;\n    assert_number(ar[0]);\n\n    if(len == 1){\n      if (ar[0] instanceof Complex) return Complex.from_polar(1/the_magnitude(ar[0]), -the_angle(ar[0]));\n      return 1/ar[0];\n    }\n    else{\n      var magnitude = the_magnitude(ar[0]);\n      var angle = the_angle(ar[0]);\n      for(var i=1; i<len; i++){\n        assert_number(ar[i]);\n        magnitude/=the_magnitude(ar[i]);\n        angle-=the_angle(ar[i]);\n      }\n      return polar_or_real(magnitude, angle);\n    }\n  });\n\n  define_libfunc(\"abs\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Math.abs(ar[0]);\n  });\n\n  var div = function(n, m){\n    return Math.floor(n / m);\n  }\n  var mod = function(n, m){\n    return n - Math.floor(n / m) * m;\n  }\n  var div0 = function(n, m){\n    return (n > 0) ? Math.floor(n / m) : Math.ceil(n / m);\n  }\n  var mod0 = function(n, m){\n    return (n > 0) ? n - Math.floor(n / m) * m\n                   : n - Math.ceil(n / m) * m;\n  }\n  define_libfunc(\"div0-and-mod0\", 2, 2, function(ar){\n    assert_number(ar[0]);\n    assert_number(ar[1]);\n    return new Values([div(ar[0], ar[1]), mod(ar[0], ar[1])]);\n  })\n  define_libfunc(\"div\", 2, 2, function(ar){\n    assert_number(ar[0]);\n    assert_number(ar[1]);\n    return div(ar[0], ar[1]);\n  })\n  define_libfunc(\"mod\", 2, 2, function(ar){\n    assert_number(ar[0]);\n    assert_number(ar[1]);\n    return mod(ar[0], ar[1]);\n  })\n  define_libfunc(\"div0-and-mod0\", 2, 2, function(ar){\n    assert_number(ar[0]);\n    assert_number(ar[1]);\n    return new Values([div0(ar[0], ar[1]), mod0(ar[0], ar[1])]);\n  })\n  define_libfunc(\"div0\", 2, 2, function(ar){\n    assert_number(ar[0]);\n    assert_number(ar[1]);\n    return div0(ar[0], ar[1]);\n  })\n  define_libfunc(\"mod0\", 2, 2, function(ar){\n    assert_number(ar[0]);\n    assert_number(ar[1]);\n    return mod0(ar[0], ar[1]);\n  })\n\n//(gcd n1 ...)    procedure\n//(lcm n1 ...)    procedure\n\n  define_libfunc(\"numerator\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    if(ar[0] instanceof Rational)\n      return ar[0].numerator;\n    else\n      throw new Bug(\"todo\");\n  })\n  define_libfunc(\"denominator\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    if(ar[0] instanceof Rational)\n      return ar[0].denominator;\n    else\n      throw new Bug(\"todo\");\n  })\n  define_libfunc(\"floor\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Math.floor(ar[0]);\n  })\n  define_libfunc(\"ceiling\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Math.ceil(ar[0]);\n  })\n  define_libfunc(\"truncate\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return (ar[0] < 0) ? Math.ceil(ar[0]) : Math.floor(ar[0]);\n  })\n  define_libfunc(\"round\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Math.round(ar[0]);\n  })\n\n//(rationalize x1 x2)    procedure\n\n  define_libfunc(\"exp\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Math.exp(ar[0]);\n  })\n  define_libfunc(\"log\", 1, 2, function(ar){\n    var num = ar[0], base = ar[1];\n    assert_number(num);\n\n    if(base){ // log b num == log e num / log e b\n      assert_number(base);\n      return Math.log(num) / Math.log(base)\n    }\n    else\n      return Math.log(num);\n  })\n  define_libfunc(\"sin\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Math.sin(ar[0]);\n  })\n  define_libfunc(\"cos\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Math.cos(ar[0]);\n  })\n  define_libfunc(\"tan\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Math.tan(ar[0]);\n  })\n  define_libfunc(\"asin\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Math.asin(ar[0]);\n  })\n  define_libfunc(\"acos\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Math.acos(ar[0]);\n  })\n  define_libfunc(\"atan\", 1, 2, function(ar){\n    assert_number(ar[0]);\n    if(ar.length == 2){\n      assert_number(ar[1]);\n      return Math.atan2(ar[0], ar[1]);\n    }\n    else\n      return Math.atan(ar[0]);\n  })\n  define_libfunc(\"sqrt\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Math.sqrt(ar[0]);\n  })\n  define_libfunc(\"exact-integer-sqrt\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    var sqrt_f = Math.sqrt(ar[0]);\n    var sqrt_i = sqrt_f - (sqrt_f % 1);\n    var rest   = ar[0] - sqrt_i * sqrt_i;\n\n    return new Values([sqrt_i, rest]);\n  })\n  define_libfunc(\"expt\", 2, 2, function(ar){\n    assert_number(ar[0]);\n    assert_number(ar[1]);\n    return Math.pow(ar[0], ar[1]);\n  })\n  define_libfunc(\"make-rectangular\", 2, 2, function(ar){\n    assert_number(ar[0]);\n    assert_number(ar[1]);\n    return new Complex(ar[0], ar[1]);\n  })\n  define_libfunc(\"make-polar\", 2, 2, function(ar){\n    assert_number(ar[0]);\n    assert_number(ar[1]);\n    return Complex.from_polar(ar[0], ar[1]);\n  })\n  var real_part = function(n) {\n    return Complex.assure(n).real;\n  }\n  var imag_part = function(n) {\n    return Complex.assure(n).imag;\n  }\n  define_libfunc(\"real-part\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return real_part(ar[0]);\n  })\n  define_libfunc(\"imag-part\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Complex.assure(ar[0]).imag;\n  })\n  define_libfunc(\"magnitude\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Complex.assure(ar[0]).magnitude();\n  })\n  define_libfunc(\"angle\", 1, 1, function(ar){\n    assert_number(ar[0]);\n    return Complex.assure(ar[0]).angle();\n  })\n\n  //\n  //                11.7.4.4  Numerical Input and Output\n  //\n  define_libfunc(\"number->string\", 1, 3, function(ar){\n    var z = ar[0], radix = ar[1], precision = ar[2];\n    if(precision)\n      throw new Bug(\"number->string: precision is not yet implemented\");\n\n    radix = radix || 10;  //TODO: check radix is 2, 8, 10, or 16.\n    return z.toString(radix);\n  })\n  define_libfunc(\"string->number\", 1, 3, function(ar){\n    var s = ar[0];\n\n    if (s === '+inf.0')\n      return Infinity;\n\n    if (s === '-inf.0')\n      return -Infinity;\n\n    if (s === '+nan.0')\n      return NaN;\n\n    var radix = ar[1];\n    \n    var int_res = BiwaScheme.parse_integer(\n      s, radix === 0 ? 0 : radix || 10\n    );\n\n    if (int_res !== false)\n      return int_res;\n\n    if (radix !== undefined && radix !== 10)\n      return false;\n\n    var fp_res = BiwaScheme.parse_float(s);\n\n    if (fp_res !== false)\n      return fp_res;\n\n    var frac_res = BiwaScheme.parse_fraction(s);\n\n    if (frac_res !== false)\n      return frac_res;\n\n    return false;\n  })\n\n  //\n  //        11.8  Booleans\n  //\n\n  define_libfunc(\"not\", 1, 1, function(ar){\n    return (ar[0] === false) ? true : false;\n  });\n  define_libfunc(\"boolean?\", 1, 1, function(ar){\n    return (ar[0] === false || ar[0] === true) ? true : false;\n  });\n  define_libfunc(\"boolean=?\", 2, null, function(ar){\n    var len = ar.length;\n    for(var i=1; i<len; i++){\n      if(ar[i] != ar[0]) return false;\n    }\n    return true;\n  });\n\n  //        11.9  Pairs and lists\n\n  define_libfunc(\"pair?\", 1, 1, function(ar){\n    return (ar[0] instanceof Pair) ? true : false;\n  });\n  define_libfunc(\"cons\", 2, 2, function(ar){\n    return new Pair(ar[0], ar[1]);\n  });\n  define_libfunc(\"car\", 1, 1, function(ar){\n    //should raise &assertion for '()...\n    if(!(ar[0] instanceof Pair)) throw new Error(\"Attempt to apply car on \" + ar[0]);\n    return ar[0].car;\n  });\n  define_libfunc(\"cdr\", 1, 1, function(ar){\n    //should raise &assertion for '()...\n    if(!(ar[0] instanceof Pair)) throw new Error(\"Attempt to apply cdr on \" + ar[0]);\n    return ar[0].cdr;\n  });\n  define_libfunc(\"set-car!\", 2, 2, function(ar){\n    if(!(ar[0] instanceof Pair)) throw new Error(\"Attempt to apply set-car! on \" + ar[0]);\n    ar[0].car = ar[1];\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"set-cdr!\", 2, 2, function(ar){\n    if(!(ar[0] instanceof Pair)) throw new Error(\"Attempt to apply set-cdr! on \" + ar[0]);\n    ar[0].cdr = ar[1];\n    return BiwaScheme.undef;\n  });\n\n  // cadr, caddr, cadddr, etc.\n  (function(){\n    // To traverse into pair and raise error\n    var get = function(funcname, spec, obj){\n      var ret = obj;\n      _.each(spec, function(is_cdr){\n        if(ret instanceof Pair){\n          ret = (is_cdr ? ret.cdr : ret.car);\n        }\n        else{\n          throw new Error(funcname+\": attempt to get \"+(is_cdr ? \"cdr\" : \"car\")+\" of \"+ret);\n        }\n      });\n      return ret;\n    };\n    define_libfunc(\"caar\", 1, 1, function(ar){ return get(\"caar\", [0, 0], ar[0]); });\n    define_libfunc(\"cadr\", 1, 1, function(ar){ return get(\"cadr\", [1, 0], ar[0]); });\n    define_libfunc(\"cdar\", 1, 1, function(ar){ return get(\"cadr\", [0, 1], ar[0]); });\n    define_libfunc(\"cddr\", 1, 1, function(ar){ return get(\"cadr\", [1, 1], ar[0]); });\n\n    define_libfunc(\"caaar\", 1, 1, function(ar){ return get(\"caaar\", [0, 0, 0], ar[0]); });\n    define_libfunc(\"caadr\", 1, 1, function(ar){ return get(\"caadr\", [1, 0, 0], ar[0]); });\n    define_libfunc(\"cadar\", 1, 1, function(ar){ return get(\"cadar\", [0, 1, 0], ar[0]); });\n    define_libfunc(\"caddr\", 1, 1, function(ar){ return get(\"caddr\", [1, 1, 0], ar[0]); });\n    define_libfunc(\"cdaar\", 1, 1, function(ar){ return get(\"cdaar\", [0, 0, 1], ar[0]); });\n    define_libfunc(\"cdadr\", 1, 1, function(ar){ return get(\"cdadr\", [1, 0, 1], ar[0]); });\n    define_libfunc(\"cddar\", 1, 1, function(ar){ return get(\"cddar\", [0, 1, 1], ar[0]); });\n    define_libfunc(\"cdddr\", 1, 1, function(ar){ return get(\"cdddr\", [1, 1, 1], ar[0]); });\n\n    define_libfunc(\"caaaar\", 1, 1, function(ar){ return get(\"caaaar\", [0, 0, 0, 0], ar[0]); });\n    define_libfunc(\"caaadr\", 1, 1, function(ar){ return get(\"caaadr\", [1, 0, 0, 0], ar[0]); });\n    define_libfunc(\"caadar\", 1, 1, function(ar){ return get(\"caadar\", [0, 1, 0, 0], ar[0]); });\n    define_libfunc(\"caaddr\", 1, 1, function(ar){ return get(\"caaddr\", [1, 1, 0, 0], ar[0]); });\n    define_libfunc(\"cadaar\", 1, 1, function(ar){ return get(\"cadaar\", [0, 0, 1, 0], ar[0]); });\n    define_libfunc(\"cadadr\", 1, 1, function(ar){ return get(\"cadadr\", [1, 0, 1, 0], ar[0]); });\n    define_libfunc(\"caddar\", 1, 1, function(ar){ return get(\"caddar\", [0, 1, 1, 0], ar[0]); });\n    define_libfunc(\"cadddr\", 1, 1, function(ar){ return get(\"cadddr\", [1, 1, 1, 0], ar[0]); });\n    define_libfunc(\"cdaaar\", 1, 1, function(ar){ return get(\"cdaaar\", [0, 0, 0, 1], ar[0]); });\n    define_libfunc(\"cdaadr\", 1, 1, function(ar){ return get(\"cdaadr\", [1, 0, 0, 1], ar[0]); });\n    define_libfunc(\"cdadar\", 1, 1, function(ar){ return get(\"cdadar\", [0, 1, 0, 1], ar[0]); });\n    define_libfunc(\"cdaddr\", 1, 1, function(ar){ return get(\"cdaddr\", [1, 1, 0, 1], ar[0]); });\n    define_libfunc(\"cddaar\", 1, 1, function(ar){ return get(\"cddaar\", [0, 0, 1, 1], ar[0]); });\n    define_libfunc(\"cddadr\", 1, 1, function(ar){ return get(\"cddadr\", [1, 0, 1, 1], ar[0]); });\n    define_libfunc(\"cdddar\", 1, 1, function(ar){ return get(\"cdddar\", [0, 1, 1, 1], ar[0]); });\n    define_libfunc(\"cddddr\", 1, 1, function(ar){ return get(\"cddddr\", [1, 1, 1, 1], ar[0]); });\n  })();\n\n  define_libfunc(\"null?\", 1, 1, function(ar){\n    return (ar[0] === nil);\n  });\n  define_libfunc(\"list?\", 1, 1, function(ar){\n    return isList(ar[0]);\n  });\n  define_libfunc(\"list\", 0, null, function(ar){\n    var l = nil;\n    for(var i=ar.length-1; i>=0; i--)\n      l = new Pair(ar[i], l);\n    return l;\n  });\n  define_libfunc(\"length\", 1, 1, function(ar){\n    assert_list(ar[0]);\n    var n = 0;\n    for(var o=ar[0]; o!=nil; o=o.cdr)\n      n++;\n    return n;\n  });\n  define_libfunc(\"append\", 1, null, function(ar){\n    var k = ar.length;\n    var ret = ar[--k];\n    while(k--){\n      _.each(ar[k].to_array().reverse(), function(item){\n        ret = new Pair(item, ret);\n      });\n    }\n    return ret;\n  });\n  define_libfunc(\"reverse\", 1, 1, function(ar){\n    // (reverse '()) => '()\n    if(ar[0] == nil)\n      return nil;\n    assert_pair(ar[0]);\n\n    var l = nil;\n    for(var o=ar[0]; o!=nil; o=o.cdr)\n      l = new Pair(o.car, l);\n    return l;\n  });\n  define_libfunc(\"list-tail\", 2, 2, function(ar){\n    assert_pair(ar[0]);\n    assert_integer(ar[1]);\n    if(ar[1] < 0)\n      throw new Error(\"list-tail: index out of range (\"+ar[1]+\")\");\n\n    var o = ar[0];\n    for(var i=0; i<ar[1]; i++){\n      if(!(o instanceof Pair)) throw new Error(\"list-tail: the list is shorter than \" + ar[1]);\n      o = o.cdr;\n    }\n    return o;\n  });\n  define_libfunc(\"list-ref\", 2, 2, function(ar){\n    assert_pair(ar[0]);\n    assert_integer(ar[1]);\n    if(ar[1] < 0)\n      throw new Error(\"list-tail: index out of range (\"+ar[1]+\")\");\n\n    var o = ar[0];\n    for(var i=0; i<ar[1]; i++){\n      if(!(o instanceof Pair)) throw new Error(\"list-ref: the list is shorter than \" + ar[1]);\n      o = o.cdr;\n    }\n    return o.car;\n  });\n  define_libfunc(\"map\", 2, null, function(ar){\n    var proc = ar.shift(), lists = ar;\n    _.each(lists, assert_list);\n\n    var a = [];\n    return Call.multi_foreach(lists, {\n      // Called for each element\n      // input: the element (or the elements, if more than one list is given)\n      // output: a Call request of proc and args\n      call: function(xs){\n        return new Call(proc, _.map(xs, function(x){ return x.car }));\n      },\n\n      // Called when each Call request is finished\n      // input: the result of Call request,\n      //   the element(s) of the Call request (which is not used here)\n      // output: `undefined' to continue,\n      //   some value to terminate (the value will be the result)\n      result: function(res){ a.push(res); },\n\n      // Called when reached to the end of the list(s)\n      // input: none\n      // output: the resultant value\n      finish: function(){ return array_to_list(a); }\n    })\n  })\n  define_libfunc(\"for-each\", 2, null, function(ar){\n    var proc = ar.shift(), lists = ar;\n    _.each(lists, assert_list);\n\n    return Call.multi_foreach(lists, {\n      call: function(xs){\n        return new Call(proc, _.map(xs, function(x){ return x.car }));\n      },\n      finish: function(){ return BiwaScheme.undef; }\n    })\n  })\n\n  //        11.10  Symbols\n\n  define_libfunc(\"symbol?\", 1, 1, function(ar){\n    return (ar[0] instanceof Symbol) ? true : false;\n  });\n  define_libfunc(\"symbol->string\", 1, 1, function(ar){\n    assert_symbol(ar[0]);\n    return ar[0].name;\n  });\n  define_libfunc(\"symbol=?\", 2, null, function(ar){\n    assert_symbol(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      assert_symbol(ar[i]);\n      if(ar[i] != ar[0]) return false;\n    }\n    return true;\n  });\n  define_libfunc(\"string->symbol\", 1, 1, function(ar){\n    assert_string(ar[0]);\n    return Sym(ar[0]);\n  });\n\n  //\n  //        11.11  Characters\n  //\n  define_libfunc('char?', 1, 1, function(ar){\n    return (ar[0] instanceof Char);\n  });\n  define_libfunc('char->integer', 1, 1, function(ar){\n    assert_char(ar[0]);\n    return ar[0].value.charCodeAt(0);\n  })\n  define_libfunc('integer->char', 1, 1, function(ar){\n    assert_integer(ar[0]);\n    return Char.get(String.fromCharCode(ar[0]));\n  })\n\n  var make_char_compare_func = function(test){\n    return function(ar){\n      assert_char(ar[0]);\n      for(var i=1; i<ar.length; i++){\n        assert_char(ar[i]);\n        if(!test(ar[i-1].value, ar[i].value))\n          return false;\n      }\n      return true;\n    }\n  }\n  define_libfunc('char=?', 2, null,\n    make_char_compare_func(function(a, b){ return a == b }))\n  define_libfunc('char<?', 2, null,\n    make_char_compare_func(function(a, b){ return a < b }))\n  define_libfunc('char>?', 2, null,\n    make_char_compare_func(function(a, b){ return a > b }))\n  define_libfunc('char<=?', 2, null,\n    make_char_compare_func(function(a, b){ return a <= b }))\n  define_libfunc('char>=?', 2, null,\n    make_char_compare_func(function(a, b){ return a >= b }))\n\n  //\n  //        11.12  Strings\n  //\n  define_libfunc(\"string?\", 1, 1, function(ar){\n    return (typeof(ar[0]) == \"string\");\n  })\n  define_libfunc(\"make-string\", 1, 2, function(ar){\n    assert_integer(ar[0]);\n    var c = \" \";\n    if(ar[1]){\n      assert_char(ar[1]);\n      c = ar[1].value;\n    }\n    var out = \"\";\n    _.times(ar[0], function() { out += c; });\n    return out;\n  })\n  define_libfunc(\"string\", 0, null, function(ar){\n    if(ar.length == 0) return \"\";\n    for(var i=0; i<ar.length; i++)\n      assert_char(ar[i]);\n    return _.map(ar, function(c){ return c.value }).join(\"\");\n  })\n  define_libfunc(\"string-length\", 1, 1, function(ar){\n    assert_string(ar[0]);\n    return ar[0].length;\n  })\n  define_libfunc(\"string-ref\", 2, 2, function(ar){\n    assert_string(ar[0]);\n    assert_between(ar[1], 0, ar[0].length-1);\n    return Char.get(ar[0].charAt([ar[1]]));\n  })\n  define_libfunc(\"string=?\", 2, null, function(ar){\n    assert_string(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      assert_string(ar[i]);\n      if(ar[0] != ar[i]) return false;\n    }\n    return true;\n  })\n  define_libfunc(\"string<?\", 2, null, function(ar){\n    assert_string(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      assert_string(ar[i]);\n      if(!(ar[i-1] < ar[i])) return false;\n    }\n    return true;\n  })\n  define_libfunc(\"string>?\", 2, null, function(ar){\n    assert_string(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      assert_string(ar[i]);\n      if(!(ar[i-1] > ar[i])) return false;\n    }\n    return true;\n  })\n  define_libfunc(\"string<=?\", 2, null, function(ar){\n    assert_string(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      assert_string(ar[i]);\n      if(!(ar[i-1] <= ar[i])) return false;\n    }\n    return true;\n  })\n  define_libfunc(\"string>=?\", 2, null, function(ar){\n    assert_string(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      assert_string(ar[i]);\n      if(!(ar[i-1] >= ar[i])) return false;\n    }\n    return true;\n  })\n\n  define_libfunc(\"substring\", 3, 3, function(ar){\n    assert_string(ar[0]);\n    assert_integer(ar[1]);\n    assert_integer(ar[2]);\n\n    if(ar[1] < 0) throw new Error(\"substring: start too small: \"+ar[1]);\n    if(ar[2] < 0) throw new Error(\"substring: end too small: \"+ar[2]);\n    if(ar[0].length+1 <= ar[1]) throw new Error(\"substring: start too big: \"+ar[1]);\n    if(ar[0].length+1 <= ar[2]) throw new Error(\"substring: end too big: \"+ar[2]);\n    if(!(ar[1] <= ar[2])) throw new Error(\"substring: not start <= end: \"+ar[1]+\", \"+ar[2]);\n\n    return ar[0].substring(ar[1], ar[2]);\n  })\n\n  define_libfunc(\"string-append\", 0, null, function(ar){\n    for(var i=0; i<ar.length; i++)\n      assert_string(ar[i]);\n\n    return ar.join(\"\");\n  })\n  define_libfunc(\"string->list\", 1, 1, function(ar){\n    assert_string(ar[0]);\n    return array_to_list(_.map(ar[0].split(\"\"), function(s){ return Char.get(s[0]); }));\n  })\n  define_libfunc(\"list->string\", 1, 1, function(ar){\n    assert_list(ar[0]);\n    return _.map(ar[0].to_array(), function(c){ return c.value; }).join(\"\");\n  })\n  define_libfunc(\"string-for-each\", 2, null, function(ar){\n    var proc = ar.shift(), strs = ar;\n    _.each(strs, assert_string);\n\n    return Call.multi_foreach(strs, {\n      call: function(chars){ return new Call(proc, chars); },\n      finish: function(){ return BiwaScheme.undef; }\n    })\n  })\n  define_libfunc(\"string-copy\", 1, 1, function(ar){\n    // note: this is useless, because javascript strings are immutable\n    assert_string(ar[0]);\n    return ar[0];\n  })\n\n\n  //\n  //        11.13  Vectors\n  //\n  define_libfunc(\"vector?\", 1, 1, function(ar){\n    return (ar[0] instanceof Array) && (ar[0].closure_p !== true)\n  })\n  define_libfunc(\"make-vector\", 1, 2, function(ar){\n    assert_integer(ar[0]);\n    var vec = new Array(ar[0]);\n\n    if(ar.length == 2){\n      for(var i=0; i<ar[0]; i++)\n        vec[i] = ar[1];\n    }\n    return vec;\n  })\n  define_libfunc(\"vector\", 0, null, function(ar){\n    return ar;\n  })\n  define_libfunc(\"vector-length\", 1, 1, function(ar){\n    assert_vector(ar[0]);\n    return ar[0].length;\n  })\n  define_libfunc(\"vector-ref\", 2, 2, function(ar){\n    assert_vector(ar[0]);\n    assert_integer(ar[1]);\n    assert_between(ar[1], 0, ar[0].length-1);\n\n    return ar[0][ar[1]];\n  })\n  define_libfunc(\"vector-set!\", 3, 3, function(ar){\n    assert_vector(ar[0]);\n    assert_integer(ar[1]);\n\n    ar[0][ar[1]] = ar[2];\n    return BiwaScheme.undef;\n  })\n  define_libfunc(\"vector->list\", 1, 1, function(ar){\n    assert_vector(ar[0]);\n    return array_to_list(ar[0]);\n  })\n  define_libfunc(\"list->vector\", 1, 1, function(ar){\n    assert_list(ar[0]);\n    return ar[0].to_array();\n  })\n  define_libfunc(\"vector-fill!\", 2, 2, function(ar){\n    assert_vector(ar[0]);\n    var vec = ar[0], obj = ar[1];\n\n    for(var i=0; i<vec.length; i++)\n      vec[i] = obj;\n    return vec;\n  })\n  define_libfunc(\"vector-map\", 2, null, function(ar){\n    var proc = ar.shift(), vecs = ar;\n    _.each(vecs, assert_vector);\n\n    var a = [];\n    return Call.multi_foreach(vecs, {\n      call: function(objs){ return new Call(proc, objs); },\n      result: function(res){ a.push(res); },\n      finish: function(){ return a; }\n    })\n  })\n  define_libfunc(\"vector-for-each\", 2, null, function(ar){\n    var proc = ar.shift(), vecs = ar;\n    _.each(vecs, assert_vector);\n\n    return Call.multi_foreach(vecs, {\n      call: function(objs){ return new Call(proc, objs); },\n      finish: function(){ return BiwaScheme.undef; }\n    })\n  })\n\n  //\n  //        11.14  Errors and violations\n  //\n//(error who message irritant1 ...)    procedure\n//(assertion-violation who message irritant1 ...)    procedure\n//(assert <expression>)    syntax\n\n  //\n  //        11.15  Control features\n  //\n  define_libfunc(\"apply\", 2, null, function(ar){\n    var proc = ar.shift(), rest_args = ar.pop(), args = ar;\n    args = args.concat(rest_args.to_array());\n\n    return new Call(proc, args);\n  })\n  define_syntax(\"call-with-current-continuation\", function(x){\n    return new Pair(Sym(\"call/cc\"),\n             x.cdr);\n  })\n  define_libfunc(\"values\", 0, null, function(ar){\n    if (ar.length == 1) // eg. (values 3)\n      return ar[0];\n    else\n      return new Values(ar);\n  })\n  define_libfunc(\"call-with-values\", 2, 2, function(ar){\n    var producer = ar[0], consumer = ar[1];\n    assert_procedure(producer);\n    assert_procedure(consumer);\n    return new Call(producer, [], function(ar){\n      var result = ar[0];\n      if(result instanceof Values){\n        return new Call(consumer, result.content);\n      }\n      else{\n        // eg. (call-with-values (lambda () 3)\n        //                       (lambda (x) x))\n        return new Call(consumer, [result]);\n      }\n    })\n  })\n\n  //\n  //dynamic-wind\n\n  //        11.16  Iteration\n  //named let\n\n  //        11.17  Quasiquotation\n  // `() is expanded to `cons` and `append`.\n  // `#() is expanded to `vector` and `vector-append`.\n  var expand_qq = function(f, lv){\n    if(f instanceof Symbol || f === nil){\n      return List(Sym(\"quote\"), f);\n    }\n    else if(f instanceof Pair){\n      var car = f.car;\n      if(car instanceof Pair && car.car === Sym(\"unquote-splicing\")){\n        if(lv == 1)\n          return List(Sym(\"append\"),\n                      f.car.cdr.car,\n                      expand_qq(f.cdr, lv));\n        else\n          return List(Sym(\"cons\"),\n                      List(Sym(\"list\"),\n                           List(Sym(\"quote\"), Sym(\"unquote-splicing\")),\n                           expand_qq(f.car.cdr.car, lv-1)),\n                      expand_qq(f.cdr, lv));\n      }\n      else if(car === Sym(\"unquote\")){\n        if(lv == 1)\n          return f.cdr.car;\n        else\n          return List(Sym(\"list\"),\n                      List(Sym(\"quote\"), Sym(\"unquote\")),\n                      expand_qq(f.cdr.car, lv-1));\n      }\n      else if(car === Sym(\"quasiquote\"))\n        return List(Sym(\"list\"),\n                    List(Sym(\"quote\"), Sym(\"quasiquote\")),\n                    expand_qq(f.cdr.car, lv+1));\n      else\n        return List(Sym(\"cons\"),\n                    expand_qq(f.car, lv),\n                    expand_qq(f.cdr, lv));\n    }\n    else if(f instanceof Array){\n      var vecs = [[]];\n      for(var i=0; i<f.length; i++){\n        if(f[i] instanceof Pair && f[i].car === Sym(\"unquote-splicing\")) {\n          if (lv == 1) {\n            var item = List(Sym(\"list->vector\"), f[i].cdr.car);\n            item[\"splicing\"] = true;\n            vecs.push(item);\n            vecs.push([]);\n          }\n          else {\n            var item = List(Sym(\"cons\"),\n                         List(Sym(\"list\"),\n                              List(Sym(\"quote\"), Sym(\"unquote-splicing\")),\n                              expand_qq(f[i].car.cdr.car, lv-1)),\n                         expand_qq(f[i].cdr, lv));\n            _.last(vecs).push(item);\n          }\n        }\n        else {\n          // Expand other things as the same as if they are in a list quasiquote\n          _.last(vecs).push(expand_qq(f[i], lv));\n        }\n      }\n\n      var vectors = vecs.map(function(vec){\n        if (vec[\"splicing\"]) {\n          return vec;\n        }\n        else {\n          return Cons(Sym(\"vector\"),\n                      BiwaScheme.array_to_list(vec));\n        }\n      });\n      if (vectors.length == 1) {\n         return Cons(Sym(\"vector\"),\n                     BiwaScheme.array_to_list(vecs[0]));\n      }\n      else {\n        return Cons(Sym(\"vector-append\"),\n                    BiwaScheme.array_to_list(vectors));\n      }\n    }\n    else\n      return f;\n  }\n  define_syntax(\"quasiquote\", function(x){\n    return expand_qq(x.cdr.car, 1);\n  })\n  //unquote\n  define_syntax(\"unquote\", function(x){\n    throw new Error(\"unquote(,) must be inside quasiquote(`)\");\n  })\n  //unquote-splicing\n  define_syntax(\"unquote-splicing\", function(x){\n    throw new Error(\"unquote-splicing(,@) must be inside quasiquote(`)\");\n  })\n\n  //        11.18  Binding constructs for syntactic keywords\n  //let-syntax\n  //letrec-syntax\n\n  //        11.19  Macro transformers\n  //syntax-rules\n  //identifier-syntax\n  //\n\n  //        11.20  Tail calls and tail contexts\n  //(no library function introduced)\n\n\n  ///\n  /// R6RS Standard Libraries\n  ///\n\n  //\n  // Chapter 1 Unicode\n  //\n//(char-upcase char)    procedure\n//(char-downcase char)    procedure\n//(char-titlecase char)    procedure\n//(char-foldcase char)    procedure\n//\n//(char-ci=? char1 char2 char3 ...)    procedure\n//(char-ci<? char1 char2 char3 ...)    procedure\n//(char-ci>? char1 char2 char3 ...)    procedure\n//(char-ci<=? char1 char2 char3 ...)    procedure\n//(char-ci>=? char1 char2 char3 ...)    procedure\n//\n//(char-alphabetic? char)    procedure\n//(char-numeric? char)    procedure\n//(char-whitespace? char)    procedure\n//(char-upper-case? char)    procedure\n//(char-lower-case? char)    procedure\n//(char-title-case? char)    procedure\n//\n//(char-general-category char)    procedure\n\n  //(string-upcase string)    procedure\n  define_libfunc(\"string-upcase\", 1, 1, function(ar){\n    assert_string(ar[0]);\n    return ar[0].toUpperCase();\n  });\n  //(string-downcase string)    procedure\n  define_libfunc(\"string-downcase\", 1, 1, function(ar){\n    assert_string(ar[0]);\n    return ar[0].toLowerCase();\n  });\n//(string-titlecase string)    procedure\n//(string-foldcase string)    procedure\n\n  BiwaScheme.make_string_ci_function = function(compare){\n    return function(ar){\n      assert_string(ar[0]);\n      var str = ar[0].toUpperCase();\n\n      for(var i=1; i<ar.length; i++){\n        assert_string(ar[i]);\n        if (!compare(str, ar[i].toUpperCase()))\n          return false;\n      }\n      return true;\n    }\n  };\n  //(string-ci=? string1 string2 string3 ...)    procedure\n  define_libfunc(\"string-ci=?\", 2, null,\n    make_string_ci_function(function(a, b){ return a == b; }));\n  //(string-ci<? string1 string2 string3 ...)    procedure\n  define_libfunc(\"string-ci<?\", 2, null,\n    make_string_ci_function(function(a, b){ return a < b; }));\n  //(string-ci>? string1 string2 string3 ...)    procedure\n  define_libfunc(\"string-ci>?\", 2, null,\n    make_string_ci_function(function(a, b){ return a > b; }));\n  //(string-ci<=? string1 string2 string3 ...)    procedure\n  define_libfunc(\"string-ci<=?\", 2, null,\n    make_string_ci_function(function(a, b){ return a <= b; }));\n  //(string-ci>=? string1 string2 string3 ...)    procedure\n  define_libfunc(\"string-ci>=?\", 2, null,\n    make_string_ci_function(function(a, b){ return a >= b; }));\n\n//(string-normalize-nfd string)    procedure\n//(string-normalize-nfkd string)    procedure\n//(string-normalize-nfc string)    procedure\n//(string-normalize-nfkc string)    procedure\n\n  //\n  // Chapter 2 Bytevectors\n  //\n\n  //\n  // Chapter 3 List utilities\n  //\n  define_libfunc(\"find\", 2, 2, function(ar){\n    var proc = ar[0], ls = ar[1];\n    assert_list(ls);\n    return Call.foreach(ls, {\n      call: function(x){ return new Call(proc, [x.car]) },\n      result: function(res, x){ if(res) return x.car; },\n      finish: function(){ return false }\n    })\n  })\n  define_libfunc(\"for-all\", 2, null, function(ar){\n    var proc = ar.shift();\n    var lists = ar;\n    _.each(lists, assert_list);\n\n    var last = true; //holds last result which proc returns\n    return Call.multi_foreach(lists, {\n      call: function(pairs){\n        return new Call(proc, _.map(pairs, function(x){ return x.car }));\n      },\n      result: function(res, pairs){\n        if(res === false) return false;\n        last = res;\n      },\n      finish: function(){ return last; }\n    })\n  })\n  define_libfunc(\"exists\", 2, null, function(ar){\n    var proc = ar.shift();\n    var lists = ar;\n    _.each(lists, assert_list);\n\n    return Call.multi_foreach(lists, {\n      call: function(pairs){\n        return new Call(proc, _.map(pairs, function(x){ return x.car }));\n      },\n      result: function(res, pairs){\n        if(res !== false) return res;\n      },\n      finish: function(){ return false; }\n    })\n  })\n  define_libfunc(\"filter\", 2, 2, function(ar){\n    var proc = ar[0], ls = ar[1];\n    assert_list(ls);\n\n    var a = [];\n    return Call.foreach(ls, {\n      call: function(x){ return new Call(proc, [x.car]) },\n      result: function(res, x){ if(res) a.push(x.car); },\n      finish: function(){ return array_to_list(a) }\n    })\n  })\n//  define_scmfunc(\"partition+\", 2, 2,\n//    \"(lambda (proc ls)  \\\n//       (define (partition2 proc ls t f) \\\n//         (if (null? ls) \\\n//           (values (reverse t) (reverse f)) \\\n//           (if (proc (car ls)) \\\n//             (partition2 proc (cdr ls) (cons (car ls) t) f) \\\n//             (partition2 proc (cdr ls) t (cons (car ls) f))))) \\\n//       (partition2 proc ls '() '()))\");\n\n  define_libfunc(\"partition\", 2, 2, function(ar){\n    var proc = ar[0], ls = ar[1];\n    assert_list(ls);\n\n    var t = [], f = [];\n    return Call.foreach(ls, {\n      call: function(x){ return new Call(proc, [x.car]) },\n      result: function(res, x){\n        if(res) t.push(x.car);\n        else    f.push(x.car);\n      },\n      finish: function(){\n        return new Values([array_to_list(t), array_to_list(f)]);\n      }\n    })\n  })\n  define_libfunc(\"fold-left\", 3, null, function(ar){\n    var proc = ar.shift(), accum = ar.shift(), lists = ar;\n    _.each(lists, assert_list);\n\n    return Call.multi_foreach(lists, {\n      call: function(pairs){\n        var args = _.map(pairs, function(x){ return x.car });\n        args.unshift(accum);\n        return new Call(proc, args);\n      },\n      result: function(res, pairs){ accum = res; },\n      finish: function(){ return accum; }\n    })\n  })\n  define_libfunc(\"fold-right\", 3, null, function(ar){\n    var proc = ar.shift(), accum = ar.shift();\n    var lists = _.map(ar, function(ls){\n      // reverse each list\n      assert_list(ls);\n      return array_to_list(ls.to_array().reverse());\n    })\n\n    return Call.multi_foreach(lists, {\n      call: function(pairs){\n        var args = _.map(pairs, function(x){ return x.car });\n        args.push(accum);\n        return new Call(proc, args);\n      },\n      result: function(res, pairs){ accum = res; },\n      finish: function(){ return accum; }\n    })\n  })\n  define_libfunc(\"remp\", 2, 2, function(ar){\n    var proc = ar[0], ls = ar[1];\n    assert_list(ls);\n\n    var ret = [];\n    return Call.foreach(ls, {\n      call: function(x){ return new Call(proc, [x.car]) },\n      result: function(res, x){ if(!res) ret.push(x.car); },\n      finish: function(){ return array_to_list(ret); }\n    })\n  })\n  var make_remover = function(key){\n    return function(ar){\n      var obj = ar[0], ls = ar[1];\n      assert_list(ls);\n\n      var ret = [];\n      return Call.foreach(ls, {\n        call: function(x){\n          return new Call(TopEnv[key] || CoreEnv[key], [obj, x.car])\n        },\n        result: function(res, x){ if(!res) ret.push(x.car); },\n        finish: function(){ return array_to_list(ret); }\n      })\n    }\n  }\n  define_libfunc(\"remove\", 2, 2, make_remover(\"equal?\"));\n  define_libfunc(\"remv\", 2, 2, make_remover(\"eqv?\"));\n  define_libfunc(\"remq\", 2, 2, make_remover(\"eq?\"));\n\n  define_libfunc(\"memp\", 2, 2, function(ar){\n    var proc = ar[0], ls = ar[1];\n    assert_list(ls);\n\n    var ret = [];\n    return Call.foreach(ls, {\n      call: function(x){ return new Call(proc, [x.car]) },\n      result: function(res, x){ if(res) return x; },\n      finish: function(){ return false; }\n    })\n  })\n  var make_finder = function(key){\n    return function(ar){\n      var obj = ar[0], ls = ar[1];\n      assert_list(ls);\n\n      var ret = [];\n      return Call.foreach(ls, {\n        call: function(x){\n          return new Call(TopEnv[key] || CoreEnv[key], [obj, x.car])\n        },\n        result: function(res, x){ if(res) return x; },\n        finish: function(){ return false; }\n      })\n    }\n  }\n  define_libfunc(\"member\", 2, 2, make_finder(\"equal?\"));\n  define_libfunc(\"memv\", 2, 2, make_finder(\"eqv?\"));\n  define_libfunc(\"memq\", 2, 2, make_finder(\"eq?\"));\n\n  define_libfunc(\"assp\", 2, 2, function(ar){\n    var proc = ar[0], als = ar[1];\n    assert_list(als);\n\n    var ret = [];\n    return Call.foreach(als, {\n      call: function(x){\n        if(x.car.car)\n          return new Call(proc, [x.car.car]);\n        else\n          throw new Error(\"ass*: pair required but got \"+to_write(x.car));\n      },\n      result: function(res, x){ if(res) return x.car; },\n      finish: function(){ return false; }\n    })\n  })\n  var make_assoc = function(func_name, eq_func_name){\n    return function(ar){\n      var obj = ar[0], list = ar[1];\n      assert_list(list);\n\n      var ret = [];\n      return Call.foreach(list, {\n        call: function(ls){\n          if(!BiwaScheme.isPair(ls.car))\n            throw new Error(func_name+\": pair required but got \"+to_write(ls.car));\n\n          var equality = (TopEnv[eq_func_name] || CoreEnv[eq_func_name]);\n          return new Call(equality, [obj, ls.car.car]);\n        },\n        result: function(was_equal, ls){ if(was_equal) return ls.car; },\n        finish: function(){ return false; }\n      })\n    }\n  }\n  define_libfunc(\"assoc\", 2, 2, make_assoc(\"assoc\", \"equal?\"));\n  define_libfunc(\"assv\", 2, 2, make_assoc(\"assv\", \"eqv?\"));\n  define_libfunc(\"assq\", 2, 2, make_assoc(\"assq\", \"eq?\"));\n\n  define_libfunc(\"cons*\", 1, null, function(ar){\n    if(ar.length == 1)\n      return ar[0];\n    else{\n      var ret = null;\n      _.each(ar.reverse(), function(x){\n        if(ret){\n          ret = new Pair(x, ret);\n        }\n        else\n          ret = x;\n      })\n      return ret;\n    }\n  });\n\n  //\n  // Chapter 4 Sorting\n  //\n  (function(){\n    // Destructively sort the given array\n    // with scheme function `proc` as comparator\n    var mergeSort = function(ary, proc, finish) {\n      if (ary.length <= 1) return finish(ary);\n      return mergeSort_(ary, proc, finish, [[0, ary.length, false]], false);\n    };\n\n    var mergeSort_ = function(ary, proc, finish, stack, up) {\n      while(true) {\n        var start = stack[stack.length-1][0],\n            end   = stack[stack.length-1][1],\n            left  = stack[stack.length-1][2];\n        var len = end - start;\n        //console.debug(\"mergeSort_\", ary, stack.join(' '), up?\"u\":\"d\", \"\"+start+\"..\"+(end-1))\n\n        if (len >= 2 && !up) {\n          // There are parts to be sorted\n          stack.push([start, start+(len>>1), true]); continue;\n        }\n        else if (left) {\n          // Left part sorted. Continue to the right one\n          stack.pop();\n          var rend = stack[stack.length-1][1];\n          stack.push([end, rend, false]); up = false; continue;\n        }\n        else {\n          // Right part sorted. Merge left and right\n          stack.pop();\n          var lstart = stack[stack.length-1][0];\n          var ary1 = ary.slice(lstart, start),\n              ary2 = ary.slice(start, end);\n          return merge_(ary1, ary2, proc, [], 0, 0, function(ret) {\n            //console.debug(\"mergeSortd\", ary, stack.join(' '), up?\"u\":\"d\", ary1, ary2, ret, \"\"+start+\"..\"+(start+len-1));\n            for (var i = 0; i < ret.length; i++) {\n              ary[lstart + i] = ret[i];\n            }\n\n            if (stack.length == 1) {\n              return finish(ary);\n            }\n            else {\n              return mergeSort_(ary, proc, finish, stack, true);\n            }\n          });\n        }\n      }\n    };\n\n    var merge_ = function(ary1, ary2, proc, ret, i, j, cont) {\n      //console.debug(\"merge_\", ary1, ary2, ret, i, j);\n      var len1 = ary1.length, len2 = ary2.length;\n      if (i < len1 && j < len2) {\n        return new Call(proc, [ary2[j], ary1[i]], function(ar) {\n          //console.debug(\"comp\", [ary2[j], ary1[i]], ar[0]);\n          if (ar[0]) {\n            ret.push(ary2[j]); j+=1;\n          }\n          else {\n            ret.push(ary1[i]); i+=1;\n          }\n          return merge_(ary1, ary2, proc, ret, i, j, cont);\n        });\n      }\n      else {\n        while (i < len1) { ret.push(ary1[i]); i+=1; }\n        while (j < len2) { ret.push(ary2[j]); j+=1; }\n        return cont(ret)\n      }\n    };\n\n    var compareFn = function(a,b){\n      return BiwaScheme.lt(a, b) ? -1 :\n             BiwaScheme.lt(b, a) ? 1 : 0;\n    };\n\n    define_libfunc(\"list-sort\", 1, 2, function(ar){\n      if(ar[1]){\n        assert_procedure(ar[0]);\n        assert_list(ar[1]);\n        return mergeSort(ar[1].to_array(), ar[0], function(ret) {\n          return array_to_list(ret);\n        });\n      }\n      else {\n        assert_list(ar[0]);\n        return array_to_list(ar[0].to_array().sort(compareFn));\n      }\n    });\n\n    //(vector-sort proc vector)    procedure\n    define_libfunc(\"vector-sort\", 1, 2, function(ar){\n      if(ar[1]){\n        assert_procedure(ar[0]);\n        assert_vector(ar[1]);\n        return mergeSort(_.clone(ar[1]), ar[0], function(ret){\n          return ret;\n        });\n      }\n      else {\n        assert_vector(ar[0]);\n        return _.clone(ar[0]).sort(compareFn);\n      }\n    });\n\n    //(vector-sort! proc vector)    procedure\n    define_libfunc(\"vector-sort!\", 1, 2, function(ar){\n      if(ar[1]){\n        assert_procedure(ar[0]);\n        assert_vector(ar[1]);\n        return mergeSort(ar[1], ar[0], function(ret) {\n          return BiwaScheme.undef;\n        });\n      }\n      else {\n        assert_vector(ar[0]);\n        ar[0].sort(compareFn);\n        return BiwaScheme.undef;\n      }\n    });\n  })();\n\n  //\n  // Chapter 5 Control Structures\n  //\n  define_syntax(\"when\", function(x){\n    //(when test body ...)\n    //=> (if test (begin body ...) #<undef>)\n    var test = x.cdr.car, body = x.cdr.cdr;\n\n    return new Pair(Sym(\"if\"),\n             new Pair(test,\n               new Pair(new Pair(Sym(\"begin\"), body),\n                 new Pair(BiwaScheme.undef, nil))));\n  });\n\n  define_syntax(\"unless\", function(x){\n    //(unless test body ...)\n    //=> (if (not test) (begin body ...) #<undef>)\n    var test = x.cdr.car, body = x.cdr.cdr;\n\n    return new Pair(Sym(\"if\"),\n             new Pair(new Pair(Sym(\"not\"), new Pair(test, nil)),\n               new Pair(new Pair(Sym(\"begin\"), body),\n                 new Pair(BiwaScheme.undef, nil))));\n  });\n\n  define_syntax(\"do\", function(x){\n    //(do ((var1 init1 step1)\n    //     (var2 init2 step2) ...)\n    //    (test expr1 expr2 ...)\n    //  body1 body2 ...)\n    //=> (let loop` ((var1 init1) (var2 init2) ...)\n    //     (if test\n    //       (begin expr1 expr2 ...)\n    //       (begin body1 body2 ...\n    //              (loop` step1 step2 ...)))))\n\n    // parse arguments\n    if(!BiwaScheme.isPair(x.cdr))\n      throw new Error(\"do: no variables of do\");\n    var varsc = x.cdr.car;\n    if(!BiwaScheme.isPair(varsc))\n      throw new Error(\"do: variables must be given as a list\");\n    if(!BiwaScheme.isPair(x.cdr.cdr))\n      throw new Error(\"do: no resulting form of do\");\n    var resultc = x.cdr.cdr.car;\n    var bodyc = x.cdr.cdr.cdr;\n\n    // construct subforms\n    var loop = BiwaScheme.gensym();\n\n    var init_vars = array_to_list(varsc.map(function(var_def){\n      var a = var_def.to_array();\n      return List(a[0], a[1]);\n    }));\n\n    var test = resultc.car;\n    var result_exprs = new Pair(Sym(\"begin\"), resultc.cdr);\n\n    var next_loop = new Pair(loop, array_to_list(varsc.map(function(var_def){\n      var a = var_def.to_array();\n      return a[2] || a[0];\n    })));\n    var body_exprs = new Pair(Sym(\"begin\"), bodyc).concat(List(next_loop));\n\n    // combine subforms\n    return List(Sym(\"let\"),\n                loop,\n                init_vars,\n                List(Sym(\"if\"),\n                     test,\n                     result_exprs,\n                     body_exprs));\n  });\n\n  //(case-lambda <case-lambda clause> ...)    syntax\n  define_syntax(\"case-lambda\", function(x){\n    if(!BiwaScheme.isPair(x.cdr))\n      throw new Error(\"case-lambda: at least 1 clause required\");\n    var clauses = x.cdr.to_array();\n    \n    var args_ = BiwaScheme.gensym();\n    var exec = List(Sym(\"raise\"), \"case-lambda: no matching clause found\");\n\n    clauses.reverse().forEach(function(clause) {\n      if(!BiwaScheme.isPair(clause))\n        throw new Error(\"case-lambda: clause must be a pair: \"+\n                        BiwaScheme.to_write(clause));\n      var formals = clause.car, clause_body = clause.cdr;\n\n      if (formals === BiwaScheme.nil) {\n        exec = List(Sym(\"if\"),\n                    List(Sym(\"null?\"), args_),\n                    new Pair(Sym(\"begin\"), clause_body),\n                    exec);\n      }\n      else if (BiwaScheme.isPair(formals)) {\n        var len = formals.length(), last_cdr = formals.last_cdr();\n        var pred = (last_cdr === BiwaScheme.nil ? Sym(\"=\") : Sym(\">=\"));\n        var lambda = new Pair(Sym(\"lambda\"),\n                       new Pair(formals,\n                         clause_body));\n        exec = List(Sym(\"if\"),\n                    List(pred, List(Sym(\"length\"), args_), len),\n                    List(Sym(\"apply\"), lambda, args_),\n                    exec);\n      }\n      else if (BiwaScheme.isSymbol(formals)) {\n        exec = new Pair(Sym(\"let1\"),\n                 new Pair(formals,\n                   new Pair(args_,\n                     clause_body)));\n        // Note: previous `exec` is just discarded because this is a wildcard pattern.\n      }\n      else {\n        throw new Error(\"case-lambda: invalid formals: \"+\n                        BiwaScheme.to_write(formals));\n      }\n    });\n\n    return List(Sym(\"lambda\"), args_, exec);\n  });\n\n  //\n  // Chapter 6 Records\n  // see also: src/system/record.js\n  //\n\n  // 6.2 Records: Syntactic layer\n  //eqv, eq\n\n  //(define-record-type <name spec> <record clause>*)    syntax\n  define_syntax(\"define-record-type\", function(x){\n    // (define-record-type <name spec> <record clause>*)\n    var name_spec = x.cdr.car;\n    var record_clauses = x.cdr.cdr;\n\n    // 1. parse name spec\n    // <name spec>: either\n    // - <record name> eg: point\n    // - (<record name> <constructor name> <predicate name>)\n    //   eg: (point make-point point?)\n    if(BiwaScheme.isSymbol(name_spec)){\n      var record_name = name_spec;\n      var constructor_name = Sym(\"make-\"+name_spec.name);\n      var predicate_name = Sym(name_spec.name+\"?\");\n    }\n    else{\n      assert_list(name_spec);\n      var record_name = name_spec.car;\n      var constructor_name = name_spec.cdr.car;\n      var predicate_name = name_spec.cdr.cdr.car;\n      assert_symbol(record_name);\n      assert_symbol(constructor_name);\n      assert_symbol(predicate_name);\n    }\n\n    // 2. parse record clauses\n    var sealed = false;\n    var opaque = false;\n    var nongenerative = false;\n    var uid = false;\n    var parent_name;\n    var parent_rtd = false;\n    var parent_cd = false;\n    var protocol = false;\n    var fields = [];\n\n    // <record clause>:\n    _.each(record_clauses.to_array(), function(clause){\n      switch(clause.car){\n        // - (fields <field spec>*)\n        case Sym(\"fields\"):\n          fields = _.map(clause.cdr.to_array(), function(field_spec, idx){\n            if(BiwaScheme.isSymbol(field_spec)){\n              // - <field name>\n              return {name: field_spec, idx: idx, mutable: false,\n                      accessor_name: null, mutator_name: null};\n            }\n            else{\n              assert_list(field_spec);\n              assert_symbol(field_spec.car);\n              switch(field_spec.car){\n                case Sym(\"immutable\"):\n                  // - (immutable <field name>)\n                  // - (immutable <field name> <accessor name>)\n                  var field_name = field_spec.cdr.car;\n                  assert_symbol(field_name);\n\n                  if(BiwaScheme.isNil(field_spec.cdr.cdr))\n                    return {name: field_name, idx: idx, mutable: false};\n                  else\n                    return {name: field_name, idx: idx, mutable: false,\n                            accessor_name: field_spec.cdr.cdr.car};\n                  break;\n\n                case Sym(\"mutable\"):\n                  // - (mutable <field name>)\n                  // - (mutable <field name> <accessor name> <mutator name>)\n                  var field_name = field_spec.cdr.car;\n                  assert_symbol(field_name);\n\n                  if(BiwaScheme.isNil(field_spec.cdr.cdr))\n                    return {name: field_name, idx: idx, mutable: true}\n                  else\n                    return {name: field_name, idx: idx, mutable: true,\n                            accessor_name: field_spec.cdr.cdr.car,\n                            mutator_name:  field_spec.cdr.cdr.cdr.car};\n                  break;\n                default:\n                  throw new Error(\"define-record-type: field definition \"+\n                              \"must start with `immutable' or `mutable' \"+\n                              \"but got \"+BiwaScheme.inspect(field_spec.car));\n              }\n            }\n          });\n          break;\n        // - (parent <name>)\n        case Sym(\"parent\"):\n          parent_name = clause.cdr.car;\n          assert_symbol(parent_name);\n          break;\n        // - (protocol <expr>)\n        case Sym(\"protocol\"):\n          protocol = clause.cdr.car;\n          break;\n        // - (sealed <bool>)\n        case Sym(\"sealed\"):\n          sealed = !!clause.cdr.car;\n          break;\n        // - (opaque <bool>)\n        case Sym(\"opaque\"):\n          opaque = !!clause.cdr.car;\n          break;\n        // - (nongenerative <uid>?)\n        case Sym(\"nongenerative\"):\n          nongenerative = true;\n          uid = clause.cdr.car;\n          break;\n        // - (parent-rtd <rtd> <cd>)\n        case Sym(\"parent-rtd\"):\n          parent_rtd = clause.cdr.car;\n          parent_cd = clause.cdr.cdr.car;\n          break;\n        default:\n          throw new BiwaScheme.Error(\"define-record-type: unknown clause `\"+\n                                     BiwaScheme.to_write(clause.car)+\"'\");\n      }\n    });\n\n    if(parent_name){\n      parent_rtd = [Sym(\"record-type-descriptor\"), parent_name];\n      parent_cd  = [Sym(\"record-constructor-descriptor\"), parent_name];\n    }\n\n    // 3. build the definitions\n    // Note: In this implementation, rtd and cd are not bound to symbols.\n    // They are referenced through record name by record-type-descriptor\n    // and record-constructor-descriptor. These relation are stored in\n    // the hash BiwaScheme.Record._DefinedTypes.\n    var rtd = [Sym(\"record-type-descriptor\"), record_name];\n    var cd  = [Sym(\"record-constructor-descriptor\"), record_name];\n\n    // registration\n    var rtd_fields = _.map(fields, function(field){\n      return List(Sym(field.mutable ? \"mutable\" : \"immutable\"), field.name);\n    });\n    rtd_fields.is_vector = true; //tell List not to convert\n    var rtd_def = [Sym(\"make-record-type-descriptor\"),\n                    [Sym(\"quote\"), record_name], parent_rtd, uid,\n                    sealed, opaque, rtd_fields];\n    var cd_def = [Sym(\"make-record-constructor-descriptor\"),\n                    Sym(\"__rtd\"), parent_cd, protocol];\n    var registration =\n      [Sym(\"let*\"), [[Sym(\"__rtd\"), rtd_def],\n                    [Sym(\"__cd\"), cd_def]],\n        [Sym(\"_define-record-type\"),\n          [Sym(\"quote\"), record_name], Sym(\"__rtd\"), Sym(\"__cd\")]];\n\n    // accessors and mutators\n    var accessor_defs = _.map(fields, function(field){\n      var name = field.accessor_name ||\n                   Sym(record_name.name+\"-\"+field.name.name);\n\n      return [Sym(\"define\"), name, [Sym(\"record-accessor\"), rtd, field.idx]];\n    });\n\n    var mutator_defs = _.filter(fields, function(field){\n      return field.mutable;\n    });\n    mutator_defs = _.map(mutator_defs, function(field){\n      var name = field.mutator_name ||\n                   Sym(record_name.name+\"-\"+field.name.name+\"-set!\");\n\n      return [Sym(\"define\"), name, [Sym(\"record-mutator\"), rtd, field.idx]];\n    });\n\n    // Wrap the definitions with `begin'\n    // Example:\n    //   (begin\n    //     (let* ((__rtd (make-record-type-descriptor 'square\n    //                     (record-type-descriptor rect)\n    //                     #f #f #f\n    //                     #((mutable w) (mutable h))))\n    //            (__cd (make-record-constructor-descriptor __rtd\n    //                    (record-constructor-descriptor rect)\n    //                    (lambda (n) ...))))\n    //       (_define-record-type 'square __rtd __cd))\n    //\n    //     (define make-square\n    //       (record-constructor\n    //         (record-constructor-descriptor square)))\n    //     (define square?\n    //       (record-predicate (record-type-descriptor square)))\n    //     (define square-w\n    //       (record-accessor (record-type-descriptor square) 0))\n    //     (define square-h\n    //       (record-accessor (record-type-descriptor square) 1))\n    //     (define set-square-w!\n    //       (record-mutator (record-type-descriptor square) 0))\n    //     (define set-square-h!\n    //       (record-mutator (record-type-descriptor square) 1)))\n    //\n    return deep_array_to_list(\n      [Sym(\"begin\"),\n        registration,\n        [Sym(\"define\"), constructor_name, [Sym(\"record-constructor\"), cd]],\n        [Sym(\"define\"), predicate_name, [Sym(\"record-predicate\"), rtd]],\n        ].concat(accessor_defs).\n          concat(mutator_defs)\n    );\n  });\n\n  define_libfunc(\"_define-record-type\", 3, 3, function(ar){\n    assert_symbol(ar[0]);\n    assert_record_td(ar[1]);\n    assert_record_cd(ar[2]);\n    BiwaScheme.Record.define_type(ar[0].name, ar[1], ar[2]);\n    return BiwaScheme.undef;\n  });\n\n  //(record-type-descriptor <record name>)    syntax\n  define_syntax(\"record-type-descriptor\", function(x){\n    return deep_array_to_list([Sym(\"_record-type-descriptor\"), [Sym(\"quote\"), x.cdr.car]]);\n  });\n  define_libfunc(\"_record-type-descriptor\", 1, 1, function(ar){\n    assert_symbol(ar[0]);\n    var type = BiwaScheme.Record.get_type(ar[0].name);\n    if(type)\n      return type.rtd;\n    else\n      throw new Error(\"record-type-descriptor: unknown record type \"+ar[0].name);\n  });\n\n  //(record-constructor-descriptor <record name>)    syntax\n  define_syntax(\"record-constructor-descriptor\", function(x){\n    return deep_array_to_list([Sym(\"_record-constructor-descriptor\"), [Sym(\"quote\"), x.cdr.car]]);\n  });\n  define_libfunc(\"_record-constructor-descriptor\", 1, 1, function(ar){\n    assert_symbol(ar[0]);\n    var type = BiwaScheme.Record.get_type(ar[0].name);\n    if(type)\n      return type.cd;\n    else\n      throw new Error(\"record-constructor-descriptor: unknown record type \"+ar[0].name);\n  });\n\n  // 6.3  Records: Procedural layer\n  //(make-record-type-descriptor name    procedure\n  define_libfunc(\"make-record-type-descriptor\", 6, 6, function(ar){\n    var name = ar[0], parent_rtd = ar[1], uid = ar[2],\n        sealed = ar[3], opaque = ar[4], fields = ar[5];\n\n    assert_symbol(name);\n    if(parent_rtd) assert_record_td(parent_rtd);\n    if(uid){\n      assert_symbol(uid);\n      var _rtd = BiwaScheme.Record.RTD.NongenerativeRecords[uid.name];\n      if(_rtd){\n        // the record type is already defined.\n        return _rtd;\n        // should check equality of other arguments..\n      }\n    }\n    sealed = !!sealed;\n    opaque = !!opaque;\n    assert_vector(fields);\n    for(var i=0; i<fields.length; i++){\n      var list = fields[i];\n      assert_symbol(list.car, \"mutability\");\n      assert_symbol(list.cdr.car, \"field name\");\n      fields[i] = [list.cdr.car.name, (list.car == Sym(\"mutable\"))];\n    };\n\n    var rtd = new BiwaScheme.Record.RTD(name, parent_rtd, uid,\n                                     sealed, opaque, fields);\n    if(uid)\n      BiwaScheme.Record.RTD.NongenerativeRecords[uid.name] = rtd;\n\n    return rtd;\n  });\n\n  //(record-type-descriptor? obj)    procedure\n  define_libfunc(\"record-type-descriptor?\", 1, 1, function(ar){\n    return (ar[0] instanceof BiwaScheme.Record.RTD);\n  });\n\n  //(make-record-constructor-descriptor rtd    procedure\n  define_libfunc(\"make-record-constructor-descriptor\", 3, 3, function(ar){\n    var rtd = ar[0], parent_cd = ar[1], protocol = ar[2];\n\n    assert_record_td(rtd);\n    if(parent_cd) assert_record_cd(parent_cd);\n    if(protocol) assert_procedure(protocol);\n\n    return new BiwaScheme.Record.CD(rtd, parent_cd, protocol);\n  });\n\n  //(record-constructor constructor-descriptor)    procedure\n  define_libfunc(\"record-constructor\", 1, 1, function(ar){\n    var cd = ar[0];\n    assert_record_cd(cd);\n\n    return cd.record_constructor();\n  });\n\n  //(record-predicate rtd)    procedure\n  define_libfunc(\"record-predicate\", 1, 1, function(ar){\n    var rtd = ar[0];\n    assert_record_td(rtd);\n\n    return function(args){\n      var obj = args[0];\n\n      return (obj instanceof BiwaScheme.Record) &&\n             (obj.rtd === rtd);\n    };\n  });\n\n  //(record-accessor rtd k)    procedure\n  define_libfunc(\"record-accessor\", 2, 2, function(ar){\n    var rtd = ar[0], k = ar[1];\n    assert_record_td(rtd);\n    assert_integer(k);\n    for(var _rtd = rtd.parent_rtd; _rtd; _rtd = _rtd.parent_rtd)\n      k += _rtd.fields.length;\n\n    return function(args){\n      var record = args[0];\n      var error_msg = rtd.name.name+\"-\"+rtd.field_name(k)+\": \"+\n                      BiwaScheme.to_write(record)+\n                      \" is not a \"+rtd.name.name;\n      assert(BiwaScheme.isRecord(record), error_msg);\n\n      var descendant = false;\n      for(var _rtd = record.rtd; _rtd; _rtd = _rtd.parent_rtd){\n        if(_rtd == rtd) descendant = true;\n      }\n      assert(descendant, error_msg);\n\n      return record.get(k);\n    };\n  });\n\n  //(record-mutator rtd k)    procedure\n  define_libfunc(\"record-mutator\", 2, 2, function(ar){\n    var rtd = ar[0], k = ar[1];\n    assert_record_td(rtd);\n    assert_integer(k);\n    for(var _rtd = rtd.parent_rtd; _rtd; _rtd = _rtd.parent_rtd)\n      k += _rtd.fields.length;\n\n    return function(args){\n      var record = args[0], val = args[1];\n      var func_name = rtd.field_name(k);\n\n      assert_record(record);\n      assert(record.rtd === rtd,\n            func_name+\": \"+BiwaScheme.to_write(record)+\n            \" is not a \"+rtd.name.name);\n      assert(!record.rtd.sealed,\n            func_name+\": \"+rtd.name.name+\" is sealed (can't mutate)\");\n\n      record.set(k, val);\n    };\n  });\n\n  // 6.4  Records: Inspection\n  //(record? obj)    procedure\n  define_libfunc(\"record?\", 1, 1, function(ar){\n    var obj = ar[0];\n    if(BiwaScheme.isRecord(obj)){\n      if(obj.rtd.opaque)\n        return false; // opaque records pretend as if it is not a record.\n      else\n        return true;\n    }\n    else\n      return false;\n  });\n\n  //(record-rtd record)    procedure\n  define_libfunc(\"record-rtd\", 1, 1, function(ar){\n    assert_record(ar[0]);\n    return ar[0].rtd;\n  });\n\n  //(record-type-name rtd)    procedure\n  define_libfunc(\"record-type-name\", 1, 1, function(ar){\n    assert_record_td(ar[0]);\n    return ar[0].name;\n  });\n\n  //(record-type-parent rtd)    procedure\n  define_libfunc(\"record-type-parent\", 1, 1, function(ar){\n    assert_record_td(ar[0]);\n    return ar[0].parent_rtd;\n  });\n\n  //(record-type-uid rtd)    procedure\n  define_libfunc(\"record-type-uid\", 1, 1, function(ar){\n    assert_record_td(ar[0]);\n    return ar[0].uid;\n  });\n\n  //(record-type-generative? rtd)    procedure\n  define_libfunc(\"record-type-generative?\", 1, 1, function(ar){\n    assert_record_td(ar[0]);\n    return ar[0].generative;\n  });\n\n  //(record-type-sealed? rtd)    procedure\n  define_libfunc(\"record-type-sealed?\", 1, 1, function(ar){\n    assert_record_td(ar[0]);\n    return ar[0].sealed;\n  });\n\n  //(record-type-opaque? rtd)    procedure\n  define_libfunc(\"record-type-opaque?\", 1, 1, function(ar){\n    assert_record_td(ar[0]);\n    return ar[0].opaque;\n  });\n\n  //(record-type-field-names rtd)    procedure\n  define_libfunc(\"record-type-field-names\", 1, 1, function(ar){\n    assert_record_td(ar[0]);\n    return _.map(ar[0].fields, function(field){ return field.name; });\n  });\n\n  //(record-field-mutable? rtd k)    procedure\n  define_libfunc(\"record-field-mutable?\", 2, 2, function(ar){\n    var rtd = ar[0], k = ar[1];\n    assert_record_td(ar[0]);\n    assert_integer(k);\n\n    for(var _rtd = rtd.parent_rtd; _rtd; _rtd = _rtd.parent_rtd)\n      k += _rtd.fields.length;\n\n    return ar[0].fields[k].mutable;\n  });\n\n  //\n  // Chapter 7 Exceptions and conditions\n  //\n//(with-exception-handler handler thunk)    procedure\n//(guard (<variable>    syntax\n  //(raise obj)    procedure\n  define_libfunc(\"raise\", 1, 1, function(ar){\n    throw new BiwaScheme.UserError(BiwaScheme.to_write(ar[0]));\n  });\n//(raise-continuable obj)    procedure\n//\n//&condition    condition type\n//(condition condition1 ...)    procedure\n//(simple-conditions condition)    procedure\n//(condition? obj)    procedure\n//(condition-predicate rtd)    procedure\n//(condition-accessor rtd proc)    procedure\n//\n//&message    condition type\n//&warning    condition type\n//&serious    condition type\n//&error    condition type\n//&violation    condition type\n//&assertion    condition type\n//&irritants    condition type\n//&who    condition type\n//&non-continuable    condition type\n//&implementation-restriction    condition type\n//&lexical    condition type\n//&syntax    condition type\n//&undefined    condition type\n\n  //\n  // Chapter 8 I/O\n  //\n//  //    8  I/O\n//  //        8.1  Condition types\n//&i/o    condition type\n//&i/o-read    condition type\n//&i/o-write    condition type\n//&i/o-invalid-position    condition type\n//&i/o-filename    condition type\n//&i/o-file-protection    condition type\n//&i/o-file-is-read-only    condition type\n//&i/o-file-already-exists    condition type\n//&i/o-file-does-not-exist    condition type\n//&i/o-port    condition type\n//\n//  //        8.2  Port I/O\n//  //            8.2.1  File names\n//  //(no function introduced)\n//\n//  //            8.2.2  File options\n//(file-options <file-options symbol> ...)    syntax\n//\n//  //            8.2.3  Buffer modes\n//(buffer-mode <buffer-mode symbol>)    syntax\n//(buffer-mode? obj)    procedure\n//\n//  //            8.2.4  Transcoders\n//(latin-1-codec)    procedure\n//(utf-8-codec)    procedure\n//(utf-16-codec)    procedure\n//(eol-style <eol-style symbol>)    syntax\n//(native-eol-style)    procedure\n//&i/o-decoding    condition type\n//&i/o-encoding    condition type\n//(error-handling-mode <error-handling-mode symbol>)    syntax\n//(make-transcoder codec)    procedure\n//(make-transcoder codec eol-style)    procedure\n//(make-transcoder codec eol-style handling-mode)    procedure\n//(native-transcoder)    procedure\n//(transcoder-codec transcoder)    procedure\n//(transcoder-eol-style transcoder)    procedure\n//(transcoder-error-handling-mode transcoder)    procedure\n//(bytevector->string bytevector transcoder)    procedure\n//(string->bytevector string transcoder)    procedure\n//\n  //            8.2.5  End-of-file object\n  //-> 8.3 (eof-object)    procedure\n  //-> 8.3 (eof-object? obj)    procedure\n\n  //            8.2.6  Input and output ports\n  define_libfunc(\"port?\", 1, 1, function(ar){\n    return (ar[0] instanceof Port);\n  })\n//(port-transcoder port)    procedure\n  define_libfunc(\"textual-port?\", 1, 1, function(ar){\n    assert_port(ar[0]);\n    return !ar[0].is_binary;\n  })\n  define_libfunc(\"binary-port?\", 1, 1, function(ar){\n    assert_port(ar[0]);\n    return ar[0].is_binary;\n  })\n//(transcoded-port binary-port transcoder)    procedure\n//(port-has-port-position? port)    procedure\n//(port-position port)    procedure\n//(port-has-set-port-position!? port)    procedure\n//(set-port-position! port pos)    procedure\n  define_libfunc(\"close-port\", 1, 1, function(ar){\n    assert_port(ar[0]);\n    ar[0].close();\n    return BiwaScheme.undef;\n  })\n  //(call-with-port port proc)    procedure\n  define_libfunc(\"call-with-port\", 2, 2, function(ar){\n    var port = ar[0], proc = ar[1];\n    assert_port(port);\n    assert_closure(proc);\n\n    return new Call(proc, [port], function(ar){\n      // Automatically close the port\n      port.close();\n      return ar[0]; // TODO: values\n    });\n  });\n\n  //            8.2.7  Input ports\n  //8.3 (input-port? obj)    procedure\n//(port-eof? input-port)    procedure\n//(open-file-input-port filename)    procedure\n//(open-bytevector-input-port bytevector)    procedure\n//(open-string-input-port string)    procedure\n//(standard-input-port)    procedure\n//8.3 (current-input-port)    procedure\n//(make-custom-binary-input-port id read!    procedure\n//(make-custom-textual-input-port id read!    procedure\n//\n//  //            8.2.8  Binary input\n//(get-u8 binary-input-port)    procedure\n//(lookahead-u8 binary-input-port)    procedure\n//(get-bytevector-n binary-input-port count)    procedure\n//(get-bytevector-n! binary-input-port    procedure\n//(get-bytevector-some binary-input-port)    procedure\n//(get-bytevector-all binary-input-port)    procedure\n//\n//  //            8.2.9  Textual input\n//(get-char textual-input-port)    procedure\n//(lookahead-char textual-input-port)    procedure\n//(get-string-n textual-input-port count)    procedure\n//(get-string-n! textual-input-port string start count)    procedure\n//(get-string-all textual-input-port)    procedure\n//(get-line textual-input-port)    procedure\n//(get-datum textual-input-port)    procedure\n//\n  //            8.2.10  Output ports\n  //8.3 (output-port? obj)    procedure\n//(flush-output-port output-port)    procedure\n//(output-port-buffer-mode output-port)    procedure\n//(open-file-output-port filename)    procedure\n//(open-bytevector-output-port)    procedure\n//(call-with-bytevector-output-port proc)    procedure\n//(open-string-output-port)    procedure\n  //(call-with-string-output-port proc)    procedure\n  define_libfunc(\"call-with-string-output-port\", 1, 1, function(ar){\n    var proc = ar[0];\n    assert_procedure(proc);\n\n    var port = new BiwaScheme.Port.StringOutput();\n\n    return new Call(proc, [port], function(ar){\n      port.close();\n      return port.output_string();\n    });\n  });\n\n//(standard-output-port)    procedure\n//(standard-error-port)    procedure\n//8.3 (current-output-port)    procedure\n//8.3 (current-error-port)    procedure\n//(make-custom-binary-output-port id    procedure\n  //(make-custom-textual-output-port id write! get-position set-position! close)\n//  define_libfunc(\"make-custom-textual-output-port\", 5, 5, function(ar){\n//    assert_string(ar[0]);\n//    assert_closure(ar[1]);\n//    assert_closure(ar[2]);\n//    assert_closure(ar[3]);\n//    assert_closure(ar[4]);\n//    return new Port(ar[0], ar[1], ar[2], ar[3], ar[4]);\n//  })\n//\n//  //            8.2.11  Binary output\n//(put-u8 binary-output-port octet)    procedure\n//(put-bytevector binary-output-port bytevector)    procedure\n//\n  //            8.2.12  Textual output\n  define_libfunc(\"put-char\", 2, 2, function(ar){\n    assert_port(ar[0]);\n    assert_char(ar[1]);\n    ar[0].put_string(ar[1].value);\n    return BiwaScheme.undef;\n  })\n  define_libfunc(\"put-string\", 2, 2, function(ar){\n    assert_port(ar[0]);\n    assert_string(ar[1]);\n    ar[0].put_string(ar[1]);\n    return BiwaScheme.undef;\n  })\n  define_libfunc(\"put-datum\", 2, 2, function(ar){\n    assert_port(ar[0]);\n    ar[0].put_string(to_write(ar[1]));\n    return BiwaScheme.undef;\n  })\n//\n//  //            8.2.13  Input/output ports\n//(open-file-input/output-port filename)    procedure\n//(make-custom-binary-input/output-port    procedure\n//(make-custom-textual-input/output-port    procedure\n//\n//  //        8.3  Simple I/O\n  define_libfunc(\"eof-object\", 0, 0, function(ar){\n    return eof;\n  })\n  define_libfunc(\"eof-object?\", 1, 1, function(ar){\n    return ar[0] === eof;\n  })\n//(call-with-input-file filename proc)    procedure\n//(call-with-output-file filename proc)    procedure\n  define_libfunc(\"input-port?\", 1, 1, function(ar){\n    assert_port(ar[0]);\n    return ar[0].is_input;\n  })\n  define_libfunc(\"output-port?\", 1, 1, function(ar){\n    assert_port(ar[0]);\n    return ar[0].is_output;\n  })\n  define_libfunc(\"current-input-port\", 0, 0, function(ar){\n    return Port.current_input;\n  })\n  define_libfunc(\"current-output-port\", 0, 0, function(ar){\n    return Port.current_output;\n  })\n  define_libfunc(\"current-error-port\", 0, 0, function(ar){\n    return Port.current_error;\n  })\n//(with-input-from-file filename thunk)    procedure\n//(with-output-to-file filename thunk)    procedure\n//(open-input-file filename)    procedure\n//(open-output-file filename)    procedure\n  define_libfunc(\"close-input-port\", 1, 1, function(ar){\n    assert_port(ar[0]);\n    if(!ar[0].is_input)\n      throw new Error(\"close-input-port: port is not input port\");\n    ar[0].close();\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"close-output-port\", 1, 1, function(ar){\n    assert_port(ar[0]);\n    if(!ar[0].is_output)\n      throw new Error(\"close-output-port: port is not output port\");\n    ar[0].close();\n    return BiwaScheme.undef;\n  });\n//(read-char)    procedure\n//(peek-char)    procedure\n  define_libfunc(\"read\", 0, 1, function(ar){\n    var port = ar[0] || Port.current_input;\n    assert_port(port);\n\n    return port.get_string(function(str){\n      return Interpreter.read(str); \n    });\n  })\n\n  define_libfunc(\"write-char\", 1, 2, function(ar){\n    var port = ar[1] || Port.current_output;\n    assert_char(ar[0]);\n    port.put_string(ar[0].value);\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"newline\", 0, 1, function(ar){\n    var port = ar[0] || Port.current_output;\n    port.put_string(\"\\n\");\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"display\", 1, 2, function(ar){\n    var port = ar[1] || Port.current_output;\n    port.put_string(to_display(ar[0]));\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"write\", 1, 2, function(ar){\n    var port = ar[1] || Port.current_output;\n    assert_port(port);\n    port.put_string(to_write(ar[0]));\n    return BiwaScheme.undef;\n  });\n\n  //\n  // Chapter 9 File System\n  // Chapter 10 Command-line access and exit values\n  //\n  // see src/library/node_functions.js\n\n  //\n  // Chapter 11 Arithmetic\n  //\n////        11.1  Bitwise operations\n////        11.2  Fixnums\n//(fixnum? obj)    procedure\n//(fixnum-width)    procedure\n//(least-fixnum)    procedure\n//(greatest-fixnum)    procedure\n//(fx=? fx1 fx2 fx3 ...)    procedure\n//(fx>? fx1 fx2 fx3 ...)    procedure\n//(fx<? fx1 fx2 fx3 ...)    procedure\n//(fx>=? fx1 fx2 fx3 ...)    procedure\n//(fx<=? fx1 fx2 fx3 ...)    procedure\n//(fxzero? fx)    procedure\n//(fxpositive? fx)    procedure\n//(fxnegative? fx)    procedure\n//(fxodd? fx)    procedure\n//(fxeven? fx)    procedure\n//(fxmax fx1 fx2 ...)    procedure\n//(fxmin fx1 fx2 ...)    procedure\n//(fx+ fx1 fx2)    procedure\n//(fx* fx1 fx2)    procedure\n//(fx- fx1 fx2)    procedure\n//(fxdiv-and-mod fx1 fx2)    procedure\n//(fxdiv fx1 fx2)    procedure\n//(fxmod fx1 fx2)    procedure\n//(fxdiv0-and-mod0 fx1 fx2)    procedure\n//(fxdiv0 fx1 fx2)    procedure\n//(fxmod0 fx1 fx2)    procedure\n//(fx+/carry fx1 fx2 fx3)    procedure\n//(fx-/carry fx1 fx2 fx3)    procedure\n//(fx*/carry fx1 fx2 fx3)    procedure\n//(fxnot fx)    procedure\n//(fxand fx1 ...)    procedure\n//(fxior fx1 ...)    procedure\n//(fxxor fx1 ...)    procedure\n//(fxif fx1 fx2 fx3)    procedure\n//(fxbit-count fx)    procedure\n//(fxlength fx)    procedure\n//(fxfirst-bit-set fx)    procedure\n//(fxbit-set? fx1 fx2)    procedure\n//(fxcopy-bit fx1 fx2 fx3)    procedure\n//(fxbit-field fx1 fx2 fx3)    procedure\n//(fxcopy-bit-field fx1 fx2 fx3 fx4)    procedure\n//(fxarithmetic-shift fx1 fx2)    procedure\n//(fxarithmetic-shift-left fx1 fx2)    procedure\n//(fxarithmetic-shift-right fx1 fx2)    procedure\n//(fxrotate-bit-field fx1 fx2 fx3 fx4)    procedure\n//(fxreverse-bit-field fx1 fx2 fx3)    procedure\n//\n////        11.3  Flonums\n//(flonum? obj)    procedure\n//(real->flonum x)    procedure\n//(fl=? fl1 fl2 fl3 ...)    procedure\n//(fl<? fl1 fl2 fl3 ...)    procedure\n//(fl<=? fl1 fl2 fl3 ...)    procedure\n//(fl>? fl1 fl2 fl3 ...)    procedure\n//(fl>=? fl1 fl2 fl3 ...)    procedure\n//(flinteger? fl)    procedure\n//(flzero? fl)    procedure\n//(flpositive? fl)    procedure\n//(flnegative? fl)    procedure\n//(flodd? ifl)    procedure\n//(fleven? ifl)    procedure\n//(flfinite? fl)    procedure\n//(flinfinite? fl)    procedure\n//(flnan? fl)    procedure\n//(flmax fl1 fl2 ...)    procedure\n//(flmin fl1 fl2 ...)    procedure\n//(fl+ fl1 ...)    procedure\n//(fl* fl1 ...)    procedure\n//(fl- fl1 fl2 ...)    procedure\n//(fl- fl)    procedure\n//(fl/ fl1 fl2 ...)    procedure\n//(fl/ fl)    procedure\n//(flabs fl)    procedure\n//(fldiv-and-mod fl1 fl2)    procedure\n//(fldiv fl1 fl2)    procedure\n//(flmod fl1 fl2)    procedure\n//(fldiv0-and-mod0 fl1 fl2)    procedure\n//(fldiv0 fl1 fl2)    procedure\n//(flmod0 fl1 fl2)    procedure\n//(flnumerator fl)    procedure\n//(fldenominator fl)    procedure\n//(flfloor fl)    procedure\n//(flceiling fl)    procedure\n//(fltruncate fl)    procedure\n//(flround fl)    procedure\n//(flexp fl)    procedure\n//(fllog fl)    procedure\n//(fllog fl1 fl2)    procedure\n//(flsin fl)    procedure\n//(flcos fl)    procedure\n//(fltan fl)    procedure\n//(flasin fl)    procedure\n//(flacos fl)    procedure\n//(flatan fl)    procedure\n//(flatan fl1 fl2)    procedure\n//(flsqrt fl)    procedure\n//(flexpt fl1 fl2)    procedure\n//&no-infinities    condition type\n//&no-nans    condition type\n//(fixnum->flonum fx)    procedure\n\n  ////        11.4  Exact bitwise arithmetic\n  //(bitwise-not ei)    procedure\n  define_libfunc(\"bitwise-not\", 1, 1, function(ar){\n    return ~(ar[0]);\n  });\n\n  //(bitwise-and ei1 ...)    procedure\n  define_libfunc(\"bitwise-and\", 1, null, function(ar){\n    return _.reduce(ar, function(ret, item){ return ret & item; });\n  });\n\n  //(bitwise-ior ei1 ...)    procedure\n  define_libfunc(\"bitwise-ior\", 1, null, function(ar){\n    return _.reduce(ar, function(ret, item){ return ret | item; });\n  });\n\n  //(bitwise-xor ei1 ...)    procedure\n  define_libfunc(\"bitwise-xor\", 1, null, function(ar){\n    return _.reduce(ar, function(ret, item){ return ret ^ item; });\n  });\n\n  //(bitwise-if ei1 ei2 ei3)    procedure\n  define_libfunc(\"bitwise-if\", 3, 3, function(ar){\n    return (ar[0] & ar[1]) | (~ar[0] & ar[2]);\n  });\n\n  //(bitwise-bit-count ei)    procedure\n  define_libfunc(\"bitwise-bit-count\", 1, 1, function(ar){\n    var e = Math.abs(ar[0]), ret = 0;\n    for (; e != 0; e >>= 1) {\n      if(e & 1) ret++;\n    }\n    return ret;\n  });\n\n  //(bitwise-length ei)    procedure\n  define_libfunc(\"bitwise-length\", 1, 1, function(ar){\n    var e = Math.abs(ar[0]), ret = 0;\n    for (; e != 0; e >>= 1) {\n      ret++;\n    }\n    return ret;\n  });\n\n  //(bitwise-first-bit-set ei)    procedure\n  define_libfunc(\"bitwise-first-bit-set\", 1, 1, function(ar){\n    var e = Math.abs(ar[0]), ret = 0;\n    if (e == 0) return -1;\n    for (; e != 0; e >>= 1) {\n      if (e & 1) return ret;\n      ret++;\n    }\n  });\n\n  //(bitwise-bit-set? ei1 ei2)    procedure\n  define_libfunc(\"bitwise-bit-set?\", 2, 2, function(ar){\n    return !!(ar[0] & (1 << ar[1]));\n  });\n\n  //(bitwise-copy-bit ei1 n b)    procedure\n  define_libfunc(\"bitwise-copy-bit\", 3, 3, function(ar){\n    var mask = (1 << ar[1]);\n    return (mask & (ar[2] << ar[1])) |   // Set n-th bit to b\n           (~mask & ar[0]);              // and use ei1 for rest of the bits\n  });\n\n  //(bitwise-bit-field ei1 start end)    procedure\n  define_libfunc(\"bitwise-bit-field\", 3, 3, function(ar){\n    var mask = ~(-1 << ar[2]);  // Has 1 at 0...end\n    return (mask & ar[0]) >> ar[1];\n  });\n\n  //(bitwise-copy-bit-field dst start end src)    procedure\n  define_libfunc(\"bitwise-copy-bit-field\", 4, 4, function(ar){\n    var dst=ar[0], start=ar[1], end=ar[2], src=ar[3];\n    var mask = ~(-1 << end) &   // Has 1 at 0...end\n                (-1 << start)   // Clear 0...start\n    return (mask & (src << start)) |\n           (~mask & dst);\n  });\n\n  //(bitwise-arithmetic-shift ei1 ei2)    procedure\n  define_libfunc(\"bitwise-arithmetic-shift\", 2, 2, function(ar){\n    return (ar[1] >= 0) ? (ar[0] << ar[1]) : (ar[0] >> -ar[1]);\n  });\n\n  //(bitwise-arithmetic-shift-left ei1 ei2)    procedure\n  define_libfunc(\"bitwise-arithmetic-shift-left\", 2, 2, function(ar){\n    return ar[0] << ar[1];\n  });\n\n  //(bitwise-arithmetic-shift-right ei1 ei2)    procedure\n  define_libfunc(\"bitwise-arithmetic-shift-right\", 2, 2, function(ar){\n    return ar[0] >> ar[1];\n  });\n\n  //(bitwise-rotate-bit-field ei1 start end count)    procedure\n  define_libfunc(\"bitwise-rotate-bit-field\", 4, 4, function(ar){\n    var n=ar[0], start=ar[1], end=ar[2], count=ar[3];\n    var width = end - start;\n    if (width <= 0) return n;\n\n    count %= width;\n    var orig_field = (~(-1 << end) & n) >> start;\n    var rotated_field = (orig_field << count) |\n                        (orig_field >> (width - count))\n\n    var mask = ~(-1 << end) & (-1 << start);\n    return (mask & (rotated_field << start)) |\n           (~mask & n);\n  });\n\n  //(bitwise-reverse-bit-field ei1 ei2 ei3)    procedure\n  define_libfunc(\"bitwise-reverse-bit-field\", 3, 3, function(ar){\n    var ret=n=ar[0], start=ar[1], end=ar[2];\n    var orig_field = ((~(-1 << end) & n) >> start);\n    for (var i=0; i<(end-start); i++, orig_field>>=1) {\n      var bit = orig_field & 1;\n      var setpos = end - 1 - i;\n      var mask = (1 << setpos);\n      ret = (mask & (bit << setpos)) | (~mask & ret);\n    }\n    return ret;\n  });\n\n  //\n  // Chapter 12 syntax-case\n  //\n\n  //\n  // Chapter 13 Hashtables\n  //\n\n  //13.1  Constructors\n  //(define h (make-eq-hashtale)\n  //(define h (make-eq-hashtable 1000))\n  define_libfunc(\"make-eq-hashtable\", 0, 1, function(ar){\n    // Note: ar[1] (hashtable size) is just ignored\n    return new Hashtable(Hashtable.eq_hash, Hashtable.eq_equiv);\n  });\n  //(make-eqv-hashtable)    procedure\n  //(make-eqv-hashtable k)    procedure\n  define_libfunc(\"make-eqv-hashtable\", 0, 1, function(ar){\n    return new Hashtable(Hashtable.eqv_hash, Hashtable.eqv_equiv);\n  });\n  //(make-hashtable hash-function equiv)    procedure\n  //(make-hashtable hash-function equiv k)    procedure\n  define_libfunc(\"make-hashtable\", 2, 3, function(ar){\n    assert_procedure(ar[0]);\n    assert_procedure(ar[1]);\n    return new Hashtable(ar[0], ar[1]);\n  });\n\n  //13.2  Procedures\n  // (hashtable? hash)\n  define_libfunc(\"hashtable?\", 1, 1, function(ar){\n    return ar[0] instanceof Hashtable;\n  });\n  //(hashtable-size hash)\n  define_libfunc(\"hashtable-size\", 1, 1, function(ar){\n    assert_hashtable(ar[0]);\n    return ar[0].keys().length;\n  });\n\n  // Find a pair from a hashtable with given key.\n  //\n  // hash      - a BiwaScheme.Hashtable\n  // key       - an object\n  // callbacks - an object contains callback functions\n  //             .on_found     - function(pair, hashed)\n  //               pair   - [Object key, Object value]\n  //               hashed - Object hashed\n  //             .on_not_found - function(hashed)\n  //               hashed - Object hashed\n  //\n  // Returns an instance of BiwaScheme.Call.\n  BiwaScheme.find_hash_pair = function(hash, key, callbacks){\n    // invoke hash proc\n    return new Call(hash.hash_proc, [key], function(ar){\n      var hashed = ar[0];\n      var candidate_pairs = hash.candidate_pairs(hashed);\n\n      if (!candidate_pairs){ // shortcut: obviously not found\n        return callbacks.on_not_found(hashed);\n      }\n\n      // search the exact key from candidates\n      return Call.foreach(candidate_pairs, {\n        call: function(pair){\n          // invoke the equivalence proc\n          return new Call(hash.equiv_proc, [key, pair[0]]);\n        },\n        result: function(equal, pair){\n          if(equal) {       // found\n            return callbacks.on_found(pair, hashed);\n          }\n        },\n        finish: function(){ // not found\n          return callbacks.on_not_found(hashed);\n        }\n      });\n    });\n  };\n\n  //(hashtable-ref hash \"foo\" #f)\n  define_libfunc(\"hashtable-ref\", 3, 3, function(ar){\n    var hash = ar[0], key = ar[1], ifnone = ar[2];\n    assert_hashtable(hash);\n\n    return BiwaScheme.find_hash_pair(hash, key, {\n      on_found: function(pair){\n        return pair[1];\n      },\n      on_not_found: function(hashed){\n        return ifnone;\n      }\n    });\n  });\n\n  //(hashtable-set! hash \"foo\" '(1 2))\n  define_libfunc(\"hashtable-set!\", 3, 3, function(ar){\n    var hash = ar[0], key = ar[1], value = ar[2];\n    assert_hashtable(hash);\n    assert(hash.mutable, \"hashtable is not mutable\");\n\n    return BiwaScheme.find_hash_pair(hash, key, {\n      on_found: function(pair){\n        pair[1] = value;\n        return BiwaScheme.undef;\n      },\n      on_not_found: function(hashed){\n        hash.add_pair(hashed, key, value);\n        return BiwaScheme.undef;\n      }\n    });\n  });\n\n  //(hashtable-delete! hash \"foo\")\n  define_libfunc(\"hashtable-delete!\", 2, 2, function(ar){\n    var hash = ar[0], key = ar[1];\n    assert_hashtable(hash);\n    assert(hash.mutable, \"hashtable is not mutable\");\n\n    return BiwaScheme.find_hash_pair(hash, key, {\n      on_found: function(pair, hashed){\n        hash.remove_pair(hashed, pair);\n        return BiwaScheme.undef;\n      },\n      on_not_found: function(hashed){\n        return BiwaScheme.undef;\n      }\n    });\n  });\n\n  //(hashtable-contains? hash \"foo\")\n  define_libfunc(\"hashtable-contains?\", 2, 2, function(ar){\n    var hash = ar[0], key = ar[1];\n    assert_hashtable(hash);\n\n    return BiwaScheme.find_hash_pair(hash, key, {\n      on_found: function(pair){\n        return true;\n      },\n      on_not_found: function(hashed){\n        return false;\n      }\n    });\n  });\n\n  //(hashtable-update! hashtable key proc default)    procedure\n  define_libfunc(\"hashtable-update!\", 4, 4, function(ar){\n    var hash = ar[0], key = ar[1], proc = ar[2], ifnone = ar[3];\n    assert_hashtable(hash);\n    assert(hash.mutable, \"hashtable is not mutable\");\n    assert_procedure(proc);\n\n    return BiwaScheme.find_hash_pair(hash, key, {\n      on_found: function(pair, hashed){\n        // invoke proc and get new value\n        return new Call(proc, [pair[1]], function(ar){\n          // replace the value\n          pair[1] = ar[0];\n          return BiwaScheme.undef;\n        });\n      },\n      on_not_found: function(hashed){\n        // invoke proc and get new value\n        return new Call(proc, [ifnone], function(ar){\n          // create new pair\n          hash.add_pair(hashed, key, ar[0]);\n          return BiwaScheme.undef;\n        });\n      }\n    });\n  });\n  //(hashtable-copy hashtable)    procedure\n  //(hashtable-copy hashtable mutable)    procedure\n  define_libfunc(\"hashtable-copy\", 1, 2, function(ar){\n    var mutable = (ar[1]===undefined) ? false : !!ar[1];\n    assert_hashtable(ar[0]);\n    return ar[0].create_copy(mutable);\n  });\n  //(hashtable-clear! hashtable)    procedure\n  //(hashtable-clear! hashtable k)    procedure\n  define_libfunc(\"hashtable-clear!\", 0, 1, function(ar){\n    assert_hashtable(ar[0]);\n    assert(ar[0].mutable, \"hashtable is not mutable\");\n    ar[0].clear();\n    return BiwaScheme.undef;\n  });\n  //(hashtable-keys hash)  ; => vector\n  define_libfunc(\"hashtable-keys\", 1, 1, function(ar){\n    assert_hashtable(ar[0]);\n    return ar[0].keys();\n  });\n  //(hashtable-entries hash)  ; => two vectors (keys, values)\n  define_libfunc(\"hashtable-entries\", 1, 1, function(ar){\n    assert_hashtable(ar[0]);\n    return new Values([ar[0].keys(), ar[0].values()]);\n  });\n\n  //13.3  Inspection\n\n  //(hashtable-equivalence-function hashtable)    procedure\n  define_libfunc(\"hashtable-equivalence-function\", 1, 1, function(ar){\n    assert_hashtable(ar[0]);\n    return ar[0].equiv_proc;\n  });\n  //(hashtable-hash-function hashtable)    procedure\n  define_libfunc(\"hashtable-hash-function\", 1, 1, function(ar){\n    assert_hashtable(ar[0]);\n    return ar[0].hash_proc;\n  });\n  //(hashtable-mutable? hashtable)    procedure\n  define_libfunc(\"hashtable-mutable?\", 1, 1, function(ar){\n    assert_hashtable(ar[0]);\n    return ar[0].mutable;\n  });\n\n  //13.4  Hash functions\n\n  //(equal-hash obj)    procedure\n  define_libfunc(\"equal-hash\", 0, 0, function(ar){\n    return Hashtable.equal_hash;\n  });\n  //(string-hash string)    procedure\n  define_libfunc(\"string-hash\", 0, 0, function(ar){\n    return Hashtable.string_hash;\n  });\n  //(string-ci-hash string)    procedure\n  define_libfunc(\"string-ci-hash\", 0, 0, function(ar){\n    return Hashtable.string_ci_hash;\n  });\n  //(symbol-hash symbol)    procedure\n  define_libfunc(\"symbol-hash\", 0, 0, function(ar){\n    return Hashtable.symbol_hash;\n  });\n\n  //\n  // Chapter 14 Enumerators\n  //\n  //(make-enumeration symbol-list) -> enum-set(new type)\n  define_libfunc(\"make-enumeration\", 1, 1, function(ar){\n    assert_list(ar[0]);\n    var members = ar[0].to_array();\n    var enum_type = new BiwaScheme.Enumeration.EnumType(members);\n    return enum_type.universe();\n  });\n\n  //(enum-set-universe enum-set) -> enum-set(same type as the argument)\n  define_libfunc(\"enum-set-universe\", 1, 1, function(ar){\n    assert_enum_set(ar[0]);\n    return ar[0].enum_type.universe();\n  });\n\n  //(enum-set-indexer enum-set) -> (lambda (sym)) -> integer or #f\n  define_libfunc(\"enum-set-indexer\", 1, 1, function(ar){\n    assert_enum_set(ar[0]);\n    return ar[0].enum_type.indexer();\n  });\n\n  //(enum-set-constructor enum-set) -> (lambda (syms)) -> enum-set(same type as the argument)\n  define_libfunc(\"enum-set-constructor\", 1, 1, function(ar){\n    assert_enum_set(ar[0]);\n    return ar[0].enum_type.constructor();\n  });\n\n  //(enum-set->list enum-set) -> symbol-list\n  define_libfunc(\"enum-set->list\", 1, 1, function(ar){\n    assert_enum_set(ar[0]);\n    return ar[0].symbol_list();\n  });\n\n  //(enum-set-member? symbol enum-set) -> bool\n  define_libfunc(\"enum-set-member?\", 2, 2, function(ar){\n    assert_symbol(ar[0]);\n    assert_enum_set(ar[1]);\n    return ar[1].is_member(ar[0]);\n  });\n\n  //(enum-set-subset? esa esb) -> bool\n  define_libfunc(\"enum-set-subset?\", 2, 2, function(ar){\n    assert_enum_set(ar[0]);\n    assert_enum_set(ar[1]);\n    return ar[0].is_subset(ar[1]);\n  });\n\n  //(enum-set=? esa esb) -> bool\n  define_libfunc(\"enum-set=?\", 2, 2, function(ar){\n    assert_enum_set(ar[0]);\n    assert_enum_set(ar[1]);\n    return ar[0].equal_to(ar[1]);\n  });\n\n  //(enum-set-union es1 es2) -> enum-set\n  define_libfunc(\"enum-set-union\", 2, 2, function(ar){\n    assert_enum_set(ar[0]);\n    assert_enum_set(ar[1]);\n    assert(ar[0].enum_type === ar[1].enum_type,\n           \"two enum-sets must be the same enum-type\", \"enum-set-union\");\n    return ar[0].union(ar[1]);\n  });\n\n  //(enum-set-intersection es1 es2) -> enum-set\n  define_libfunc(\"enum-set-intersection\", 2, 2, function(ar){\n    assert_enum_set(ar[0]);\n    assert_enum_set(ar[1]);\n    return ar[0].intersection(ar[1]);\n  });\n\n  //(enum-set-difference es1 es2) -> enum-set\n  define_libfunc(\"enum-set-difference\", 2, 2, function(ar){\n    assert_enum_set(ar[0]);\n    assert_enum_set(ar[1]);\n    return ar[0].difference(ar[1]);\n  });\n\n  //(enum-set-complement enum-set) -> enum-set\n  define_libfunc(\"enum-set-complement\", 1, 1, function(ar){\n    assert_enum_set(ar[0]);\n    return ar[0].complement();\n  });\n\n  //(enum-set-projection esa esb) -> enum-set\n  define_libfunc(\"enum-set-projection\", 2, 2, function(ar){\n    assert_enum_set(ar[0]);\n    assert_enum_set(ar[1]);\n    return ar[0].projection(ar[1]);\n  });\n\n  //(define-enumeration <type-name> (<symbol> ...) <constructor-syntax>)\n  // Example:\n  //   (define-enumeration color (red green black white) color-set)\n  //   this defines:\n  //     - an EnumType\n  //     - (color red) ;=> 'red\n  //     - (color-set red black) ;=> #<enum-set (red black)>\n  define_syntax(\"define-enumeration\", function(x){\n    // Extract parameters\n    var type_name = x.cdr.car;\n    assert(BiwaScheme.isSymbol(type_name),\n           \"expected symbol for type_name\", \"define-enumeration\");\n    type_name = type_name.name;\n\n    var members = x.cdr.cdr.car;\n    assert(BiwaScheme.isList(members),\n           \"expected list of symbol for members\", \"define-enumeration\");\n    members = members.to_array();\n\n    var constructor_name = x.cdr.cdr.cdr.car;\n    assert(BiwaScheme.isSymbol(constructor_name),\n           \"expected symbol for constructor_name\", \"define-enumeration\");\n    constructor_name = constructor_name.name;\n\n    // Define EnumType\n    var enum_type = new BiwaScheme.Enumeration.EnumType(members);\n\n    // Define (color red)\n    define_syntax(type_name, function(x){\n      // (color)\n      assert(!BiwaScheme.isNil(x.cdr),\n             \"an argument is needed\", type_name);\n\n      var arg = x.cdr.car;\n      assert_symbol(arg, type_name);\n\n      // Check arg is included in the universe\n      assert(_.include(enum_type.members, arg),\n        arg.name+\" is not included in the universe: \"+\n          BiwaScheme.to_write(enum_type.members),\n        type_name);\n\n      return BiwaScheme.List(Sym(\"quote\"), arg);\n    });\n\n    // Define (color-set red black)\n    define_syntax(constructor_name, function(x){\n      assert_list(x.cdr, constructor_name);\n\n      var symbols = x.cdr.to_array();\n\n      // Check each argument is included in the universe\n      _.each(symbols, function(arg){\n        assert_symbol(arg, constructor_name);\n        assert(_.include(enum_type.members, arg),\n          arg.name+\" is not included in the universe: \"+\n            BiwaScheme.to_write(enum_type.members),\n          constructor_name);\n      });\n\n      // Create an EnumSet\n      return new BiwaScheme.Enumeration.EnumSet(enum_type, symbols);\n    });\n  });\n\n  //\n  // Chapter 15 Composite library\n  //\n  //(rnrs 6) = all - eval - mutable pairs - mutable strings - r5rs compatibility\n\n  //\n  // Chapter 16 eval\n  //\n  //(eval expression environment)    procedure\n  define_libfunc(\"eval\", 1, 1, function(ar, intp){\n    //TODO: environment\n    //TODO: this implementation has a bug that\n    //  expressions which contains #<undef>, etc. cannot be evaluated.\n    var expr = ar[0];\n    var intp2 = new Interpreter(intp);\n    return intp2.evaluate(BiwaScheme.to_write(expr));\n  });\n//(environment import-spec ...)    procedure\n\n  //\n  // Chapter 17 Mutable pairs\n  //\n//(set-car! pair obj)    procedure\n//(set-cdr! pair obj)    procedure\n\n  //\n  // Chapter 18 Mutable strings\n  //\n  //(string-set! string k char)    procedure\n // (string-fill! string char)    procedure\n\n  //\n  // Chapter 19 R5RS compatibility\n  //\n//(exact->inexact z)    procedure\n//(inexact->exact z)    procedure\n//\n//(quotient n1 n2)    procedure\n//(remainder n1 n2)    procedure\n//(modulo n1 n2)    procedure\n//\n//(null-environment n)    procedure\n//(scheme-report-environment n)    procedure\n\n  //\n  // R7RS (TODO: split file?)\n  //\n\n  // R7RS Promise\n  //\n  // (delay expression)\n  define_syntax(\"delay\", function(x){\n    if (x.cdr === BiwaScheme.nil) {\n      throw new Error(\"malformed delay: no argument\");\n    }\n    if (x.cdr.cdr !== nil) {\n      throw new Error(\"malformed delay: too many arguments: \"+\n                      BiwaScheme.to_write_ss(x));\n    }\n    var expr = x.cdr.car;\n    // Expand into call of internal function\n    // ( procedure->promise (lambda () (make-promise expr)))\n    return new Pair(Sym(\" procedure->promise\"),\n             new Pair(new Pair(Sym(\"lambda\"),\n                        new Pair(BiwaScheme.nil,\n                          new Pair(new Pair(Sym(\"make-promise\"),\n                                     new Pair(expr, BiwaScheme.nil)),\n                            BiwaScheme.nil)))));\n  });\n\n  // (delay-force promise-expr)\n  define_syntax(\"delay-force\", function(x){\n    if (x.cdr === BiwaScheme.nil) {\n      throw new Error(\"malformed delay-force: no argument\");\n    }\n    if (x.cdr.cdr !== nil) {\n      throw new Error(\"malformed delay-force: too many arguments: \"+\n                      BiwaScheme.to_write_ss(x));\n    }\n    var expr = x.cdr.car;\n    // Expand into call of internal function\n    // ( procedure->promise (lambda () expr))\n    return new Pair(Sym(\" procedure->promise\"),\n             new Pair(new Pair(Sym(\"lambda\"),\n                        new Pair(BiwaScheme.nil,\n                          new Pair(expr, BiwaScheme.nil))), BiwaScheme.nil));\n  });\n\n  // (force promise)\n  var force = function(promise) {\n    if (promise.is_done()) {\n      return promise.value();\n    }\n    return new Call(promise.thunk(), [], function(ar) {\n      assert_promise(ar[0]);\n      var new_promise = ar[0];\n      if (promise.is_done()) {  // reentrant!\n        return promise.value();\n      }\n      else {\n        promise.update_with(new_promise);\n        return force(new_promise);\n      }\n    });\n  };\n  define_libfunc(\"force\", 1, 1, function(ar, intp){\n    assert_promise(ar[0]);\n    return force(ar[0]);\n  });\n\n  // (promise? obj)\n  define_libfunc(\"promise?\", 1, 1, function(ar, intp){\n    return (ar[0] instanceof BiwaScheme.Promise);\n  });\n\n  // (make-promise obj)\n  define_libfunc(\"make-promise\", 1, 1, function(ar, intp){\n    var obj = ar[0];\n    if (obj instanceof BiwaScheme.Promise) {\n      return obj;\n    }\n    else {\n      return BiwaScheme.Promise.done(obj);\n    }\n  });\n\n  // internal function\n  // ( procedure->promise proc)\n  // proc must be a procedure with no argument and return a promise\n  define_libfunc(\" procedure->promise\", 1, 1, function(ar, intp){\n    assert_procedure(ar[0]);\n    return BiwaScheme.Promise.fresh(ar[0]);\n  });\n}\nif( typeof(BiwaScheme)!='object' ) BiwaScheme={}; with(BiwaScheme) {\n\n  //\n  // interface to javascript\n  //\n  define_libfunc(\"js-eval\", 1, 1, function(ar){\n    return eval(ar[0]);\n  });\n  define_libfunc(\"js-ref\", 2, 2, function(ar){\n    if(_.isString(ar[1])){\n      return ar[0][ar[1]];\n    }\n    else{\n      assert_symbol(ar[1]);\n      return ar[0][ar[1].name];\n    }\n  });\n  define_libfunc(\"js-set!\", 3, 3, function(ar){\n    assert_string(ar[1]);\n    ar[0][ar[1]] = ar[2];\n    return BiwaScheme.undef;\n  });\n\n  // (js-call (js-eval \"Math.pow\") 2 4)\n  define_libfunc(\"js-call\", 1, null, function(ar){\n    var js_func = ar.shift();\n    assert_function(js_func);\n\n    var receiver = null;\n    return js_func.apply(receiver, ar);\n  });\n  // (js-invoke (js-new \"Date\") \"getTime\")\n  define_libfunc(\"js-invoke\", 2, null, function(ar){\n    var js_obj = ar.shift();\n    var func_name = ar.shift();\n    if(!_.isString(func_name)){\n      assert_symbol(func_name);\n      func_name = func_name.name;\n    }\n    if(js_obj[func_name])\n      return js_obj[func_name].apply(js_obj, ar);\n    else\n      throw new Error(\"js-invoke: function \"+func_name+\" is not defined\");\n  });\n\n  // Short hand for JavaScript method call.\n  //\n  // (js-invocation obj '(foo 1 2 3))  ;=> obj.foo(1,2,3)\n  // (js-invocation obj '(foo 1 2 3)   ;=> obj.foo(1,2,3)\n  //                    'bar           ;      .bar\n  //                    '(baz 4 5))    ;      .baz(4,5)\n  // (js-invocation 'Math '(pow 2 3))  ;=> Math.pow(2,3)\n  //\n  // It also converts\n  //   (lambda (e) ...) to\n  //   (js-closure (lambda (e) ...))\n  //   and\n  //   '((a . b) (c . 4)) to\n  //   {a: \"b\", c: 4}\n  //\n  define_libfunc(\"js-invocation\", 2, null, function(ar, intp){\n    var receiver = ar.shift();\n    // TODO: convert lambdas by js-closure \n    if(BiwaScheme.isSymbol(receiver)){\n      receiver = eval(receiver.name); //XXX: is this ok?\n    }\n\n    var v = receiver;\n\n    // Process each method call\n    _.each(ar, function(callspec){\n        if(BiwaScheme.isSymbol(callspec)){\n          // Property access\n          v = v[callspec.name];\n        }\n        else if(BiwaScheme.isList(callspec)){\n          // Method call\n          var args = callspec.to_array();\n\n          assert_symbol(args[0]);\n          var method = args.shift().name;\n\n          // Convert arguments\n          args = _.map(args, function(arg){\n              if(BiwaScheme.isClosure(arg)){\n                // closure -> JavaScript funciton\n                return BiwaScheme.js_closure(arg, intp);\n              }\n              else if(BiwaScheme.isList(arg)){\n                // alist -> JavaScript Object\n                var o = {};\n                arg.foreach(function(pair){\n                    assert_symbol(pair.car);\n                    o[pair.car.name] = pair.cdr;\n                  });\n                return o;\n              }\n              else\n                return arg;\n            });\n\n          // Call the method\n          if(!_.isFunction(v[method])){\n            throw new BiwaScheme.Error(\"js-invocation: the method `\"+method+\"' not found\");\n          }\n          v = v[method].apply(v, args);\n        }\n        else{\n          // (wrong argument)\n          throw new BiwaScheme.Error(\"js-invocation: expected list or symbol for callspec but got \" + BiwaScheme.inspect(callspec));\n        }\n      });\n\n    return v;\n  });\n\n  // TODO: provide corresponding macro \"..\" \n  define_syntax(\"..\", function(x){\n    if (x.cdr == nil) {\n      throw new Error(\"malformed ..\");\n    }\n    return new Pair(Sym(\"js-invocation\"), x.cdr);\n  });\n\n  // (js-new (js-eval \"Date\") 2005 1 1)\n  // (js-new (js-eval \"Draggable\") elem 'onEnd (lambda (drg) ...))\n  //   If symbol is given, following arguments are converted to \n  //   an js object. If any of them is a scheme closure,\n  //   it is converted to js function which invokes that closure.\n  //\n  // (js-new \"Date\" 2005 1 1)\n  //   You can pass javascript program string for constructor.\n  define_libfunc(\"js-new\", 1, null, function(ar, intp){\n    // make js object from key-value pair\n    var array_to_obj = function(ary){\n      if((ary.length % 2) != 0)\n        throw new Error(\"js-new: odd number of key-value pair\");\n\n      var obj = {};\n      for(var i=0; i<ary.length; i+=2){\n        var key = ary[i], value = ary[i+1];\n        assert_symbol(key);\n        if(value.closure_p === true)\n          value = BiwaScheme.js_closure(value, intp);\n\n        obj[key.name] = value;\n      }\n      return obj;\n    };\n\n    var ctor = ar.shift();\n    if (_.isString(ctor)) ctor = eval(ctor);\n\n    if(ar.length == 0){\n      return new ctor();\n    }\n    else{\n      // pack args to js object, if symbol appears\n      var args = [];\n      for(var i=0; i<ar.length; i++){\n        if(ar[i] instanceof Symbol){\n          args.push(array_to_obj(ar.slice(i)));\n          break;\n        }\n        else{\n          args.push(ar[i]);\n        }\n      }\n      // Run `new ctor(...args)`;\n      return new (Function.prototype.bind.apply(ctor, [null].concat(args)))();\n    }\n  });\n\n  // (js-obj \"foo\" 1 \"bar\" 2)\n  // -> {\"foo\": 1, \"bar\": 2}\n  define_libfunc(\"js-obj\", 0, null, function(ar){\n    if(ar.length % 2 != 0){\n      throw new Error(\"js-obj: number of arguments must be even\");\n    }\n\n    var obj = {};\n    for(i=0; i<ar.length/2; i++){\n      assert_string(ar[i*2]);\n      obj[ar[i*2]] = ar[i*2+1];\n    }\n    return obj;\n  });\n\n  BiwaScheme.js_closure = function(proc, intp){\n    var intp2 = new Interpreter(intp);\n    return function(/*args*/){\n      return intp2.invoke_closure(proc, _.toArray(arguments));\n    };\n  };\n  // (js-closure (lambda (event) ..))\n  // Returns a js function which executes the given procedure.\n  //\n  // Example\n  //   (add-handler! ($ \"#btn\") \"click\" (js-closure on-click))\n  define_libfunc(\"js-closure\", 1, 1, function(ar, intp){\n    assert_closure(ar[0]);\n    return BiwaScheme.js_closure(ar[0], intp);\n  });\n\n  define_libfunc(\"js-null?\", 1, 1, function(ar){\n    return ar[0] === null;\n  });\n\n  define_libfunc(\"js-undefined?\", 1, 1, function(ar){\n    return ar[0] === undefined;\n  });\n\n  define_libfunc(\"js-function?\", 1, 1, function(ar){\n    return _.isFunction(ar[0]);\n  });\n\n  define_libfunc(\"js-array-to-list\", 1, 1, function(ar){\n    BiwaScheme.deprecate(\"js-array-to-list\", \"1.0\", \"js-array->list\");\n    return BiwaScheme.array_to_list(ar[0]);\n  });\n\n  define_libfunc(\"js-array->list\", 1, 1, function(ar){\n    return BiwaScheme.array_to_list(ar[0]);\n  });\n\n  define_libfunc(\"list-to-js-array\", 1, 1, function(ar){\n    BiwaScheme.deprecate(\"list-to-js-array\", \"1.0\", \"list->js-array\");\n    return ar[0].to_array();\n  });\n\n  define_libfunc(\"list->js-array\", 1, 1, function(ar){\n    return ar[0].to_array();\n  });\n\n  BiwaScheme.alist_to_js_obj = function(alist) {\n    if (alist === nil) {\n      return {} ;\n    }\n    assert_list(alist);\n    var obj = {};\n    alist.foreach(function(item){\n      assert_string(item.car);\n      obj[item.car] = item.cdr;\n    });\n    return obj;\n  };\n  define_libfunc(\"alist-to-js-obj\", 1, 1, function(ar) {\n    BiwaScheme.deprecate(\"alist-to-js-obj\", \"1.0\", \"alist->js-obj\");\n    return BiwaScheme.alist_to_js_obj(ar[0]);\n  });\n\n  define_libfunc(\"alist->js-obj\", 1, 1, function(ar) {\n    return BiwaScheme.alist_to_js_obj(ar[0]);\n  });\n\n  BiwaScheme.js_obj_to_alist = function(obj) {\n    if (obj === undefined) {\n      return BiwaScheme.nil;\n    }\n    var arr = [];\n    _.each(obj, function(val, key) {\n      arr.push(new Pair(key, val));\n    });\n    var alist = BiwaScheme.array_to_list(arr);\n    return alist;\n  };\n  define_libfunc(\"js-obj-to-alist\", 1, 1, function(ar) {\n    BiwaScheme.deprecate(\"js-obj-to-alist\", \"1.0\", \"js-obj->alist\");\n    return BiwaScheme.js_obj_to_alist(ar[0]);\n  });\n  define_libfunc(\"js-obj->alist\", 1, 1, function(ar) {\n    return BiwaScheme.js_obj_to_alist(ar[0]);\n  });\n\n  //\n  // timer, sleep\n  //\n  define_libfunc(\"timer\", 2, 2, function(ar, intp){\n    var proc = ar[0], sec = ar[1];\n    assert_closure(proc);\n    assert_real(sec);\n    var intp2 = new Interpreter(intp);\n    setTimeout(function(){ intp2.invoke_closure(proc); }, sec * 1000);\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"set-timer!\", 2, 2, function(ar, intp){\n    var proc = ar[0], sec = ar[1];\n    assert_closure(proc);\n    assert_real(sec);\n    var intp2 = new Interpreter(intp);\n    return setInterval(function(){ intp2.invoke_closure(proc); }, sec * 1000);\n  });\n  define_libfunc(\"clear-timer!\", 1, 1, function(ar){\n    var timer_id = ar[0];\n    clearInterval(timer_id);\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"sleep\", 1, 1, function(ar){\n    var sec = ar[0];\n    assert_real(sec);\n    return new BiwaScheme.Pause(function(pause){\n      setTimeout(function(){ pause.resume(nil); }, sec * 1000);\n    });\n  });\n\n  //\n  // console\n  //\n  // (console-debug obj1 ...)\n  // (console-log obj1 ...)\n  // (console-info obj1 ...)\n  // (console-warn obj1 ...)\n  // (console-error obj1 ...)\n  //   Put objects to console, if window.console is defined.\n  //   Returns obj1.\n  //\n  // Example:\n  //     (some-func arg1 (console-debug arg2) arg3)\n  var define_console_func = function(name){\n    define_libfunc(\"console-\"+name, 1, null, function(ar){\n      var con = window.console;\n      if(con){\n        var vals = _.map(ar, function(item){\n          return BiwaScheme.inspect(item, {fallback: item});\n        });\n\n        con[name].apply(con, vals);\n      }\n      return ar[0];\n    });\n  };\n  define_console_func(\"debug\");\n  define_console_func(\"log\");\n  define_console_func(\"info\");\n  define_console_func(\"warn\");\n  define_console_func(\"error\");\n\n}\n\nif( typeof(BiwaScheme)!='object' ) BiwaScheme={}; with(BiwaScheme) {\n  define_libfunc(\"html-escape\", 1, 1, function(ar){\n    assert_string(ar[0]);\n    return _.escape(ar[0]);\n  });\n  BiwaScheme.inspect_objs = function(objs){\n    return _.map(objs, BiwaScheme.inspect).join(\", \");\n  };\n  define_libfunc(\"inspect\", 1, null, function(ar){\n    return BiwaScheme.inspect_objs(ar);\n  });\n  define_libfunc(\"inspect!\", 1, null, function(ar){\n    Console.puts(BiwaScheme.inspect_objs(ar));\n    return BiwaScheme.undef;\n  });\n\n  //\n  // json\n  //\n  // json->sexp\n  // Array -> list\n  // Object -> alist\n  // (number, boolean, string, \n  //\n  BiwaScheme.json2sexp = function(json){\n    switch(true){\n    case _.isNumber(json) ||\n         _.isString(json) ||\n         json === true || json === false:\n      return json;\n    case _.isArray(json):\n      return array_to_list(_.map(json, json2sexp));\n    case typeof(json) == \"object\":\n      var ls = nil;\n      for(key in json){\n        ls = new Pair(new Pair(key, json2sexp(json[key])),\n               ls);\n      }\n      return ls;\n    default:\n      throw new Error(\"json->sexp: detected invalid value for json: \"+BiwaScheme.inspect(json));\n    }\n    throw new Bug(\"must not happen\");\n  }\n  define_libfunc(\"json->sexp\", 1, 1, function(ar){\n    return json2sexp(ar[0]);\n  })\n\n  // (vector-push! v item1 item2 ...)\n  define_libfunc(\"vector-push!\", 2, null, function(ar){\n    assert_vector(ar[0]);\n    for(var i=1; i<ar.length; i++){\n      ar[0].push(ar[i]);\n    }\n    return ar[0];\n  });\n\n  //\n  //from Gauche\n  //\n\n  // (identity obj)\n  // Returns obj.\n  define_libfunc(\"identity\", 1, 1, function(ar){\n    return ar[0];\n  });\n\n  // (inc! i)\n  // = (begin (set! i (+ i 1)) i)\n  // Increments i (i.e., set i+1 to i).\n  define_syntax(\"inc!\", function(x){\n    var target = x.cdr.car;\n    return List(Sym(\"begin\"),\n                List(Sym(\"set!\"),\n                     target, \n                     List(Sym(\"+\"), target, 1)),\n                target);\n  });\n  \n  // (dec! i)\n  // = (begin (set! i (- i 1)) i)\n  // Decrements i (i.e., set i-1 to i).\n  define_syntax(\"dec!\", function(x){\n    var target = x.cdr.car;\n    return List(Sym(\"begin\"),\n                List(Sym(\"set!\"),\n                     target, \n                     List(Sym(\"-\"), target, 1)),\n                target);\n  });\n\n  // string\n  \n  define_libfunc(\"string-concat\", 1, 1, function(ar){\n    assert_list(ar[0]);\n    return ar[0].to_array().join(\"\");\n  })\n\n  define_libfunc(\"string-split\", 2, 2, function(ar){\n    assert_string(ar[0]);\n    assert_string(ar[1]);\n    return array_to_list(ar[0].split(ar[1]));\n  })\n\n  define_libfunc(\"string-join\", 1, 2, function(ar){\n    assert_list(ar[0]);\n    var delim = \"\"\n    if(ar[1]){\n      assert_string(ar[1]);\n      delim = ar[1];\n    }\n    return ar[0].to_array().join(delim);\n  })\n  \n  // lists\n\n  define_libfunc(\"intersperse\", 2, 2, function(ar){\n    var item = ar[0], ls = ar[1];\n    assert_list(ls);\n\n    var ret = [];\n    _.each(ls.to_array().reverse(),function(x){\n      ret.push(x);\n      ret.push(item);\n    });\n    ret.pop();\n    return array_to_list(ret);\n  });\n\n  define_libfunc(\"map-with-index\", 2, null, function(ar){\n    var proc = ar.shift(), lists = ar;\n    _.each(lists, assert_list);\n\n    var results = [], i = 0;\n    return Call.multi_foreach(lists, {\n      call: function(xs){ \n        var args = _.map(xs, function(x){ return x.car });\n        args.unshift(i);\n        i++;\n        return new Call(proc, args);\n      },\n      result: function(res){ results.push(res); },\n      finish: function(){ return array_to_list(results); }\n    });\n  });\n\n  // loop\n\n  // (dotimes (variable limit result) body ...)\n  // Iterate with variable 0 to limit-1.\n  // ->\n  //    (do ((tlimit limit)\n  //         (variable 0 (+ variable 1)))\n  //        ((>= variable tlimit) result)\n  //      body ...)\n  define_syntax(\"dotimes\", function(x){\n    var spec = x.cdr.car,\n        bodies = x.cdr.cdr;\n    var variable = spec.car,\n        limit = spec.cdr.car,\n        result = spec.cdr.cdr.car;\n    var tlimit = BiwaScheme.gensym();\n\n    var do_vars = deep_array_to_list([[tlimit, limit],\n                                      [variable, 0, [Sym(\"+\"), variable, 1]]]);\n    var do_check = deep_array_to_list([[Sym(\">=\"), variable, tlimit], result]);\n\n    return new Pair(Sym(\"do\"),\n             new Pair(do_vars,\n               new Pair(do_check,\n                 bodies)));\n  });\n\n  // sorting (Obsolete: use list-sort, etc. instead of these.)\n\n  // utility function. takes a JS Array and a Scheme procedure,\n  // returns sorted array\n  var sort_with_comp = function(ary, proc, intp){\n    return ary.sort(function(a, b){\n        var intp2 = new BiwaScheme.Interpreter(intp);\n        return intp2.invoke_closure(proc, [a, b]);\n      });\n  };\n\n  define_libfunc(\"list-sort/comp\", 1, 2, function(ar, intp){\n    assert_procedure(ar[0]);\n    assert_list(ar[1]);\n\n    return array_to_list(sort_with_comp(ar[1].to_array(), ar[0], intp));\n  });\n  define_libfunc(\"vector-sort/comp\", 1, 2, function(ar, intp){\n    assert_procedure(ar[0]);\n    assert_vector(ar[1]);\n\n    return sort_with_comp(_.clone(ar[1]), ar[0], intp);\n  });\n  define_libfunc(\"vector-sort/comp!\", 1, 2, function(ar, intp){\n    assert_procedure(ar[0]);\n    assert_vector(ar[1]);\n\n    sort_with_comp(ar[1], ar[0], intp);\n    return BiwaScheme.undef;\n  });\n  \n  // macros\n\n  //(define-macro (foo x y) body ...)\n  //(define-macro foo lambda)\n\n  var rearrange_args = function (expected, given) {\n    var args = [];\n    var dotpos = (new Compiler).find_dot_pos(expected);\n    if (dotpos == -1)\n      args = given;\n    else {\n      for (var i = 0; i < dotpos; i++) {\n        args[i] = given[i];\n      }\n      args[i] = array_to_list(given.slice(i));\n    }\n    return args;\n  }\n  define_syntax(\"define-macro\", function(x){\n    var head = x.cdr.car;\n    var expected_args;\n    if(head instanceof Pair){\n      var name = head.car;\n      expected_args = head.cdr;\n      var body = x.cdr.cdr;\n      var lambda = new Pair(Sym(\"lambda\"),\n                     new Pair(expected_args,\n                       body))\n    }\n    else{\n      var name = head;\n      var lambda = x.cdr.cdr.car;\n      expected_args = lambda.cdr.car;\n    }\n\n    //[close, n_frees, do_body, next]\n    var opc = Compiler.compile(lambda);\n    if(opc[1] != 0)\n      throw new Bug(\"you cannot use free variables in macro expander (or define-macro must be on toplevel)\")\n    var cls = [opc[2]];\n\n    TopEnv[name.name] = new Syntax(name.name, function(sexp){\n      var given_args = sexp.to_array();\n\n      given_args.shift();\n      \n      var intp = new Interpreter();\n      var args = rearrange_args(expected_args, given_args);\n      var result = intp.invoke_closure(cls, args);\n      return result;\n    });\n\n    return BiwaScheme.undef;\n  })\n\n  var macroexpand_1 = function(x){\n    if(x instanceof Pair){\n      if(x.car instanceof Symbol && TopEnv[x.car.name] instanceof Syntax){\n        var transformer = TopEnv[x.car.name];\n        x = transformer.transform(x);\n      }\n      else\n        throw new Error(\"macroexpand-1: `\" + to_write_ss(x) + \"' is not a macro\");\n    }\n    return x;\n  }\n  define_syntax(\"%macroexpand\", function(x){\n    var expanded = BiwaScheme.Interpreter.expand(x.cdr.car);\n    return List(Sym(\"quote\"), expanded);\n  });\n  define_syntax(\"%macroexpand-1\", function(x){\n    var expanded = macroexpand_1(x.cdr.car);\n    return List(Sym(\"quote\"), expanded);\n  });\n\n  define_libfunc(\"macroexpand\", 1, 1, function(ar){\n    return BiwaScheme.Interpreter.expand(ar[0]);\n  });\n  define_libfunc(\"macroexpand-1\", 1, 1, function(ar){\n    return macroexpand_1(ar[0]);\n  });\n\n  define_libfunc(\"gensym\", 0, 0, function(ar){\n    return BiwaScheme.gensym();\n  });\n  \n  // i/o\n\n  define_libfunc(\"print\", 1, null, function(ar){\n    _.map(ar, function(item){\n      Console.puts(to_display(item), true);\n    })\n    Console.puts(\"\"); //newline\n    return BiwaScheme.undef;\n  })\n  define_libfunc(\"write-to-string\", 1, 1, function(ar){\n    return to_write(ar[0]);\n  });\n  define_libfunc(\"read-from-string\", 1, 1, function(ar){\n    assert_string(ar[0]);\n    return Interpreter.read(ar[0]);\n  });\n  define_libfunc(\"port-closed?\", 1, 1, function(ar){\n    assert_port(ar[0]);\n    return !(ar[0].is_open);\n  });\n  //define_libfunc(\"with-input-from-port\", 2, 2, function(ar){\n  //define_libfunc(\"with-error-to-port\", 2, 2, function(ar){\n  define_libfunc(\"with-output-to-port\", 2, 2, function(ar){\n    var port = ar[0], proc = ar[1];\n    assert_port(port);\n    assert_procedure(proc);\n\n    var original_port = BiwaScheme.Port.current_output;\n    BiwaScheme.Port.current_output = port\n\n    return new Call(proc, [port], function(ar){\n      port.close();\n      BiwaScheme.Port.current_output = original_port;\n\n      return ar[0];\n    });\n  });\n  \n  // syntax\n  \n  define_syntax(\"let1\", function(x){\n    //(let1 vari expr body ...) \n    //=> ((lambda (var) body ...) expr)\n    var vari = x.cdr.car; \n    var expr = x.cdr.cdr.car;\n    var body = x.cdr.cdr.cdr;\n\n    return new Pair(new Pair(Sym(\"lambda\"),\n                      new Pair(new Pair(vari, nil),\n                        body)),\n             new Pair(expr, nil));\n  })\n\n  //\n  // Regular Expression\n  //\n  var assert_regexp = function(obj, fname){\n    if(!(obj instanceof RegExp))\n      throw new Error(fname + \": regexp required, but got \" + to_write(obj));\n  }\n\n  //Function: string->regexp string &keyword case-fold \n  define_libfunc(\"string->regexp\", 1, 1, function(ar){\n    assert_string(ar[0], \"string->regexp\");\n    return new RegExp(ar[0]); //todo: case-fold\n  })\n  //Function: regexp? obj \n  define_libfunc(\"regexp?\", 1, 1, function(ar){\n    return (ar[0] instanceof RegExp);\n  })\n  //Function: regexp->string regexp \n  define_libfunc(\"regexp->string\", 1, 1, function(ar){\n    assert_regexp(ar[0], \"regexp->string\");\n    return ar[0].toString().slice(1, -1); //cut '/' \n  })\n\n  define_libfunc(\"regexp-exec\", 2, 2, function(ar){\n    var rexp = ar[0];\n    if(_.isString(ar[0])){\n      rexp = new RegExp(ar[0]);\n    }\n    assert_regexp(rexp, \"regexp-exec\");\n    assert_string(ar[1], \"regexp-exec\");\n    var ret = rexp.exec(ar[1])\n    return (ret === null) ? false : array_to_list(ret);\n  })\n\n//  //Function: rxmatch regexp string \n//  define_libfunc(\"rxmatch\", 1, 1, function(ar){\n//    assert_regexp(ar[0], \"rxmatch\");\n//    assert_string(ar[1], \"rxmatch\");\n//    return ar[0].match(ar[1]);\n//  });\n  //Function: rxmatch-start match &optional (i 0) \n  //Function: rxmatch-end match &optional (i 0) \n  //Function: rxmatch-substring match &optional (i 0) \n  //Function: rxmatch-num-matches match   \n  //Function: rxmatch-after match &optional (i 0) \n  //Function: rxmatch-before match &optional (i 0) \n  //Generic application: regmatch &optional index \n  //Generic application: regmatch 'before &optional index \n  //Generic application: regmatch 'after &optional index \n  //Function: regexp-replace regexp string substitution \n  \n  // regexp-replace-all regexp string substitution \n  define_libfunc(\"regexp-replace-all\", 3, 3, function(ar){\n    var pat = ar[0];\n    if(_.isString(pat)){\n      var rexp = new RegExp(pat, \"g\")\n    }\n    else{\n      assert_regexp(pat);\n      var rexp = new RegExp(pat.source, \"g\")\n    }\n    assert_string(ar[1]);\n    assert_string(ar[2]);\n    return ar[1].replace(rexp, ar[2])\n  })\n  //Function: regexp-replace* string rx1 sub1 rx2 sub2 ... \n  //Function: regexp-replace-all* string rx1 sub1 rx2 sub2 ... \n  //Function: regexp-quote string \n  //Macro: rxmatch-let match-expr (var ...) form ... \n  //Macro: rxmatch-if match-expr (var ...) then-form else-form \n  //Macro: rxmatch-cond clause ... \n  //Macro: rxmatch-case string-expr clause ... \n\n}\n\n\n//\n// Library functions only work on Node.js\n// see also: test/node_functions.js\n//\n\n(function(){\n  if(BiwaScheme.on_node){\n    var node = {\n      fs: require('fs'),\n      path: require('path'),\n      process: process\n    };\n  }\n\n  // Defines library functions which only works on Node.\n  // - On Node: same as define_libfunc\n  // - On Browser: defines a stub libfunc which just raises Error\n  var define_node_libfunc = function(/*arguments*/){\n    var args = _.toArray(arguments);\n\n    if(BiwaScheme.on_node){\n      BiwaScheme.define_libfunc.apply(null, args);\n    }\n    else{\n      var func_name = args[0];\n      var func = function(ar){\n        throw new BiwaScheme.Error(\"the function '\"+func_name+\"' \"+\n          \"is not supported in the browser \"+\n          \"(works only on Node.js).\");\n      };\n      args.pop();\n      args.push(func);\n      BiwaScheme.define_libfunc.apply(null, args);\n    }\n  };\n\n  //\n  // Chapter 9 File System\n  //\n\n  //(file-exists? filename)    procedure \n  define_node_libfunc(\"file-exists?\", 1, 1, function(ar){\n    BiwaScheme.assert_string(ar[0]);\n    return node.fs.existsSync(ar[0]);\n  });\n\n  //(delete-file filename)    procedure \n  define_node_libfunc(\"delete-file\", 1, 1, function(ar){\n    BiwaScheme.assert_string(ar[0]);\n    node.fs.unlinkSync(ar[0]);\n    return BiwaScheme.undef;\n  });\n\n  //\n  // Chapter 10 Command-line access and exit values\n  //\n  \n  //(command-line)    procedure\n  define_node_libfunc(\"command-line\", 0, 0, function(ar){\n    return BiwaScheme.List.apply(null, node.process.argv);\n  });\n\n  //(exit)    procedure \n  //(exit obj)    procedure\n  define_node_libfunc(\"exit\", 0, 1, function(ar){\n    var obj = ar[0];\n    var code = _.isUndefined(obj) ? 0 :\n               (obj === false)    ? 1 :\n               Number(obj);\n\n    node.process.exit(code);\n  });\n\n  //\n  // srfi-98 (get-environment-variable)\n  //\n\n  // (get-environment-variable name) -> string or #f\n  define_node_libfunc(\"get-environment-variable\", 1, 1, function(ar){\n    BiwaScheme.assert_string(ar[0]);\n    var val = node.process.env[ar[0]];\n    return _.isUndefined(val) ? false : val;\n  });\n\n  // (get-environment-variables) -> alist of string ((\"key\" . \"value\"))\n  define_node_libfunc(\"get-environment-variables\", 0, 0, function(ar){\n    return BiwaScheme.js_obj_to_alist(node.process.env);\n  });\n\n})();\n//\n// srfi.js - SRFI libraries\n//\n// should be src/library/srfi/1.js, etc (in the future).\n//\n\nwith(BiwaScheme) {\n  \n  //\n  // srfi-1 (list)\n  //\n  // (iota count start? step?)\n  define_libfunc(\"iota\", 1, 3, function(ar){\n    var count = ar[0];\n    var start = ar[1] || 0;\n    var step = (ar[2]===undefined) ? 1 : ar[2];\n    assert_integer(count);\n    assert_number(start);\n    assert_number(step);\n\n    var a = [], n = start;\n    for(var i=0; i<count; i++){\n      a.push(n);\n      n += step;\n    }\n    return array_to_list(a);\n  });\n\n  var copy_pair = function(pair){\n    var car = BiwaScheme.isPair(pair.car) ? copy_pair(pair.car)\n                                          : pair.car;\n    var cdr = BiwaScheme.isPair(pair.cdr) ? copy_pair(pair.cdr)\n                                          : pair.cdr;\n    return new Pair(car, cdr);\n  };\n  // (list-copy list)\n  define_libfunc(\"list-copy\", 1, 1, function(ar){\n    if(BiwaScheme.isPair(ar[0])){\n      return copy_pair(ar[0]);\n    }\n    else{\n      return BiwaScheme.nil;\n    }\n  });\n\n  //\n  // srfi-6 & Gauche (string port)\n  // \n  define_libfunc(\"open-input-string\", 1, 1, function(ar){\n    assert_string(ar[0]);\n    return new Port.StringInput(ar[0]);\n  })\n  define_libfunc(\"open-output-string\", 0, 0, function(ar){\n    return new Port.StringOutput();\n  })\n  define_libfunc(\"get-output-string\", 1, 1, function(ar){\n    assert_port(ar[0]);\n    if(!(ar[0] instanceof Port.StringOutput))\n      throw new Error(\"get-output-string: port must be made by 'open-output-string'\");\n    return ar[0].output_string();\n  })\n\n  //\n  // srfi-8 (receive)\n  //\n\n  // (receive <formals> <expression> <body>...)\n  // -> (call-with-values (lambda () expression)\n  //                        (lambda formals body ...))\n  define_syntax(\"receive\", function(x){\n    assert(BiwaScheme.isPair(x.cdr),\n           \"missing formals\", \"receive\");\n    var formals = x.cdr.car;\n    assert(BiwaScheme.isPair(x.cdr.cdr),\n           \"missing expression\", \"receive\");\n    var expression = x.cdr.cdr.car;\n    var body       = x.cdr.cdr.cdr;\n    \n    return deep_array_to_list([Sym(\"call-with-values\"),\n      [Sym(\"lambda\"), BiwaScheme.nil, expression],\n      new BiwaScheme.Pair(Sym(\"lambda\"),\n        new BiwaScheme.Pair(formals, body))]);\n  });\n\n  // srfi-19 (time)\n  //\n//  // constants\n//time-duration\n//time-monotonic\n//time-process\n//time-tai\n//time-thread\n//time-utc\n  // Current time and clock resolution\n  // (current-date [tz-offset])\n  define_libfunc(\"current-date\", 0, 1, function(ar){\n    //todo: tz-offset (ar[1])\n    return new Date();\n  })\n//\n//current-julian-day -> jdn\n//current-modified-julian-day -> mjdn\n//current-time [time-type] -> time\n//time-resolution [time-type] -> integer\n//  // Time object and accessors\n//make-time type nanosecond second -> time\n//time? object -> boolean\n//time-type time -> time-type\n//time-nanosecond time -> integer\n//time-second time -> integer\n//set-time-type! time time-type\n//set-time-nanosecond! time integer\n//set-time-second! time integer\n//copy-time time1 -> time2 \n//  // Time comparison procedures\n//time<=? time1 time2 -> boolean\n//time<? time1 time2 -> boolean\n//time=? time1 time2 -> boolean\n//time>=? time1 time2 -> boolean\n//time>? time1 time2 -> boolean\n//  // Time arithmetic procedures\n//time-difference time1 time2 -> time-duration\n//time-difference! time1 time2 -> time-duration\n//add-duration time1 time-duration -> time\n//add-duration! time1 time-duration -> time\n//subtract-duration time1 time-duration -> time\n//subtract-duration! time1 time-duration -> time\n  // Date object and accessors\n  // make-date\n  define_libfunc(\"date?\", 1, 1, function(ar){\n    return (ar[0] instanceof Date);\n  })\n  define_libfunc(\"date-nanosecond\", 1, 1, function(ar){\n    assert_date(ar[0]);\n    return ar[0].getMilliseconds() * 1000000;\n  })\n  define_libfunc(\"date-millisecond\", 1, 1, function(ar){ // not srfi-19\n    assert_date(ar[0]);\n    return ar[0].getMilliseconds();\n  })\n  define_libfunc(\"date-second\", 1, 1, function(ar){\n    assert_date(ar[0]);\n    return ar[0].getSeconds();\n  })\n  define_libfunc(\"date-minute\", 1, 1, function(ar){\n    assert_date(ar[0]);\n    return ar[0].getMinutes();\n  })\n  define_libfunc(\"date-hour\", 1, 1, function(ar){\n    assert_date(ar[0]);\n    return ar[0].getHours();\n  })\n  define_libfunc(\"date-day\", 1, 1, function(ar){\n    assert_date(ar[0]);\n    return ar[0].getDate();\n  })\n  define_libfunc(\"date-month\", 1, 1, function(ar){\n    assert_date(ar[0]);\n    return ar[0].getMonth() + 1; //Jan = 0 in javascript..\n  })\n  define_libfunc(\"date-year\", 1, 1, function(ar){\n    assert_date(ar[0]);\n    return ar[0].getFullYear();\n  })\n  //date-zone-offset\n  //date-year-day\n  define_libfunc(\"date-week-day\", 1, 1, function(ar){\n    assert_date(ar[0]);\n    return ar[0].getDay();\n  })\n  //date-week-number\n\n  // Time/Date/Julian Day/Modified Julian Day Converters\n  // (snipped)\n  \n  // Date to String/String to Date Converters\n  // TODO: support locale\n  //   * date_names\n  //   * ~f 5.2 sec\n  //   * ~p AM/PM\n  //   * ~X 2007/01/01\n  BiwaScheme.date_names = {\n    weekday: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    full_weekday: [\"Sunday\", \"Monday\", \"Tuesday\", \n      \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    month: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \n      \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n    full_month: [\"January\", \"February\", \"March\", \"April\",\n      \"May\", \"June\", \"July\", \"August\", \"September\", \n      \"Octorber\", \"November\", \"December\"]\n  }\n\n  BiwaScheme.date2string = function(date, format){\n    var zeropad  = function(n){ return n<10 ? \"0\"+n : \"\"+n }; \n    var spacepad = function(n){ return n<10 ? \" \"+n : \"\"+n }; \n    \n    var getter = {\n      a: function(x){ return date_names.weekday[x.getDay()] },\n      A: function(x){ return date_names.full_weekday[x.getDay()] },\n      b: function(x){ return date_names.month[x.getMonth()] },\n      B: function(x){ return date_names.full_month[x.getMonth()] },\n      c: function(x){ return x.toString() },\n      d: function(x){ return zeropad(x.getDate()) },\n      D: function(x){ return getter.d(x) + getter.m(x) + getter.y(x); },\n      e: function(x){ return spacepad(x.getDate()) },\n      f: function(x){ return x.getSeconds() + x.getMilliseconds()/1000; },\n      h: function(x){ return date_names.month[x.getMonth()] },\n      H: function(x){ return zeropad(x.getHours()) },\n      I: function(x){ var h = x.getHours(); return zeropad(h<13 ? h : h-12) },\n      j: function(x){ throw new Bug(\"not implemented: day of year\") },\n      k: function(x){ return spacepad(x.getHours()) },\n      l: function(x){ var h = x.getHours(); return spacepad(h<13 ? h : h-12) },\n      m: function(x){ return zeropad(x.getMonth()+1) },\n      M: function(x){ return zeropad(x.getMinutes()) },\n      n: function(x){ return \"\\n\" },\n      N: function(x){ throw new Bug(\"not implemented: nanoseconds\") },\n      p: function(x){ return x.getHours()<13 ? \"AM\" : \"PM\" },\n      r: function(x){ return getter.I(x) + \":\" + getter.M(x) + \":\" + getter.S(x) + \" \" + getter.p(x) },\n      s: function(x){ return Math.floor(x.getTime() / 1000) },\n      S: function(x){ return zeropad(x.getSeconds()) },\n      t: function(x){ return \"\\t\" },\n      T: function(x){ return getter.H(x) + \":\" + getter.M(x) + \":\" + getter.S(x) },\n      U: function(x){ throw new Bug(\"not implemented: weeknum(0~, Sun)\") },\n      V: function(x){ throw new Bug(\"not implemented: weeknum(1~, Sun?)\") },\n      w: function(x){ return x.getDay() },\n      W: function(x){ throw new Bug(\"not implemented: weeknum(0~, Mon)\") },\n      x: function(x){ throw new Bug(\"not implemented: weeknum(1~, Mon)\") },\n      X: function(x){ return getter.Y(x) + \"/\" + getter.m(x) + \"/\" + getter.d(x) },\n      y: function(x){ return x.getFullYear() % 100 },\n      Y: function(x){ return x.getFullYear() },\n      z: function(x){ throw new Bug(\"not implemented: time-zone\") },\n      Z: function(x){ throw new Bug(\"not implemented: symbol time zone\") },\n      1: function(x){ throw new Bug(\"not implemented: ISO-8601 year-month-day format\") },\n      2: function(x){ throw new Bug(\"not implemented: ISO-8601 hour-minute-second-timezone format\") },\n      3: function(x){ throw new Bug(\"not implemented: ISO-8601 hour-minute-second format\") },\n      4: function(x){ throw new Bug(\"not implemented: ISO-8601 year-month-day-hour-minute-second-timezone format\") },\n      5: function(x){ throw new Bug(\"not implemented: ISO-8601 year-month-day-hour-minute-second format\") }\n    }\n\n    return format.replace(/~([\\w1-5~])/g, function(str, x){\n      var func = getter[x];\n      if(func)\n        return func(date);\n      else if(x == \"~\")\n        return \"~\";\n      else\n        return x;\n    })\n  }\n  \n  // date->string date template\n  define_libfunc(\"date->string\", 1, 2, function(ar){\n    assert_date(ar[0]);\n\n    if(ar[1]){\n      assert_string(ar[1]);\n      return date2string(ar[0], ar[1]);\n    }\n    else\n      return ar[0].toString();\n  })\n  // string->date\n\n  // parse-date date\n  define_libfunc(\"parse-date\", 1, 1, function(ar){ // not srfi-19\n    assert_string(ar[0]);\n    return new Date(Date.parse(ar[0]));\n  })\n\n  //\n  // srfi-27\n  //\n  define_libfunc(\"random-integer\", 1, 1, function(ar){\n    var n = ar[0];\n    assert_integer(n);\n    if (n < 0)\n      throw new Error(\"random-integer: the argument must be >= 0\");\n    else\n      return Math.floor(Math.random() * ar[0]);\n  });\n  define_libfunc(\"random-real\", 0, 0, function(ar){\n    return Math.random();\n  });\n\n  //\n  // srfi-28 (format)\n  //\n\n  // (format format-str obj1 obj2 ...) -> string\n  // (format #f format-str ...) -> string\n  // (format #t format-str ...) -> output to current port \n  // (format port format-str ...) -> output to the port \n  //   ~a: display\n  //   ~s: write\n  //   ~%: newline\n  //   ~~: tilde\n  define_libfunc(\"format\", 1, null, function(ar){\n    if (_.isString(ar[0])) {\n      var port = null, format_str = ar.shift();\n    }\n    else if (ar[0] === false) {\n      ar.shift();\n      var port = null, format_str = ar.shift();\n    }\n    else if (ar[0] === true) {\n      ar.shift();\n      var port = BiwaScheme.Port.current_output,\n          format_str = ar.shift();\n    }\n    else {\n      var port = ar.shift(), format_str = ar.shift();\n      assert_port(port);\n    }\n\n    var str = format_str.replace(/~[as]/g, function(matched){\n                 assert(ar.length > 0,\n                        \"insufficient number of arguments\", \"format\");\n                 if (matched == \"~a\")\n                   return BiwaScheme.to_display(ar.shift());\n                 else\n                   return BiwaScheme.to_write(ar.shift());\n              }).replace(/~%/, \"\\n\")\n                .replace(/~~/, \"~\");\n    if (port) {\n      port.put_string(str);\n      return BiwaScheme.undef;\n    }\n    else {\n      return str;\n    }\n  });\n  \n  //\n  // srfi-38 (write/ss)\n  //\n  var user_write_ss = function(ar){\n    Console.puts(write_ss(ar[0]), true);\n    return BiwaScheme.undef;\n  }\n  define_libfunc(\"write/ss\", 1, 2, user_write_ss);\n  define_libfunc(\"write-with-shared-structure\", 1, 2, user_write_ss);\n  define_libfunc(\"write*\", 1, 2, user_write_ss); //from Gauche(STklos)\n\n  //\n  // srfi-43 (vector library)\n  //\n  define_libfunc(\"vector-append\", 2, null, function(ar){\n    var vec = [];\n    return vec.concat.apply(vec, ar);\n  });\n\n  // (vector-copy vector)\n  define_libfunc(\"vector-copy\", 1, 1, function(ar){\n    assert_vector(ar[0]);\n    return _.clone(ar[0]);\n  });\n\n  //\n  // see src/library/node_functions.js for:\n  // - srfi-98 (get-environment-variable)\n  //\n}\nif( typeof(BiwaScheme)!='object' ) BiwaScheme={}; with(BiwaScheme) {\n\n  define_libfunc(\"read-line\", 0, 1, function(ar){\n    var port = ar[0] || Port.current_input;\n    assert_port(port);\n    return port.get_string();\n  });\n\n  //\n  // element\n  //\n  define_libfunc(\"element-empty!\", 1, 1, function(ar){\n    if ($(ar[0]).attr(\"value\")) {\n      return $(ar[0]).val(\"\");\n    } else {\n      return $(ar[0]).empty();\n    }\n  });\n  alias_libfunc(\"element-empty!\", \"element-clear!\");\n  define_libfunc(\"element-visible?\", 1, 1, function(ar){\n    return $(ar[0]).is(\":visible\");\n  });\n  define_libfunc(\"element-toggle!\", 1, 1, function(ar){\n    return $(ar[0]).toggle();\n  });\n  define_libfunc(\"element-hide!\", 1, 1, function(ar){\n    return $(ar[0]).hide();\n  });\n  define_libfunc(\"element-show!\", 1, 1, function(ar){\n    return $(ar[0]).show();\n  });\n  define_libfunc(\"element-remove!\", 1, 1, function(ar){\n    return $(ar[0]).remove();\n  });\n  define_libfunc(\"element-update!\", 2, 2, function(ar){\n    return $(ar[0]).html(ar[1]);\n  });\n  define_libfunc(\"element-replace!\", 2, 2, function(ar){\n    return $(ar[0]).replaceWith(ar[1]);\n  });\n  define_libfunc(\"element-insert!\", 2, 2, function(ar){\n    return $(ar[0]).append(ar[1]);\n  });\n  define_libfunc(\"element-wrap!\", 3, 3, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-ancestors\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-descendants\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-first-descendant\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-immediate-descendants\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-previous-sibling\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-next-sibling\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-siblings\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-match?\", 2, 2, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-up\", 3, 3, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-down\", 3, 3, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-previous\", 3, 3, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-next\", 3, 3, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-select\", 1, 1, function(ar){\n    $(ar[0]).select();\n  });\n  define_libfunc(\"element-adjacent\", 0, 0, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-identify\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-read-attribute\", 2, 2, function(ar){\n    assert_string(ar[1]);\n    return $(ar[0]).attr(ar[1]);\n  });\n\n  var element_write_attribute = function(ar) {\n    assert_string(ar[1]);\n    return $(ar[0]).attr(ar[1], ar[2]);\n  };\n  define_libfunc(\"element-write-attribute\", 3, 3, function(ar){\n    BiwaScheme.deprecate(\"element-write-attribute\", \"1.0\",\n                         \"element-write-attribute!\");\n    return element_write_attribute(ar);\n  });\n  define_libfunc(\"element-write-attribute!\", 3, 3, element_write_attribute);\n\n  define_libfunc(\"element-height\", 1, 1, function(ar){\n    return $(ar[0]).height();\n  });\n  define_libfunc(\"element-width\", 1, 1, function(ar){\n    return $(ar[0]).width();\n  });\n\n  define_libfunc(\"element-class-names\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-has-class-name?\", 2, 2, function(ar){\n    assert_string(ar[1]);\n    return $(ar[0]).hasClass(ar[1]);\n  });\n\n  var element_add_class_name = function(ar) {\n    assert_string(ar[1]);\n    return $(ar[0]).addClass(ar[1]);\n  };\n  define_libfunc(\"element-add-class-name\", 2, 2, function(ar){\n    BiwaScheme.deprecate(\"element-add-class-name\", \"1.0\",\n                         \"element-add-class-name!\");\n    return element_add_class_name(ar);\n  });\n  define_libfunc(\"element-add-class-name!\", 2, 2, element_add_class_name);\n\n  var element_remove_class_name = function(ar) {\n    assert_string(ar[1]);\n    return $(ar[0]).removeClass(ar[1]);\n  };\n  define_libfunc(\"element-remove-class-name\", 2, 2, function(ar){\n    BiwaScheme.deprecate(\"element-remove-class-name\", \"1.0\",\n                         \"element-remove-class-name!\");\n    return element_remove_class_name(ar);\n  });\n  define_libfunc(\"element-remove-class-name!\", 2, 2, element_remove_class_name);\n\n  var element_toggle_class_name = function(ar) {\n    assert_string(ar[1]);\n    return $(ar[0]).toggleClass(ar[1]);\n  };\n  define_libfunc(\"element-toggle-class-name\", 2, 2, function(ar){\n    BiwaScheme.deprecate(\"element-toggle-class-name\", \"1.0\",\n                         \"element-toggle-class-name!\");\n    return element_toggle_class_name(ar);\n  });\n  define_libfunc(\"element-toggle-class-name!\", 2, 2, element_toggle_class_name);\n\n  define_libfunc(\"element-clean-whitespace!\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-empty?\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-descendant-of!\", 2, 2, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"scroll-to-element!\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-style\", 2, 2, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-opacity\", 2, 2, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-style-set!\", 2, 2, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-opacity-set!\", 2, 2, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-dimensions\", 1, 1, function(ar){\n    return new Values($(ar[0]).width(), $(ar[0]).height());\n  });\n  define_libfunc(\"element-make-positioned!\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-undo-positioned!\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-make-clipping!\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-undo-clipping!\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-cumulative-offset\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-positioned-offset\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-absolutize!\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-relativize!\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-cumulative-scroll-offset\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-offset-parent\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-viewport-offset\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-clone-position!\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-absolutize!\", 1, 1, function(ar){\n    throw new Bug(\"not yet implemented\");\n  });\n  define_libfunc(\"element-focus!\", 1, 1, function(ar){\n    return $(ar[0]).focus();\n  });\n\n  // usage:\n  //  (element-new '(div \"foo\"))        => <div>foo</div>\n  //  (element-new '(\"div#main\" \"foo\")) => <div id='main'>foo</div>\n  //  (element-new '(\"div.red\" \"foo\"))  => <div class='red'>foo</div>\n  //  (element-new '(div align \"right\" \"foo\"))  => <div align='right'>foo</div>\n  //  (element-new '(div (span \"foo\"))  => <div><span>foo</span></div>\n  //\n\n  BiwaScheme.create_elements_by_string = function(spec){\n    spec = spec.to_array();\n    var name = spec.shift();\n    if(name instanceof Symbol) name = name.name;\n    var m = name.match(/(.*)\\.(.*)/);\n    if (m) {\n      name = m[1];\n      spec.unshift(Sym(\"class\"), m[2]);\n    }\n    m = name.match(/(.*)\\#(.*)/);\n    if (m) {\n      name = m[1];\n      spec.unshift(Sym(\"id\"), m[2]);\n    }\n    var children = [];\n    var s = [\"<\" + name];\n    for(var i=0; i<spec.length; i++){\n      if(spec[i] instanceof Symbol){\n        s.push(' ' + spec[i].name + '=\"' + spec[i+1] + '\"');\n        i++;\n      }\n      else{\n        if(spec[i] instanceof Pair)\n          children.push(create_elements_by_string(spec[i]));\n        else\n          children.push(spec[i]); // String\n      }\n    }\n    s.push(\">\");\n    s.push( children.join(\"\") );\n    s.push(\"</\" + name + \">\");\n    return s.join(\"\");\n  };\n\n  BiwaScheme.tree_all = function(tree, pred){\n    if(tree === nil)\n      return true;\n    else if(pred(tree.car) === false)\n      return false;\n    else\n      return BiwaScheme.tree_all(tree.cdr, pred); \n  };\n  define_libfunc(\"element-new\", 1, 1, function(ar){\n    var string_or_symbol = function(item){\n      return _.isString(item) ||\n             (item instanceof Symbol) ||\n             (item instanceof Pair);\n    };\n    if(BiwaScheme.tree_all(ar[0], string_or_symbol)){\n      return $(create_elements_by_string(ar[0]))[0];\n    } else {\n      return nil;\n    }\n  });\n  BiwaScheme.element_content = function(selector) {\n    if ($(selector).attr(\"value\")) {\n      return $(selector).val();\n    } else {\n      return _.escape($(selector).html());\n    }\n  };\n  define_libfunc(\"element-content\", 1, 1, function(ar){\n    return BiwaScheme.element_content(ar[0]);\n  });\n\n  //\n  // load from network\n  //\n  define_libfunc(\"load\", 1, 1, function(ar, intp){\n    var path = ar[0];\n    assert_string(path);\n    var intp2 = new Interpreter(intp);\n    return new BiwaScheme.Pause(function(pause){\n      $.ajax(path, {\n        dataType: \"text\",\n        mimeType: \"text/plain; charset=x-user-defined\", // For Firefox (#88)\n        success: function(data) {\n          // create new interpreter not to destroy current stack.\n          intp2.evaluate(data,\n                         function(){\n                           return pause.resume(BiwaScheme.undef);\n                         });\n        },\n        error: function() {\n          throw new Error(\"load: network error: failed to load \"+path);\n        }\n      });\n    });\n  });\n\n  // Load javascript file on the server\n  _require = function(src, check, proc){\n    var script = $(\"<script/>\", { src: src });\n    $(\"body\").append(script);\n\n    var checker = new Function(\"return !!(\" + check + \")\");\n\n    if(checker()) proc();\n    else          setTimeout(function(){ checker() ? proc() : setTimeout(arguments.callee, 10); }, 10);\n  };\n  // (js-load \"lib/foo.js\" \"Foo\")\n  define_libfunc(\"js-load\", 2, 2, function(ar){\n    var path = ar[0];\n    var check = ar[1];\n    assert_string(path);\n    assert_string(check);\n\n    return new BiwaScheme.Pause(function(pause){\n      _require(path, \"window.\" + check, function(){\n        pause.resume(BiwaScheme.undef);\n      });\n    });\n  });\n\n  //\n  // html modification\n  //\n\n  BiwaScheme.getelem = function(ar){\n    // account for getelem returning false when no results (and that getting passed back in)\n    if (ar.length > 1 && ar[1] === false) {\n      ar[1] = [];\n    }\n\n    var x = $.apply(this, ar);\n    if (x.length > 0) {\n      return x;\n    } else {\n      return false;\n    }\n  };\n  define_libfunc(\"$\",       1, 2, BiwaScheme.getelem);\n  define_libfunc(\"getelem\", 1, 2, BiwaScheme.getelem);\n  define_libfunc(\"dom-element\", 1, 1, function(ar) {\n    return $(ar[0])[0];\n  });\n\n  define_libfunc(\"set-style!\", 3, 3, function(ar){\n    assert_string(ar[1]);\n    $(ar[0]).css(ar[1], ar[2]);\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"get-style\", 2, 2, function(ar){\n    assert_string(ar[1]);\n    return $(ar[0]).css(ar[1]);\n  });\n  define_libfunc(\"set-content!\", 2, 2, function(ar){\n    assert_string(ar[1]);\n    var str = ar[1].replace(/\\n/g,\"<br>\").replace(/\\t/g,\"&nbsp;&nbsp;&nbsp;\");\n    $(ar[0]).html(str);\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"get-content\", 1, 1, function(ar){\n    return BiwaScheme.element_content(ar[0]);\n  });\n\n  //\n  // handlers\n  //\n  define_libfunc(\"set-handler!\", 3, 3, function(ar, intp){\n    throw new Error(\"set-handler! is obsolete, please use add-handler! instead\");\n  });\n  define_libfunc(\"add-handler!\", 3, 3, function(ar, intp){\n    var selector = ar[0], evtype = ar[1], proc = ar[2];\n    var intp2 = new Interpreter(intp);\n    var handler = function(event){\n      return _.clone(intp2).invoke_closure(proc, [event]);\n    };\n    $(selector).on(evtype, handler);\n    return handler;\n  });\n  define_libfunc(\"remove-handler!\", 3, 3, function(ar, intp){\n    var selector = ar[0], evtype = ar[1], handler = ar[2];\n    $(selector).off(evtype, handler);\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"wait-for\", 2, 2, function(ar){\n    var selector = ar[0], evtype = ar[1];\n    var elem = $(selector);\n    elem.biwascheme_wait_for = elem.biwascheme_wait_for || {};\n\n    var prev_handler = elem.biwascheme_wait_for[evtype];\n    if (prev_handler) {\n      // Maybe a wait-for is called more than once,\n      // and previous handler is not consumed.\n      elem.off(evtype, prev_handler);\n    }\n\n    return new BiwaScheme.Pause(function(pause){\n      var handler = function(event){\n        elem.biwascheme_wait_for[evtype] = undefined;\n        elem.off(evtype, handler);\n        return pause.resume(event);\n      };\n\n      elem.biwascheme_wait_for[evtype] = handler;\n      elem.on(evtype, handler);\n    });\n  });\n\n  //\n  // dom\n  //\n  define_libfunc(\"domelem\", 1, null, function(ar){\n    throw new Error(\"obsolete\");\n  });\n  define_libfunc(\"dom-remove-children!\", 1, 1, function(ar){\n    Console.puts(\"warning: dom-remove-children! is obsolete. use element-empty! instead\");\n    $(ar[0]).empty();\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"dom-create-element\", 1, 1, function(ar){\n    throw new Error(\"obsolete\");\n  });\n  define_libfunc(\"element-append-child!\", 2, 2, function(ar){\n    return $(ar[0]).append(ar[1]);\n  });\n  define_libfunc(\"dom-remove-child!\", 2, 2, function(ar){\n    throw new Error(\"obsolete\");\n  });\n//  define_libfunc(\"dom-get-attribute\", 2, 2, function(ar){\n//  });\n//  define_libfunc(\"dom-remove-child!\", 2, 2, function(ar){\n//  });\n\n  //\n  // communication to server\n  //\n  define_libfunc(\"http-request\", 1, 1, function(ar){\n    var path = ar[0];\n    assert_string(path);\n\n    return new BiwaScheme.Pause(function(pause){\n      $.get(path, function(data) {\n        pause.resume(data);\n      }, \"text\");\n    });\n  });\n  // (http-post \"/foo\" '((\"x\" . 1) (\"y\" . 2)))\n  define_libfunc(\"http-post\", 2, 2, function(ar){\n    var path = ar[0];\n    assert_string(path);\n    var alist = ar[1];\n    assert_list(alist);\n    var h = alist_to_js_obj(alist);\n\n    return new BiwaScheme.Pause(function(pause){\n      $.post(path, h, function(data) {\n        pause.resume(data);\n      }, \"text\");\n    });\n  });\n\n  BiwaScheme.jsonp_receiver = [];\n  define_libfunc(\"receive-jsonp\", 1, 1, function(ar){\n    var url = ar[0];\n    assert_string(url);\n\n    var receives = BiwaScheme.jsonp_receiver;\n    for(var i=0; i<receives.length; i++)\n      if(receives[i] === null) break;\n    var receiver_id = i;\n    url += \"?callback=BiwaScheme.jsonp_receiver[\" + receiver_id + \"]\";\n\n    return new BiwaScheme.Pause(function(pause){\n      receives[receiver_id] = function(data){\n        pause.resume(data);\n        receives[receiver_id] = null;\n      };\n      var script = $(\"<script/>\", { src: url });\n      $(\"body\").append(script);\n    });\n  });\n\n  //\n  // dialog, debug\n  //\n  define_libfunc(\"alert\", 1, 1, function(ar){\n    alert(ar[0]);\n    return BiwaScheme.undef;\n  });\n  define_libfunc(\"confirm\", 1, 1, function(ar){\n    return confirm(ar[0]);\n  });\n//  define_libfunc(\"dumpobj\", 1, 1, function(ar){\n//    return eval(ar[0]);\n//  });\n\n}\n//\n// Dumper - graphical state dumper\n//\nwith(BiwaScheme) {\n\nBiwaScheme.Dumper = BiwaScheme.Class.create({\n  initialize: function(dumparea){\n    this.dumparea = dumparea || $(\"#dumparea\")[0] || null;\n    this.reset();\n  },\n\n  reset: function(){\n    if(this.dumparea){\n      // Note: this is for repl.html (needs refactoring..)\n      $(this.dumparea).empty();\n    }\n    this.n_folds = 0;\n    this.closures = [];\n    this.n_dumps = 0;\n    this.cur = -1;\n    this.is_folded = true;\n  },\n\n  is_opc: function(obj){\n    return (obj instanceof Array && typeof(obj[0]) == 'string');\n  },\n\n  dump_pad: \"&nbsp;&nbsp;&nbsp;\",\n  dump_opc: function(obj, level, nested){\n    var s=\"\";\n    var pad1=\"\", pad2=\"\";\n    var level = level || 0;\n    var nested = nested || false;\n    _.times(level, _.bind(function(){ pad1 += this.dump_pad; }, this));\n    _.times((level+1), _.bind(function(){ pad2 += this.dump_pad; }, this));\n\n    s += pad1 + '[<span class=\"dump_opecode\">' + obj[0] + '</span>';\n    var i = 1;\n    while(!(obj[i] instanceof Array) && i<obj.length){\n      if(obj[0] == \"constant\")\n        s += \"&nbsp;<span class='dump_constant'>\" + \n             this.dump_obj(obj[i]) + \"</span>\";\n      else\n        s += \"&nbsp;\" + this.dump_obj(obj[i]);\n      i++;\n    }\n    if(i < obj.length) s += '<br>\\n';\n    for(; i<obj.length; i++){\n      if(this.is_opc(obj[i])){\n        s += this.dump_opc(obj[i], (i == obj.length-1 ? level : level+1), true);\n      }\n      else{\n        s += (i == obj.length-1) ? pad1 : pad2;\n        s += this.dump_obj(obj[i]);\n      }\n      if(i != obj.length-1) s += \"<br>\\n\";\n    }\n    s += \"]\";\n    return (nested ? s : this.add_fold(s));\n  },\n\n  fold_limit: 20,\n  add_fold: function(s){\n    var lines = s.split(/<br>/gmi);\n\n    if(lines.length > this.fold_limit){\n      var fold_btn   = \" <span style='text-decoration:underline; color:blue; cursor:pointer;'\" +\n                           \"onclick='BiwaScheme.Dumper.toggle_fold(\"+this.n_folds+\")'>more</span>\";\n      var fold_start = \"<div style='display:none' class='fold\"+this.n_folds+\"'>\";\n      var fold_end   = \"</div>\";\n      this.n_folds++;\n      return [\n        lines.slice(0, this.fold_limit).join(\"<br>\"), fold_btn,\n        fold_start, lines.slice(this.fold_limit).join(\"<br>\"), fold_end\n      ].join(\"\");\n    }\n    else{\n      return s;\n    }\n  },\n\n  stack_max_len: 80,\n  dump_stack: function(stk, size){\n    if(stk === null || stk === undefined) return BiwaScheme.inspect(stk);\n    var s = \"<table>\";\n\n    // show the 'physical' stack top\n    if (stk.length == 0){\n      s += \"<tr><td class='dump_dead'>(stack is empty)</td></tr>\";\n    }\n    else if (size < stk.length){\n      var l = stk.length - 1;\n      s += \"<tr><td class='dump_dead'>[\" + l + \"]</td>\" +\n           \"<td class='dump_dead'>\" + \n           _.str.truncate(this.dump_obj(stk[l]), this.stack_max_len) +\n           \"</td></tr>\";\n    }\n\n    // show the element in the stack\n    for(var i=size-1; i >= 0; i--){\n      s += \"<tr><td class='dump_stknum'>[\" + i + \"]</td>\" +\n           \"<td>\" + _.str.truncate(this.dump_obj(stk[i]), this.stack_max_len) +\n           \"</td></tr>\";\n    }\n    return s + \"</table>\";\n  },\n\n  dump_object: function(obj){\n    var a = [];\n    for(var k in obj){\n      //if(this.prototype[k]) continue;\n      a.push( k.toString() );//+\" => \"+this[k].toString() );\n    }\n    return \"#<Object{\"+a.join(\",\")+\"}>\";\n  },\n\n  dump_closure: function(cls){\n    if(cls.length == 0) return \"[]\";\n\n    var cls_num = null;\n    for(var i=0; i<this.closures.length; i++){\n      if(this.closures[i] == cls) cls_num = i;\n    }\n    if(cls_num == null){\n      cls_num = this.closures.length;\n      this.closures.push(cls);\n    }\n\n    var c = _.clone(cls);\n    var body = c.shift();\n    return [\n      \"c\", cls_num, \" <span class='dump_closure'>free vars :</span> \",\n      this.dump_obj(c), \" <span class='dump_closure'>body :</span> \",\n      _.str.truncate(this.dump_obj(body), 100)\n    ].join(\"\");\n  },\n\n  dump_obj: function(obj){\n    if(obj && typeof(obj.to_html) == 'function')\n      return obj.to_html();\n    else{\n      var s = write_ss(obj, true); //true=Array mode\n      if(s == \"[object Object]\") s = this.dump_object(obj);\n      return _.escape(s);\n    }\n  },\n\n  dump: function(obj){\n    var s = \"\";\n    if(obj instanceof Object){\n      s += \"<table>\";\n\n      // header\n      s += \"<tr><td colspan='4'>\" + \n           \"<a href='#' class='header'>\" +\n           \"#\"+this.n_dumps+\"</a></td></tr>\";\n\n      // registers\n      _.each(_.keys(obj), _.bind(function(key){\n        var value = obj[key];\n        if(key!=\"x\" && key != \"stack\"){\n          value = (key==\"c\" ? this.dump_closure(value)\n                            : this.dump_obj(value));\n          s += \"<tr><td>\" + key + \": </td>\" +\n               \"<td colspan='3'>\" + value + \"</td></tr>\";\n        }\n      }, this));\n      s += \"<tr><td>x:</td><td>\" +\n           (this.is_opc(obj[\"x\"]) ? this.dump_opc(obj[\"x\"])\n                                  : this.dump_obj(obj[\"x\"])) +\n           \"</td>\";\n\n      // stack\n      s += \"<td style='border-left: 1px solid black'>stack:</td><td>\" +\n           this.dump_stack(obj[\"stack\"], obj[\"s\"]) +\n           \"</td></tr>\";\n      s += \"</table>\";\n    }\n    else{\n      s = _.escape(BiwaScheme.inspect(obj)) + \"<br>\\n\";\n    }\n    var dumpitem = $(\"<div/>\", { class: (\"dump\" + this.n_dumps) });\n    dumpitem.html(s);\n    $(this.dumparea).append(dumpitem);\n    (_.bind(function(n){\n        $(\".header\", this.dump_el(this.n_dumps)).click(_.bind(function(){\n        this.dump_move_to(n);\n        this.dump_fold();\n      }, this));\n    }, this))(this.n_dumps);\n    dumpitem.hide();\n    this.n_dumps++;\n  },\n\n  //\n  // UI\n  //\n  dump_el: function(n) {\n    return $(\".dump\"+n, this.dumparea);\n  },\n  dump_move_to: function(n){\n    if (0 <= n && n <= this.n_dumps){\n      this.dump_el(this.cur).hide();\n      this.cur = n;\n      this.dump_el(this.cur).show();\n    }\n  },\n\n  dump_move: function(dir){\n    if(0 <= this.cur && this.cur < this.n_dumps)\n      this.dump_el(this.cur).hide();\n\n    if(0 <= this.cur+dir && this.cur+dir < this.n_dumps)\n      this.cur += dir;\n\n    this.dump_el(this.cur).show();\n  },\n\n  dump_fold: function(){\n    for(var i=0; i<this.n_dumps; i++)\n      if(i!=this.cur) this.dump_el(i).hide();\n\n    this.is_folded = true;\n  },\n\n  dump_unfold: function(){\n    for(var i=0; i<this.n_dumps; i++)\n      this.dump_el(i).show();\n\n    this.is_folded = false;\n  },\n\n  dump_toggle_fold: function(){\n    if(this.is_folded)\n      this.dump_unfold();\n    else\n      this.dump_fold();\n  }\n});\n} // with(BiwaScheme);\n\nBiwaScheme.Dumper.toggle_fold = function(n){\n  $(\".fold\"+n, this.dumparea).toggle();\n};\nConsole = {}\n\nBiwaScheme.Port.current_error =\nBiwaScheme.Port.current_output = new BiwaScheme.Port.CustomOutput(\n  function (str) {\n      print.error(str);\n    // var console;\n    // var text;\n    // console = $(\"#bs-console\");\n    // if (console[0]) {\n    // \ttext = _.escape(str);\n    // \tvar span = $(\"<span>\");\n    // \tspan.html(text.replace(/\\n/g,\"<br>\").replace(/ /g,\"&nbsp;\"));\n    // \tconsole.append(span);\n    // }\n  }\n);\n\nBiwaScheme.Port.current_input = new BiwaScheme.Port.CustomInput(\n  function (callback) {\n    var form = $(\"<form/>\");\n    form.html(\"<input id='webscheme-read-line' type='text'><input type='submit' value='ok'>\");\n    $(\"#bs-console\").append(form);\n    form.submit(function(){\n      var input = $(\"#webscheme-read-line\").val();\n      form.remove();\n      callback(input);\n      return false;\n    });\n  }\n);\n\n\nConsole.puts = function(str, no_newline) {\n  BiwaScheme.Port.current_output.put_string(str + (no_newline ? \"\" : \"\\n\"))\n};\n\nConsole.p = function (/*ARGS*/){\n  BiwaScheme.Port.current_output.put_string(\n    \"p> \"+_.map(_.toArray(arguments), BiwaScheme.inspect).join(\" \")\n  );\n};\n//\n// release_initializer.js - read user's program and eval it (if it exists)\n//\n// This file is put on the end the lib/biwascheme.js.\n//\n(function(){ //local namespace\n  // var dumper = null;\n  // if ($(\"#biwascheme-debugger\")[0]) {\n  //   dumper = new BiwaScheme.Dumper($(\"#biwascheme-debugger\")[0]);\n  // }\n\n  // Error handler (show message to console div)\n  var onError = function(e, state){\n    BiwaScheme.Port.current_error.put_string(e.message + \"\\n\");\n    if (dumper) {\n      dumper.dump(state);\n      dumper.dump_move(1);\n    } else if (typeof(console) !== \"undefined\" && console.error) {\n      print.error(e.message);\n    } else {\n      throw(e);\n    }\n  };\n\n  var run = function(script) {\n      var intp = new BiwaScheme.Interpreter(onError);\n    try{\n        intp.evaluate(script, log);\n    }\n    catch(e){\n      onError(e);\n    }\n  };\n\n    run(global.input);\n})();\n"
}