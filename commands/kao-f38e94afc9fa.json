{
    "locked": false,
    "starred": false,
    "name": "kao",
    "command": "// © 2042 do not steal\n\nconst {\n    str,\n    char,\n    digits,\n    possibly,\n    sequenceOf,\n    regex,\n    anythingExcept,\n    anyOfString,\n    many1,\n    many,\n    choice,\n    whitespace,\n    between,\n    recursiveParser,\n} = require('arcsecond');\n\nconst delim = (prefix, surround) => (\n    between(str(`${prefix}${surround}`))(char(surround)) (\n        many(choice([\n            str(`\\\\${surround}`).map(() => surround),\n            anythingExcept(char(surround)),\n        ]))\n    ).map(arr => arr.join``)\n);\n\n// ascii\n\nconst asciiCode = choice([\n    sequenceOf([\n        str('@x'),\n        regex(/^[0-9a-fA-F]+/g),\n    ]).map(([_, h]) => String.fromCodePoint(parseInt(h, 16))),\n    sequenceOf([\n        char('@'),\n        digits,\n    ]).map(([_, d]) => String.fromCodePoint(d)),\n    delim('@', \"'\").map(ch => {\n        if (!ch) return '✖';\n        const code = ch.codePointAt(0);\n        return `${code}-0x${code.toString(16)}-${code.toString(36)}`;\n    }),\n    delim('', '`').map(ch => String.fromCodePoint(parseInt(ch || 0, 36))),\n]);\n\n// text replacement\n\nconst normal = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789()';\nconst aesthetic = 'ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ０１２３４５６７８９';\nconst sup = 'ᴬᴮᶜᴰᴱᶠᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾQᴿˢᵀᵁⱽᵂˣʸᶻᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖqʳˢᵗᵘᵛʷˣʸᶻ⁰¹²³⁴⁵⁶⁷⁸⁹⁽⁾';\nconst italic = [...'𝒜𝐵𝒞𝒟𝐸𝐹𝒢𝐻𝐼𝒥𝒦𝐿𝑀𝒩𝒪𝒫𝒬𝑅𝒮𝒯𝒰𝒱𝒲𝒳𝒴𝒵𝒶𝒷𝒸𝒹𝑒𝒻𝑔𝒽𝒾𝒿𝓀𝓁𝓂𝓃𝑜𝓅𝓆𝓇𝓈𝓉𝓊𝓋𝓌𝓍𝓎𝓏'];\nconst boldItalic = [...'𝓐𝓑𝓒𝓓𝓔𝓕𝓖𝓗𝓘𝓙𝓚𝓛𝓜𝓝𝓞𝓟𝓠𝓡𝓢𝓣𝓤𝓥𝓦𝓧𝓨𝓩𝓪𝓫𝓬𝓭𝓮𝓯𝓰𝓱𝓲𝓳𝓴𝓵𝓶𝓷𝓸𝓹𝓺𝓻𝓼𝓽𝓾𝓿𝔀𝔁𝔂𝔃'];\nconst dia = 'ÄßÇÐÈ£GHÌJKLMñÖþQR§†ÚVW×¥Zåß¢Ðê£ghïjklmñðþqr§†µvwx¥z'\n\nconst convertText = (name, charset) => {\n    return (\n        delim(name, `'`).map(str => (\n            [...str].map(ch => charset[normal.indexOf(ch)] || ch).join``\n        ))\n    );\n};\n\n// flip\n\nconst flipped = { '∀': 'A', B: 'ꓭ', Ɔ: 'C', D: 'ꓷ', Ǝ: 'E', Ⅎ: 'F', פ: 'G', H: 'H', I: 'I', ſ: 'J', ʞ: 'K', '˥': 'L', W: 'M', N: 'N', O: 'O', Ԁ: 'P', Q: 'Ὸ', R: 'ꓤ', S: 'S', '┴': 'T', '∩': 'U', Λ: 'V', M: 'W', X: 'X', '⅄': 'Y', Z: 'Z', a: '\\u0250', b: 'q', c: '\\u0254', d: 'p', e: '\\u01dd', f: '\\u025f', g: 'ƃ', h: '\\u0265', i: '\\u0131', j: 'ɾ', k: 'ʞ', l: 'ן', m: '\\u026f', n: 'u', o: 'o', p: 'd', q: 'b', r: '\\u0279', s: 's', t: '\\u0287', u: 'n', v: '\\u028c', w: '\\u028d', x: 'x', y: '\\u028e', z: 'z', '0': '0', Ɩ: '1', ᄅ: '2', Ɛ: '3', ㄣ: '4', ϛ: '5', '9': '6', ㄥ: '7', '8': '8', '6': '9', '¿': '?', '¡': '!', '[': ']', '(': ')', '{': '}', \"'\": ',', '<': '>', '^': 'v', };\n\nObject.entries(flipped).forEach(([k, v]) => {\n    k in flipped || (flipped[k] = v);\n});\n\nconst fliptext = delim('f', `'`).map(str => (\n    [...str].reverse().map(ch => flipped[ch] || ch).join``\n));\n\nconst charset = (start, length) => Array.from({ length }, (_, i) => String.fromCodePoint(start + i)).join``;\n\nconst textReplacement = choice([\n    delim('t', \"'\"), // none\n    convertText('i', italic),\n    convertText('bi', boldItalic),\n    convertText('s', sup),\n    convertText('d', dia),\n    convertText('a', aesthetic),\n    convertText('h', charset(0x3041, 83)), // hiragana\n    convertText('k', charset(0x4e00, 0x89a0)), // kanji\n    fliptext, // f\n]);\n\n// charmaps\n\nconst charmap = (trigger, lookup, _default = trigger) => (\n    sequenceOf([\n        str(trigger),\n        possibly(choice(Object.keys(lookup).map(str))),\n    ]).map(([_, key]) => key ? lookup[key] : _default)\n);\n\nconst star = charmap('*', {\n    '**': '⊃━☆ﾟ.*･｡',\n    '!': '🎉',\n    '\"': '✴',\n    '£': '✯',\n    '*': '★',\n    '$': '🗲',\n    '#': '✿',\n    '+': '✧',\n});\n\nconst heart = charmap('<3', {\n    '!': '♥',\n    '\"': '❥',\n}, '❤');\n\nconst tilde = charmap('~', {\n    '~': '～',\n    '`': '～́̀',\n});\n\nconst emotes = charmap(':', {\n    ')': 'ツ',\n});\n\nconst script = recursiveParser(() => possibly(many1(choice([\n    textReplacement,\n    faces,\n    // charsets\n    star,\n    heart,\n    tilde,\n    emotes,\n    // misc\n    asciiCode,\n    whitespace,\n    sequenceOf([ char('.'), regex(/^./) ]).map(([_, c]) => c), // oneChar\n    str('ZWJ').map(()=> String.fromCharCode(0x200b)),\n    str('BELL').map(()=> String.fromCharCode(0x7)),\n]))))\n    .map(arr => arr ? arr.join('') : '');\n\nconst face = (ident) => (fn) => sequenceOf([\n    sequenceOf([\n        ident,\n        many(anyOfString('!\"£*')),\n        char('('),\n    ]),\n    possibly(sequenceOf([script, char('^')]).map(([str])=>str)),\n    script,\n    possibly(sequenceOf([char('$'), script]).map(([_, str])=>str)),\n    possibly(sequenceOf([char('?'), script]).map(([_, str])=>str)),\n    char(')'),\n]).map(([[name, mods], left, center, right, optional ]) => {\n    const pound = mods.includes('£');\n    const hideWrap = mods.includes('*') || pound;\n    const hideArms = mods.includes('\"');\n    const hideFace = (str) => (mods.includes('!') || pound) ? '' : str;\n    const face = fn({\n        name,\n        dir: /[A-Z]/.test(name),\n        left: (def) => left == null ? hideFace(def) : left,\n        eye: (str) => hideFace(str),\n        center: (def) => center || hideFace(def),\n        right: (def) => right == null ? hideFace(def) : right,\n        arm: (str) => hideArms ? '' : str,\n        wrap: (str) => hideWrap ? str.join`` : `(${str.join``})`,\n        obj: (str) => optional == null ? str : optional,\n    })\n    return Array.isArray(face) ? face.join`` : face;\n});\n\nconst cute = face(anyOfString('cC'))(({ dir, left, right, center, wrap, eye }) => {\n    const eye_ = eye(dir ? '◔' : '◕');\n    const left_ = dir ? '✿' : undefined;\n    const right_ = dir ? undefined : '✿';\n    return wrap([left(left_), eye_, center('◡'), eye_, right(right_)]);\n});\n\nconst cool = face(char('x'))(({ left, center, right, wrap, eye }) => {\n    return wrap([left('⌐'), eye('■'), center('_'), eye('■'), right()]);\n});\n\nconst sad = face(char('a'))(({ center, eye }) => {\n    return [eye(`ʘ`), center('︵'), eye(`ʘ`)];\n});\n\nconst lod = face(char('d'))(({ center, eye }) => {\n    return [eye(`ಠ`), center('_'), eye(`ಠ`)];\n});\n\nconst actually = face(char('z'))(({ left, center, right, wrap, arm, eye }) => {\n    return [wrap([left(arm('~')), eye('˘'), center('▾'), eye('˘'), right()]), arm('~')];\n});\n\nconst shrug = face(char('s'))(({ left, center, right, wrap, arm }) => {\n    return [arm(`¯\\\\_`), wrap([left(), center('ツ'), right()]), arm('_/¯')];\n});\n\nconst lenny = face(char('v'))(({ left, center, right, wrap, eye }) => {\n    return wrap([left(), eye(' ͡°'), center(' ͜ʖ'), eye(' ͡°'), right()]);\n});\n\n\nconst flip = face(anyOfString('fF'))(({ dir, left, center, right, wrap, obj, arm, eye }) => {\n    if (dir) {\n        return [obj('┬──┬◡'), arm('ﾉ'), wrap([\n            left(), eye('° '), center('-'), eye('°'), right(arm('ﾉ'))\n        ])]\n    }\n    return [wrap([\n        left(arm('╯')), eye('°'), center('□'), eye('°'), right()\n    ]), arm(' ╯'), '︵ ', obj('┻━┻')]\n});\n\nconst dumb = face(anyOfString('qQ'))(({ dir, left, right, center, wrap, eye, arm }) => {\n    return [arm('ヘ '), wrap([\n        left(), eye('°。'[+dir]), center('□'), eye('。°'[+dir]), right()\n    ]), arm(' ヘ')];\n});\n\nconst wizard = face(char('w'))(({ left, right, center, wrap, eye, arm, obj }) => {\n    return [wrap([\n        left(arm('∩')), eye('｀'), center('-'), eye('´'), right()\n    ]), arm('⊃'), '━☆ﾟ.*･｡ﾟ ', obj('')];\n});\n\nconst faces = choice([\n    sad,\n    lod,\n    lenny,\n    shrug,\n    cool,\n    actually,\n    cute,\n    flip,\n    dumb,\n    wizard,\n]);\n\nfunction parser(str) {\n    const { result, index } = script.run(str);\n    return str.length == index ? result : result + '// ' + str.slice(index);\n}\n\nprint(parser(input))"
}