{
    "name": "golf.scores",
    "command": "const tasks = IRC.require('golf.tasks');\n\ninput = input.trim() || IRC.message.from;\n\nif (input == 'global') {\n    \n    function orderScores(scoreList) {\n        return _.sortBy(scoreList, (d) => +d.bytes)\n            .reduce((acc, cur) => {\n                const exists = acc.findIndex((d) => d.bytes === cur.bytes);\n                if (exists !== -1) {\n                    acc[exists].push(cur);\n                } else {\n                    acc.push([cur]);\n                }\n                return acc;\n            }, [])\n    }\n\n    const users = new Set([]);\n    let scores = Object.keys(tasks).map(d => IRC.require('module.loadObject')(`scores-${d}`)[0]);\n    scores = scores.map((score) => {\n        Object.keys(score).forEach(d => { score[d].from = d; users.add(d)});\n        return orderScores(score);\n    });\n\n\n    scores = [...users].map(user => {\n        const totalRank = scores.reduce((acc, score) => {\n            index = score.findIndex(a => ~a.findIndex(b => b.from == user));\n            return acc + (index == -1 ? 10 : index)\n        }, 0);\n        return { from: user, bytes: totalRank }\n    })\n    scores = _.sortBy(scores, (d) => +d.bytes);\n    scores = scores.slice(0, IRC.command.params[0] || Infinity);\n        \n    const colours = ['{y}','{gr}','{o}'];\n    scores.forEach(({from, bytes}, i)=> {\n        const pad = 23 - from.length - (String(i+1).length - 1);\n        print(`${i+1}. ${colours[i]||''}${from.replace(/\\w+/g, IRC.breakHighlight)}{/}{bo}${'.'.repeat(pad>0?pad:0)}{/}{y}${+bytes}`)\n    });\n\n    \n} else if (!tasks[input]) {\n    const scores = [];\n    Object.keys(tasks)\n        .map(d => [d, IRC.require('module.loadObject')(`scores-${d}`)[0]])\n        .forEach(([name, data]) => {\n            const found = data[input];\n            if (found) {\n                scores.push(`{bo}${name}:{/} {dc}${found.bytes}{/}`);\n            }\n        });\n        \n    if (!scores.length) {\n        throw new Error('no task by this name / no scores for this user');\n    }\n        \n    print(scores.join`, `)\n    \n} else {\n    const showAll = IRC.command.params[0] == 'all';\n    const scoreList = Object.entries(IRC.require('module.loadObject')(`scores-${input}`)[0])\n        .map(([key, value]) => ({ from: key, ...value }));\n    const scores = _.sortBy(scoreList, (d) => +d.bytes)\n    .reduce((acc, cur) => {\n        const exists = acc.findIndex((d) => d.bytes === cur.bytes);\n        if (exists !== -1) {\n            acc[exists].from += `, ${cur.from}`;\n        } else {\n            cur.key = cur.from\n            acc.push(cur);\n        }\n        return acc;\n    }, []).slice(0, showAll ? Infinity : IRC.command.params[0] || 5);\n    \n    const longest = Math.max(scores.reduce((acc, cur) => Math.max(acc, cur.from.length), 0) + 2, 20);\n        \n    print(`{u}Leaderboard{/}`);\n    const colours = ['{y}','{gr}','{o}'];\n    scores.forEach(({from, bytes}, i)=> {\n        const pad = longest - from.length - (String(i+1).length - 1);\n        print(`${i+1}. ${colours[i]||''}${from.replace(/\\w+/g, IRC.breakHighlight)}{/}{bo}${'.'.repeat(pad>0?pad:0)}{/}{y}${+bytes}`)\n    });\n}\n\n",
    "locked": false,
    "starred": false
}