{
    "name": "golf.scores",
    "command": "const { getLeaderboard } = IRC.require('golf.store');\nconst { getTask, taskList, taskListDisplay } = IRC.require('golf.tasks');\nconst leaderboard = IRC.require('module.leaderboard');\n\nconst [type, modifiers = ''] = (input.trim() || IRC.message.from).split` `;\nconst showAll = modifiers.includes('all');\nconst showPosition = modifiers.includes('position');\n\nconst task = getTask(type);\n\nif (task) {\n    const scores = getLeaderboard(type)\n        .map(entry => ({\n            score: entry.bytes,\n            name: entry.scores.map(d => d.from).join`, `,\n            entry,\n        }));\n\n    const publicStr = task.public ? ' {dc}[PUBLIC]{/}' : '';\n    const hasPublicScore = scores[0] && scores[0].name === '##jsgolf';\n    const fmtRank = ({ entry: { position, rank }}, index) => { \n        const value = showPosition ? position : rank;\n        return hasPublicScore ? value - 1 : value;\n    }\n\n    print(leaderboard({\n        scores,\n        title: `Leaderboard - ${IRC.colors.nick(task.displayName, !1)}${publicStr}`,\n        reverse: true,\n        limit: showAll ? Infinity : 5,\n        fmtRank,\n    }));\n} else {\n    const userScores = [];\n    taskList.map(key => getLeaderboard(key))\n        .forEach((board, i) => {\n            const key = taskListDisplay[i];\n            board.forEach(entry => {\n                if (entry.scores.find(score => score.from === type)) {\n                    userScores.push([key, entry]);\n                }\n            });\n        });\n\n    if (!userScores.length) {\n        throw 'no task by this name / no scores for this user'\n    }\n\n    const desc = '{bo}task{/}:{y}score{/}:{g}rank{/}:{dg}position{/}';\n    // const bytesUsed = userScores.reduce(d => )\n    // const avgRank = \n    // const avgPos\n    const scores = userScores.map(([taskName, { bytes, position, rank }]) => {\n        return `${IRC.colors.nick(taskName, false)}:{y}${bytes}{/}:{g}${rank}{/}:{dg}${position}{/}`;\n    }).join` `;\n\n    print(`${desc} - ${scores}`);\n}\n\n// const tasks = IRC.require('golf.tasks');\n\n// input = input.trim() || IRC.message.from;\n\n// if (input == 'global') {\n    \n//     function orderScores(scoreList) {\n//         return _.sortBy(scoreList, (d) => +d.bytes)\n//             .reduce((acc, cur) => {\n//                 const exists = acc.findIndex((d) => d.bytes === cur.bytes);\n//                 if (exists !== -1) {\n//                     acc[exists].push(cur);\n//                 } else {\n//                     acc.push([cur]);\n//                 }\n//                 return acc;\n//             }, [])\n//     }\n\n//     const users = new Set([]);\n//     let scores = Object.keys(tasks).map(d => IRC.require('module.loadObject')(`scores-${d}`)[0]);\n//     scores = scores.map((score) => {\n//         Object.keys(score).forEach(d => { score[d].from = d; users.add(d)});\n//         return orderScores(score);\n//     });\n\n//     scores = [...users].map(user => {\n//         const totalRank = scores.reduce((acc, score) => {\n//             index = score.findIndex(a => ~a.findIndex(b => b.from == user));\n//             return acc + (index == -1 ? 10 : index)\n//         }, 0);\n//         return { from: user, bytes: totalRank }\n//     })\n//     scores = _.sortBy(scores, (d) => +d.bytes);\n//     scores = scores.slice(0, IRC.command.params[0] || Infinity);\n        \n//     const colours = ['{y}','{gr}','{o}'];\n//     scores.forEach(({from, bytes}, i)=> {\n//         const pad = 23 - from.length - (String(i+1).length - 1);\n//         print(`${i+1}. ${colours[i]||''}${from.replace(/\\w+/g, IRC.breakHighlight)}{/}{bo}${'.'.repeat(pad>0?pad:0)}{/}{y}${+bytes}`)\n//     });",
    "locked": false,
    "starred": false
}